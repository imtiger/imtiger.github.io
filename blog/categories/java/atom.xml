<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | I'm Tiger,一个有理想爱折腾的程序员!]]></title>
  <link href="http://imtiger.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://imtiger.github.io/"/>
  <updated>2013-10-16T17:21:42+08:00</updated>
  <id>http://imtiger.github.io/</id>
  <author>
    <name><![CDATA[imtiger]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Tomcat总体结构（Tomcat源代码阅读系列之二）]]></title>
    <link href="http://imtiger.github.io/blog/2013/10/16/tomcat-server-start-process-and-shutdown/"/>
    <updated>2013-10-16T14:33:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2013/10/16/tomcat-server-start-process-and-shutdown</id>
    <content type="html"><![CDATA[<p>我们在<a href="/blog/2013/10/14/run-tomcat-in-idea-or-eclipse/">在IntelliJ IDEA 和 Eclipse运行tomcat 7源代码</a>一文中介绍了如何在intelliJ IDEA 和 Eclipse中运行Tomcat源代码，本文介绍一下Tomcat的总体结构。</p>

<blockquote><p>本文没有特别指明的地方，源代码都是针对tomcat7.0.42来说。</p></blockquote>

<h1>Tomcat的总体结构</h1>

<p>Tomcat即是一个Http服务器也是一个Servlet容器，它的总体结构我们可以用下图来描述：
<img class="center" src="/images/2013/10/16/TomcatArchitecture.png"></p>

<!-- more -->


<p>通过上图我们可以看出Tomcat中主要涉及Server,Service,Engine,Connector,Host,Context组件，之前用过Tomcat的童鞋是不是觉得这些组件的名称有点似曾相识的赶脚，没赶脚？！您再想想。好吧，不用你想了，我来告诉你吧。其实在Tomcat二进制分发包解压后,在conf目录中有一个server.xml文件，你打开它瞄两眼看看，是不是发现server.xml文件中已经包含了上述的几个名称。我拿我本地Tomcat7.0.42分发包中的server.xml来具体分析一下，它的内容如下：
```xml conf/server.xml(Tomcat 7.0.42)
&lt;?xml version=&lsquo;1.0&rsquo; encoding=&lsquo;utf-8&rsquo;?></p>

<!--
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->


<!-- Note:  A "Server" is not itself a "Container", so you may not
     define subcomponents such as "Valves" at this level.
     Documentation at /docs/config/server.html
 -->


<p><Server port="8005" shutdown="SHUTDOWN">
  <!-- Security listener. Documentation at /docs/config/listeners.html
  <Listener className="org.apache.catalina.security.SecurityListener" />
  &mdash;>
  <!--APR library loader. Documentation at /docs/apr.html -->
  <Listener className="org.apache.catalina.core.AprLifecycleListener" SSLEngine="on" />
  <!--Initialize Jasper prior to webapps are loaded. Documentation at /docs/jasper-howto.html -->
  <Listener className="org.apache.catalina.core.JasperListener" />
  <!-- Prevent memory leaks due to use of particular java/javax APIs-->
  <Listener className="org.apache.catalina.core.JreMemoryLeakPreventionListener" />
  <Listener className="org.apache.catalina.mbeans.GlobalResourcesLifecycleListener" />
  <Listener className="org.apache.catalina.core.ThreadLocalLeakPreventionListener" /></p>

<p>  &lt;!&mdash; Global JNDI resources</p>

<pre><code>   Documentation at /docs/jndi-resources-howto.html
</code></pre>

<p>  &mdash;>
  <GlobalNamingResources></p>

<pre><code>&lt;!-- Editable user database that can also be used by
     UserDatabaseRealm to authenticate users
--&gt;
&lt;Resource name="UserDatabase" auth="Container"
          type="org.apache.catalina.UserDatabase"
          description="User database that can be updated and saved"
          factory="org.apache.catalina.users.MemoryUserDatabaseFactory"
          pathname="conf/tomcat-users.xml" /&gt;
</code></pre>

<p>  </GlobalNamingResources></p>

<p>  &lt;!&mdash; A &ldquo;Service&rdquo; is a collection of one or more &ldquo;Connectors&rdquo; that share</p>

<pre><code>   a single "Container" Note:  A "Service" is not itself a "Container",
   so you may not define subcomponents such as "Valves" at this level.
   Documentation at /docs/config/service.html
</code></pre>

<p>   &mdash;>
  <Service name="Catalina"></p>

<pre><code>&lt;!--The connectors can use a shared executor, you can define one or more named thread pools--&gt;
&lt;!--
&lt;Executor name="tomcatThreadPool" namePrefix="catalina-exec-"
    maxThreads="150" minSpareThreads="4"/&gt;
--&gt;


&lt;!-- A "Connector" represents an endpoint by which requests are received
     and responses are returned. Documentation at :
     Java HTTP Connector: /docs/config/http.html (blocking &amp; non-blocking)
     Java AJP  Connector: /docs/config/ajp.html
     APR (HTTP/AJP) Connector: /docs/apr.html
     Define a non-SSL HTTP/1.1 Connector on port 8080
--&gt;
&lt;Connector port="8080" protocol="HTTP/1.1"
           connectionTimeout="20000"
           redirectPort="8443" /&gt;
&lt;!-- A "Connector" using the shared thread pool--&gt;
&lt;!--
&lt;Connector executor="tomcatThreadPool"
           port="8080" protocol="HTTP/1.1"
           connectionTimeout="20000"
           redirectPort="8443" /&gt;
--&gt;
&lt;!-- Define a SSL HTTP/1.1 Connector on port 8443
     This connector uses the JSSE configuration, when using APR, the
     connector should be using the OpenSSL style configuration
     described in the APR documentation --&gt;
&lt;!--
&lt;Connector port="8443" protocol="HTTP/1.1" SSLEnabled="true"
           maxThreads="150" scheme="https" secure="true"
           clientAuth="false" sslProtocol="TLS" /&gt;
--&gt;

&lt;!-- Define an AJP 1.3 Connector on port 8009 --&gt;
&lt;Connector port="8009" protocol="AJP/1.3" redirectPort="8443" /&gt;


&lt;!-- An Engine represents the entry point (within Catalina) that processes
     every request.  The Engine implementation for Tomcat stand alone
     analyzes the HTTP headers included with the request, and passes them
     on to the appropriate Host (virtual host).
     Documentation at /docs/config/engine.html --&gt;

&lt;!-- You should set jvmRoute to support load-balancing via AJP ie :
&lt;Engine name="Catalina" defaultHost="localhost" jvmRoute="jvm1"&gt;
--&gt;
&lt;Engine name="Catalina" defaultHost="localhost"&gt;

  &lt;!--For clustering, please take a look at documentation at:
      /docs/cluster-howto.html  (simple how to)
      /docs/config/cluster.html (reference documentation) --&gt;
  &lt;!--
  &lt;Cluster className="org.apache.catalina.ha.tcp.SimpleTcpCluster"/&gt;
  --&gt;

  &lt;!-- Use the LockOutRealm to prevent attempts to guess user passwords
       via a brute-force attack --&gt;
  &lt;Realm className="org.apache.catalina.realm.LockOutRealm"&gt;
    &lt;!-- This Realm uses the UserDatabase configured in the global JNDI
         resources under the key "UserDatabase".  Any edits
         that are performed against this UserDatabase are immediately
         available for use by the Realm.  --&gt;
    &lt;Realm className="org.apache.catalina.realm.UserDatabaseRealm"
           resourceName="UserDatabase"/&gt;
  &lt;/Realm&gt;

  &lt;Host name="localhost"  appBase="webapps"
        unpackWARs="true" autoDeploy="true"&gt;

    &lt;!-- SingleSignOn valve, share authentication between web applications
         Documentation at: /docs/config/valve.html --&gt;
    &lt;!--
    &lt;Valve className="org.apache.catalina.authenticator.SingleSignOn" /&gt;
    --&gt;

    &lt;!-- Access log processes all example.
         Documentation at: /docs/config/valve.html
         Note: The pattern used is equivalent to using pattern="common" --&gt;
    &lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"
           prefix="localhost_access_log." suffix=".txt"
           pattern="%h %l %u %t &amp;quot;%r&amp;quot; %s %b" /&gt;

  &lt;/Host&gt;
&lt;/Engine&gt;
</code></pre>

<p>  </Service>
</Server></p>

<p>```
接下来我们就根据上图以及conf/server.xml的内容来一步步描述一下上面所说的各种组件吧。</p>

<h2>Server</h2>

<p>首先闪联登场的是咋们的Server大哥（大家能给点掌声吗？），Server是Tomcat中最顶层的组件，它可以包含多个Service组件。在Tomcat源代码中Server组件对应源码中的<code>org.apache.catalina.core.StandardServer</code>类。StandardServer的继承关系图如下图所示：
<img class="center" src="/images/2013/10/16/StandardServer.jpg"></p>

<h2>Service</h2>

<p>接下来咋们来看看Service组件，Service组件相当于Connetor和Engine组件的包装器，它将一个或者多个Connector组件和一个Engine建立关联。缺省的的配置文件中，定义一个叫<code>Catalina</code>的服务，并将Http,AJP这两个Connector关联到了一个名为<code>Catalina</code>的Engine.Service组件对应Tomcat源代码中的<code>org.apache.catalina.core.StandardService</code>,StandardService的继承关系图如下图所示：
<img class="center" src="/images/2013/10/16/StandardService.png"></p>

<h2>Connector</h2>

<p>既然Tomcat需要提供http服务，而我们知道http应用层协议最终都是需要通过TCP层的协议进行包传递的，而Connector正是Tomcat中监听TCP网络连接的组件，一个Connector会监听一个独立的端口来处理来自客户端的连接。缺省的情况下Tomcat提供了如下两个Connector。我们分别描述一下：</p>

<ol>
<li>HTTP/1.1<br/>
<code>&lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt;</code>
上面定义了一个Connector，它缺省监听端口8080,这个端口我们可以根据具体情况进行改动。<code>connectionTimeout</code>定义了连接超时时间，单位是毫秒，<code>redirectPort</code>定义了ssl的重定向接口，根据缺省的配置，Connector会将ssl请求重定向到8443端口。</li>
<li>AJP/1.3<br/>
AJP表示<code>Apache Jserv Protocol</code>,此连接器将处理Tomcat和Aapache http服务器之间的交互，这个连机器是用来处理我们将Tomcat和Apache http服务器结合使用的情况。假如在同样的一台物理Server上面部署了一台Apache http服务器和多台Tomcat服务器，通过Apache服务器来处理静态资源以及负载均衡的时候，针对不同的Tomcat实例需要AJP监听不同的端口。</li>
</ol>


<p>Connector对应源代码中的<code>org.apache.catalina.connector.Connector</code>,它的继承关系图如下所示：
<img class="center" src="/images/2013/10/16/Connector.png"></p>

<h2>Engine</h2>

<p>Tomcat中有一个容器的概念，而Engine,Host,Context都属于Contanier，我们先来说说最顶层的容器Engine.<br/>
一个Engine可以包含一个或者多个Host,也就是说我们一个Tomcat的实例可以配置多个虚拟主机。<br/>
缺省的情况下<code>&lt;Engine name="Catalina" defaultHost="localhost"&gt;</code>定义了一个名称为Cataline的Engine.Engine对应源代码中的<code>org.apache.catalina.core.StandardEngine</code>，它的继承关系图如下图所示：
<img class="center" src="/images/2013/10/16/StandardEngine.png"></p>

<h2>Host</h2>

<p>Host定义了一个虚拟主机，一个虚拟主机可以有多个Context，缺省的配置如下：<br/>
<code>&lt;Host name="localhost"  appBase="webapps" unpackWARs="true" autoDeploy="true"&gt;….&lt;/Host&gt;</code> 其中<code>appBase</code>为webapps，也就是<code>&lt;CATALINA_HOME&gt;\webapps</code>目录，<code>unpackingWARS</code>属性指定在appBase指定的目录中的war包都自动的解压，缺省配置为true,<code>autoDeploy</code>属性指定是否对加入到appBase目录的war包进行自动的部署，缺省为true.<br/>
Host对应源代码中的<code>org.apache.catalina.core.StandardHost</code>,它的继承关系图如下所示：
<img class="center" src="/images/2013/10/16/StandardHost.png"></p>

<h2>Context</h2>

<p>在Tomcat中，每一个运行的webapp其实最终都是以Context的形成存在，每个Context都有一个根路径和请求URL路径，Context对应源代码中的<code>org.apache.catalina.core.StandardContext</code>,它的继承关系图如下图所示：
<img class="center" src="/images/2013/10/16/StandardContext.png">
在Tomcat中我们通常采用如下的两种方式创建一个Context.下面分别描述一下：</p>

<ol>
<li>在<code>&lt;CATALINA-HOME&gt;\webapps</code>目录中创建一个目录，这个时候将自动创建一个context，默认context的访问url为<code>http://host:port/dirname</code>,你也可以通过在<code>ContextRoot\META-INF</code>中创建一个context.xml的文件，其中包含如下的内容来指定应用的访问路径。
<code>&lt;Context path="/yourUrlPath" /&gt;</code></li>
<li>conf\server.xml文件中增加context元素。
第二种创建context的方法，我们可以选择在server.xml文件的<code>&lt;Host&gt;</code>元素，比如我们在server.xml文件中增加如下内容：
<code>xml server.xml
     ......
     ......
     &lt;Context path="/mypath" docBase="/Users/tiger/develop/xxx" reloadable="true"&gt;
     &lt;/Context&gt;
   &lt;/Host&gt;
 &lt;/Engine&gt;
&lt;/Service&gt;
&lt;/Server&gt;
</code>
这样的话，我们就可以通过<code>http://host:port/mypath</code>访问上面配置的context了。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在IntelliJ IDEA 和 Eclipse运行tomcat 7源代码（Tomcat源代码阅读系列之一）]]></title>
    <link href="http://imtiger.github.io/blog/2013/10/14/run-tomcat-in-idea-or-eclipse/"/>
    <updated>2013-10-14T14:39:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2013/10/14/run-tomcat-in-idea-or-eclipse</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/10/14/apache_tomcat_bag.jpg">
在阅读Tomcat源代码之前，我们首先需要将Tomcat的源代码在IDE里面运行起来，这样方便我们阅读的过程中调试。本文总结一下在IDEA 或者 Eclipse中运行Tomcat源代码环境的搭建过程，同时我们通过Maven来负责项目的构建。</p>

<p>在进行搭建之前，我们首先来说一下总体的思路。我们知道Tomcat运行的时候，一部分是源代码编译以后的可运行的Jar,另外一部分则是运行时的环境（也就是我们从官方下载下来的二进制分发包中的一系列的配置文件以及目录结构，说的更直白点就是CATALINA_HOME环境变量指定的目录）,本文对于第一部分采用IntelliJ IDEA 运行tomcat-7.0.42 tag的源代码，而对于第二部分运行环境，我们则直接采用tomcat-7.0.42的二进制分发包。明白了上述的思路以后，咋们就来一步步的搭建吧。</p>

<!-- more -->


<p>首先咋们来看看搭建完成以后的总体的目录结构，然后再一步步的去分解搭建过程。笔者搭建完以后，最终的运行结构如下图所示：
<img class="center" src="/images/2013/10/14/project-structure.png"></p>

<p>下面分别解释一下上图工程结构中涉及到的文件和目录：</p>

<ol>
<li>.idea和tomcat-study.iml是IntelliJ IDEA的文件，如果你用Eclipse的话不会存在这两个东东 。</li>
<li>catalina-home是从官方下载的7.0.42的二进制分发包解压后的目录</li>
<li>target是Maven编译项目以后生成的文件夹，熟悉Maven的读者应该很熟悉此目录</li>
<li>tomcat-7.0.42-sourcecode是从Tomcat<a href="http://svn.apache.org/repos/asf/tomcat/tc7.0.x/tags/TOMCAT_7_0_42/">官方仓库</a>下载的tags的源代码</li>
<li>pom.xml是Maven的配置文件,此工程中有两个pom.xml，这里运用了Maven聚合的特性。</li>
</ol>


<p>了解了最终的结构以后，咋们就来一步步的搭建它吧。</p>

<h3>第一步 创建项目目录结构</h3>

<p>本文假设我们将项目放在<code>~/develop/java</code>目录中。
<code>bash create project structure
cd ~/develop/java
mkdir Tomcat
cd Tomcat
touch pom.xml
</code></p>

<h3>第二步 下载Tomcat 7.0.42二进制分发包</h3>

<p>我们通过apache-tomcat-7.0.42的<a href="http://mirrors.hust.edu.cn/apache/tomcat/tomcat-7/v7.0.42/bin/apache-tomcat-7.0.42.tar.gz">官方地址</a>下载它。具体的过程如下：
<code>bash download apache-tomcat-7.0.42 binary distribution
cd ~/develop/java/Tomcat
wget http://mirrors.hust.edu.cn/apache/tomcat/tomcat-7/v7.0.42/bin/apache-tomcat-7.0.42.tar.gz
tar -zxvf apache-tomcat-7.0.42.tar.gz
rm apache-tomcat-7.0.42.tar.gz
mv apache-tomcat-7.0.42 catalina-home
</code></p>

<h3>第三步 下载Tomcat 7.0.42 源代码</h3>

<p>接下来我们从Tomcat的<a href="http://svn.apache.org/repos/asf/tomcat/tc7.0.x/tags/TOMCAT_7_0_42/">官方SVN仓库</a>下载Tomcat 7.0.42源代码，具体的步骤如下：
<code>bash download Tomcat 7.0.42 source code
cd ~/develop/java/Tomcat
svn co http://svn.apache.org/repos/asf/tomcat/tc7.0.x/tags/TOMCAT_7_0_42/  tomcat-7.0.42-sourcecode
</code>
在这一步中，我们将7.0.42的源代码迁入到了tomcat-7.0.42-sourcecode目录中。</p>

<h3>第四步 创建聚合模块pom.xml</h3>

<p>因为我们通过maven来对项目进行构建，这就需要我们来创建一个pom.xml文件，具体过程如下：
<code>bash create aggregation child project pom.xml
cd ~/develop/java/Tomcat/tomcat-7.0.42-sourcecode
touch pom.xml
</code>
用你喜欢的编辑器打开pom.xml然后用下面的内容替换它的内容：</p>

<p>```xml pom.xml
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
&lt;project xmlns=&ldquo;<a href="http://maven.apache.org/POM/4.0.0">http://maven.apache.org/POM/4.0.0</a>&rdquo;</p>

<pre><code>     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;


&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
&lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;
&lt;artifactId&gt;Tomcat7.0&lt;/artifactId&gt;
&lt;name&gt;Tomcat7.0&lt;/name&gt;
&lt;version&gt;7.0&lt;/version&gt;

&lt;build&gt;
    &lt;finalName&gt;Tomcat7.0&lt;/finalName&gt;
    &lt;sourceDirectory&gt;java&lt;/sourceDirectory&gt;
    &lt;testSourceDirectory&gt;test&lt;/testSourceDirectory&gt;
    &lt;resources&gt;
        &lt;resource&gt;
            &lt;directory&gt;java&lt;/directory&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
    &lt;testResources&gt;
        &lt;testResource&gt;
            &lt;directory&gt;test&lt;/directory&gt;
        &lt;/testResource&gt;
    &lt;/testResources&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
            &lt;version&gt;2.3&lt;/version&gt;

            &lt;configuration&gt;
                &lt;encoding&gt;UTF-8&lt;/encoding&gt;
                &lt;source&gt;1.6&lt;/source&gt;
                &lt;target&gt;1.6&lt;/target&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.4&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;ant&lt;/groupId&gt;
        &lt;artifactId&gt;ant&lt;/artifactId&gt;
        &lt;version&gt;1.7.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;wsdl4j&lt;/groupId&gt;
        &lt;artifactId&gt;wsdl4j&lt;/artifactId&gt;
        &lt;version&gt;1.6.2&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.xml&lt;/groupId&gt;
        &lt;artifactId&gt;jaxrpc&lt;/artifactId&gt;
        &lt;version&gt;1.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.eclipse.jdt.core.compiler&lt;/groupId&gt;
        &lt;artifactId&gt;ecj&lt;/artifactId&gt;
        &lt;version&gt;4.2.2&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>

<p></project></p>

<p>```
对于pom.xml文件我们需要注意以下几点：</p>

<ol>
<li>因为下载代码不符合Maven默认的目录结构约定，因此需要修改<code>resources</code>和<code>testResources</code>为<code>java</code>和 <code>test</code>，而不是默认的<code>src/main/resource</code>和<code>src/test/resource</code>,修改<code>sourceDirectory</code>和<code>testSourceDirectory</code>为，<code>java</code>和<code>test</code>,而不是默认的<code>src/main/java</code>和<code>src/test/java</code>.</li>
<li>因为Tomcat源代码的编译需要wsdl4j，jaxrpc,ecj等jar包，因此需要增加相关的依赖。</li>
</ol>


<h3>第五步 创建项目的根pom.xml文件</h3>

<p>这一步我么在Tomcat目录中创建pom.xml文件，这里采用了Maven中聚合的概念.具体过程如下：
<code>bash create root pom.xml
cd ~/develop/java/Tomcat
touch pom.xml
</code>
用你喜欢的编辑器打开刚创建的空的pom.xml文件，修改它的内容如下：
```xml ~/develop/java/Tomcat/pom.xml
&lt;project xmlns=&ldquo;<a href="http://maven.apache.org/POM/4.0.0">http://maven.apache.org/POM/4.0.0</a>&rdquo; xmlns:xsi=&ldquo;<a href="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</a>&rdquo;</p>

<pre><code>     xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt;

&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
&lt;groupId&gt;net.imtiger&lt;/groupId&gt;
&lt;artifactId&gt;tomcat-study&lt;/artifactId&gt;
&lt;name&gt;Tomcat 7.0 Study&lt;/name&gt;
&lt;version&gt;1.0&lt;/version&gt;
&lt;packaging&gt;pom&lt;/packaging&gt;

&lt;modules&gt;
    &lt;module&gt;tomcat-7.0.42-sourcecode&lt;/module&gt;
&lt;/modules&gt;
</code></pre>

<p></project>
```</p>

<h3>第六步 用IntelliJ IDEA 打开项目根目录的pom.xml</h3>

<p>这一步需要注意，要用IDEA 打开项目根目录的pom.xml文件（也就是~/develop/java/Tomcat/pom.xml）</p>

<h3>第七步 运行Tomcat</h3>

<p>终于到激动人心的时刻了,我们知道任何Java程序都会有一个<code>public static void main(String… args)</code>的入口，Tomcat本身是用Java写的，因此它也不例外，对于Tomcat来说，入口类是<code>org.apache.catalina.startup.Bootstrap</code>,我们找到这个类，然后在IntelliJ IDEA中创建一个运行配置，其中最主要的就是VM options的配置了，在VM options里面填写如下的参数：</p>

<p><code>java VM options
-Dcatalina.home=catalina-home -Dcatalina.base=catalina-home
-Djava.endorsed.dirs=catalina-home/endorsed -Djava.io.tmpdir=catalina-home/temp
-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager
-Djava.util.logging.config.file=catalina-home/conf/logging.properties
</code>
配置好后，IntelliJ IDEA的配置界面如下：
<img class="center" src="/images/2013/10/14/vm-options.png"></p>

<p>点击运行，即可看到Tomcat已经启动了，日志已经打到了IntelliJ IDEA的控制台上了，这个时候可以启动浏览器输入<a href="http://127.0.0.1:8080">http://127.0.0.1:8080</a>看看是否启动成功。</p>

<p>接下来，咋们在Bootstrap的main方法中，增加一句<code>System.out.println("Have fun and Enjoy!");</code>,然后运行一下，看看加入的信息是否被打入到了控制台，在笔者的电脑上打印可以看到信息已经输出如下信息：
<code>java console log
Have fun and Enjoy!
//ignore other log info
2013-10-14 17:19:35 org.apache.catalina.startup.Catalina start
信息: Server startup in 908 ms
</code>
上面就是Tomcat7.0.42源代码在IntelliJ IDEA运行环境搭建的完整的过程。因为笔者日常开发采用的是IntelliJ IDEA,所以本文就只写了IntelliJ IDEA的搭建，但是本文采用了Maven来进行构建的，理论上来说其它IDE，比如Eclipse，只要支持Maven,则可以采用本文同样的方法进行，用Eclipse开发的童鞋，按照本文的步骤理论上也是可以运行起来的。</p>

<p>最后，列出几个笔者在搭建的过程中遇到的几个小问题。</p>

<ol>
<li><code>org.apache.catalina.connector.TestRequest</code>类的<code>prepareRequestBug54984</code>中有两个特殊字符<code>äö</code>,在SVN 迁出的时候变为了乱码，导致Maven在编译的时候编译不过，大家可以复制<code>äö</code>替换乱码的字符即可。</li>
<li><code>CompilationUnit</code>类中的<code>public boolean ignoreOptionalProblems()</code>方法被标记为了@Override，但是其实现的接口<code>ICompilationUnit</code>属于<code>org.eclipse.jdt.core.compiler:ecj</code>，而3.x版本的<code>ICompilationUnit</code>中没有<code>ignoreOptionalProblems</code>方法，4.x的版本中才有，因此为了编译通过，本文采用了4.2.2版本。</li>
</ol>


<p>另外本文最终搭建好的环境，我已经放在Github上了，不想搭建的童鞋可以直接clone一份使用。<a href="https://github.com/imtiger/Tomcat">Github仓库地址</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实例分析Java Class文件的结构-实践篇]]></title>
    <link href="http://imtiger.github.io/blog/2013/01/30/java-class-file-format-demo/"/>
    <updated>2013-01-30T12:16:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2013/01/30/java-class-file-format-demo</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/01/30/java-logo.jpg" width="500" height="300"><br/>
在<a href="/blog/2013/01/30/java-class-file-format/"><code>实例分析Java Class文件的结构-理论篇</code></a>一文中，我们说了Java Class文件结构的理论知识，接下来我们来通过一个具体的例子来理论结合实践的学习一下。
首先我们有一个TestClass类，代码如下：
```java TestClass.java</p>

<pre><code> package com.ejushang.TestClass;
 public class TestClass implements Super{

         private static final int staticVar = 0;

         private int instanceVar=0;

         public int instanceMethod(int param){
             return param+1;
         }

 }

 interface Super{ }
</code></pre>

<p>```</p>

<p>通过jdk1.6.0_37的javac 编译后的TestClass.java对应的TestClass.class的二进制结构如下图所示：</p>

<!-- more -->


<p><img class="center" src="/images/2013/01/30/test-class-file.png"></p>

<ol>
<li><p>魔数<br/>
从Class的文件结构我们知道，刚开始的4个字节是魔数，上图中从地址00000000h-00000003h的内容就是魔数，从上图可知Class的文件的魔数是0xCAFEBABE。</p></li>
<li><p>主次版本号 <br/>
接下来的4个字节是主次版本号，由上图可知从00000004h-00000005h对应的是0x0000,因此Class的minor_version为0x0000,从00000006h-00000007h对应的内容为0x0032,因此Class文件的major_version版本为0x0032,这正好就是jdk1.6.0不带target参数编译后的Class对应的主次版本。</p></li>
<li><p>常量池的数量 <br/>
接下来的2个字节从00000008h-00000009h表示常量池的数量，由上图可以知道其值为0x0018，十进制为24个,但是对于常量池的数量需要明确一点，常量池的数量是constant_pool_count-1，为什么减一，是因为索引0表示class中的数据项不引用任何常量池中的常量。</p></li>
<li><p>常量池
我们上面说了常量池中有不同类型的常量，下面就来看看TestClass.class的第一个常量，我们知道每个常量都有一个u1类型的tag标识来表示常量的类型，上图中0000000ah处的内容为0x0A，转换成二级制是10，由上面的关于常量类型的描述可知tag为10的常量是Constant_Methodref_info,而Constant_Methodref_info的结够如下图所示：
<img class="center" src="/images/2013/01/30/constant-methodref-info.png"> <br/>
<code>class_index</code>指向常量池中类型为CONSTANT_Class_info的常量，从TestClass的二进制文件结构中可以看出class_index的值为0x0004（地址为0000000bh-0000000ch)，也就是说指向第四个常量。 <br/>
<code>name_and_type_index</code>指向常量池中类型为CONSTANT_NameAndType_info常量。从上图可以看出name_and_type_index的值为0x0013，表示指向常量池中的第19个常量.接下来又可以通过同样的方法来找到常量池中的所有常量。不过JDK提供了一个方便的工具可以让我们查看常量池中所包含的常量。通过javap -verbose TestClass 即可得到所有常量池中的常量，截图如下：<br/>
<img class="center" src="/images/2013/01/30/test-class-javap.png"> <br/>
从上图我们可以清楚的看到，TestClass中常量池有24个常量，不要忘记了第0个常量，因为第0个常量被用来表示 Class中的数据项不引用任何常量池中的常量。从上面的分析中我们得知TestClass的第一个常量表示方法，其中class_index指向的第四个常量为java/lang/Object，name_and_type_index指向的第19个常量值为<init>:()V,从这里可以看出第一个表示方法的常量表示的是java编译器生成的实例构造器方法。通过同样的方法可以分析常量池的其它常量。OK，分析完常量池，我们接下来再分析下access_flags。</p></li>
<li>u2 access_flags
表示类或者接口方面的访问信息，比如Class表示的是类还是接口，是否为public,static，final等。具体访问标示的含义之前已经说过了，下面我们就来看看TestClass的访问标示。Class的访问标示是从0000010dh-0000010e，其值为0x0021，根据前面说的各种访问标示的标志位，我们可以知道：0x0021=0x0001|0x0020 也即ACC_PUBLIC 和 ACC_SUPER为真，其中ACC_PUBLIC大家好理解，ACC_SUPER是jdk1.2之后编译的类都会带有的标志。</li>
<li><p>u2 this_class <br/>
表示类的索引值，用来表示类的全限定名称，类的索引值如下图所示：<br/>
<img class="center" src="/images/2013/01/30/class-index.png"><br/>
从上图可以清楚到看到，类索引值为0x0003，对应常量池的第三个常量，通过javap的结果，我们知道第三个常量为CONSTANT_Class_info类型的常量，通过它可以知道类的全限定名称为：com/ejushang/TestClass/TestClass</p></li>
<li><p>u2 super_class <br/>
表示当前类的父类的索引值，索引值指向常量池中类型为CONSTANT_Class_info的常量，父类的索引值如下图所示，其值为0x0004,查看常量池的第四个常量，可知TestClass的父类的全限定名称为：java/lang/Object.
<img class="center" src="/images/2013/01/30/super-class.png"></p></li>
<li><p>interfaces_count 、 interfaces[interfaces_count]<br/>
表示接口数量以及具体的每一个接口，TestClass的接口数量以及接口如下图所示，其中0x0001表示接口数量为1，而0x0005表示接口在常量池的索引值，找到常量池的第五个常量，其类型为CONSTANT_Class_info，其值为：com/ejushang/TestClass/Super
<img class="center" src="/images/2013/01/30/interface-count.png"></p></li>
<li><p>fields_count、field_info <br/>
fields_count表示类中field_info表的数量，而field_info表示类的实例变量和类变量，这里需要注意的是field_info不包含从父类继承过来的字段，field_info的结构如下图所示：<br/>
<img class="center" src="/images/2013/01/30/field-info.png"><br/>
<code>access_flags</code>表示字段的访问标识，比如public,private,protected，static,final等，access_flags的取值如下图所示：<br/>
<img class="center" src="/images/2013/01/30/access-flags.png"><br/>
<code>name_index</code> 和 <code>descriptor_index</code>都是常量池的索引值，分别表示字段的名称和字段的描述符，字段的名称容易理解，但是字段的描述符如何理解呢？其实在JVM 规范中，对于字段的描述符规定如下图所示：<br/>
<img class="center" src="/images/2013/01/30/field-descriptor.png"><br/>
其中大家需要关注一下上图最后一行，它表示的是对一维数组的描述符，对于String[][]的描述符将是[[ Ljava/lang/String,而对于int[][]的描述符为[[I。接下来的attributes_count以及attribute_info分别表示属性表的数量以及属性表。<br/>
下面我们还是以上面的TestClass为例，来看看TestClass的字段表吧。首先我们来看一下字段的数量，TestClass的字段的数量如下图所示：<br/>
<img class="center" src="/images/2013/01/30/testclass-field-count.png"><br/>
从上图中可以看出TestClass有两个字段，查看TestClass的源代码可知，确实也只有两个字段，接下来我们看看第一个字段，我们知道第一个字段应该为private int staticVar,它在Class文件中的二进制表示如下图所示：<br/>
<img class="center" src="/images/2013/01/30/field-one.png"><br/>
其中0x001A表示访问标示，通过查看access_flags表可知，其为ACC_PRIVATE,ACC_STATIC,ACC_FINAL,接下来0x0006和0x0007分别表示常量池中第6和第7个常量，通过查看常量池可知，其值分别为：staticVar和I，其中staticVar为字段名称，而I为字段的描述符，通过上面对描述符的解释，I所描述的是int类型的变量，接下来0x0001表示staticVar这个字段表中的属性表的数量，从上图可以staticVar字段对应的属性表有1个，0x0008表示常量池中的第8个常量，查看常量池可以得知此属性为ConstantValue属性，而ConstantValue属性的格式如下图所示：<br/>
<img class="center" src="/images/2013/01/30/constantvalue-attribute.png"><br/>
其中<code>attribute_name_index</code>表述属性名的常量池索引，本例中为ConstantValue，而ConstantValue的<code>attribute_length</code>固定长度为2，而<code>constantValue_index</code>表示常量池中的引用，本例中，其中为0x0009，查看第9个常量可以知道，它表示一个类型为CONSTANT_Integer_info的常量，其值为0。<br/>
上面说完了<code>private static final int staticVar=0</code>，下面我们接着说一下TestClass的<code>private int instanceVar=0</code>,在本例中对instanceVar的二进制表示如下图所示：
<img class="center" src="/images/2013/01/30/field-two.png"><br/>
其中0x0002表示访问标示为ACC_PRIVATE,0x000A表示字段的名称，它指向常量池中的第10个常量，查看常量池可以知道字段名称为instanceVar，而0x0007表示字段的描述符，它指向常量池中的第7个常量，查看常量池可以知道第7个常量为I，表示类型为instanceVar的类型为I，最后0x0000表示属性表的数量为0.</p></li>
<li>methods_count 、method_info <br/>
methods_count表示方法的数量，而method_info表示的方法表，其中方法表的结构如下图所示：<br/>
<img class="center" src="/images/2013/01/30/method-info.png">  <br/>
从上图可以看出method_info和field_info的结构是很类似的，方法表的access_flag的所有标志位以及取值如下图所示：<br/>
<img class="center" src="/images/2013/01/30/access-flags.png">  <br/>
其中<code>name_index</code>和<code>descriptor_index</code>表示的是方法的名称和描述符，他们分别是指向常量池的索引。这里需要结解释一下方法的描述符，方法的描述符的结构为：<code>（参数列表）返回值</code>，比如<code>public int instanceMethod(int param)</code>的描述符为：<code>（I）I</code>，表示带有一个int类型参数且返回值也为int类型的方法，接下来就是属性数量以及属性表了，方法表和字段表虽然都有属性数量和属性表，但是他们里面所包含的属性是不同。接下来我们就以TestClass来看一下方法表的二进制表示。首先来看一下方法表数量，截图如下：
<img class="center" src="/images/2013/01/30/method-count.png"><br/>
从上图可以看出方法表的数量为0x0002表示有两个方法，接下来我们来分析第一个方法，我们首先来看一下TestClass的第一个方法的<code>access_flag</code>，<code>name_index</code>,<code>descriptor_index</code>，截图如下：<br/>
<img class="center" src="/images/2013/01/30/method-one-info.png"><br/>
从上图可以知道access_flags为0x0001，从上面对access_flags标志位的描述，可知方法的access_flags的取值为ACC_PUBLIC,name_index为0x000B，查看常量池中的第11个常量，知道方法的名称为<init>，0x000C表示descriptor_index表示常量池中的第12常量，其值为()V,表示<init>方法没有参数和返回值，其实这是编译器自动生成的实例构造器方法。接下来的0x0001表示<init>方法的方法表有1个属性，属性截图如下：
<img class="center" src="/images/2013/01/30/init-method-info.png"> <br/>
从上图可以看出0x000D对应的常量池中的常量为Code,表示的方法的Code属性，所以到这里大家应该明白方法的那些代码是存储在Class文件方法表中的属性表中的Code属性中。接下来我们在分析一下Code属性，Code属性的结构如下图所示：
<img class="center" src="/images/2013/01/30/code-attribute.png"><br/>
其中<code>attribute_name_index</code>指向常量池中值为Code的常量，<code>attribute_length</code>的长度表示Code属性表的长度（这里需要注意的时候长度不包括attribute_name_index和attribute_length的6个字节的长度）。<br/>
<code>max_stack</code>表示最大栈深度，虚拟机在运行时根据这个值来分配栈帧中操作数的深度.<br/>
<code>max_locals</code>代表了局部变量表的存储空间,它的单位为slot，slot是虚拟机为局部变量分配内存的最小单元，在运行时，对于不超过32位类型的数据类型，比如byte,char,int等占用1个slot，而double和Long这种64位的数据类型则需要分配2个slot，另外max_locals的值并不是所有局部变量所需要的内存数量之和，因为slot是可以重用的，当局部变量超过了它的作用域以后，局部变量所占用的slot就会被重用。 <br/>
<code>code_length</code>代表了字节码指令的数量，而code表示的时候字节码指令，从上图可以知道code的类型为u1,一个u1类型的取值为0x00-0xFF,对应的十进制为0-255，目前虚拟机规范已经定义了200多条指令。<br/>
<code>exception_table_length</code>以及<code>exception_table</code>分别代表方法对应的异常信息。<br/>
<code>attributes_count</code>和<code>attribute_info</code>分别表示了Code属性中的属性数量和属性表，从这里可以看出Class的文件结构中，属性表是很灵活的，它可以存在于Class文件，方法表，字段表以及Code属性中。
接下来我们继续以上面的例子来分析一下，从上面init方法的Code属性的截图中可以看出，属性表的长度为0x00000026,max_stack的值为0x0002,max_locals的取值为0x0001,code_length的长度为0x0000000A，那么00000149h-00000152h为字节码，接下来exception_table_length的长度为0x0000，而attribute_count的值为0x0001，00000157h-00000158h的值为0x000E,它表示常量池中属性的名称，查看常量池得知第14个常量的值为LineNumberTable，LineNumberTable用于描述java源代码的行号和字节码行号的对应关系，它不是运行时必需的属性,接下来我们再看一下LineNumberTable的结构如下图所示：</li>
</ol>


<blockquote><p>如果通过-g:none的编译器参数来取消生成LineNumberTable的话，最大的影响就是异常发生的时候，堆栈中不能显示出出错的行号，调试的时候也不能按照源代码来设置断点，</p></blockquote>

<p><img class="center" src="/images/2013/01/30/linenumbertable-attribute.png"><br/>
其中<code>attribute_name_index</code>上面已经提到过，表示常量池的索引，<code>attribute_length</code>表示属性长度，而<code>start_pc</code>和<code>line_number</code>分表表示字节码的行号和源代码的行号。本例中LineNumberTable属性的字节流如下图所示：
<img class="center" src="/images/2013/01/30/testclass-linenumbertable.png"><br/>
上面分析完了TestClass的第一个方法，通过同样的方式我们可以分析出TestClass的第二个方法，截图如下：<br/>
<img class="center" src="/images/2013/01/30/method-two.png">
其中<code>access_flags</code>为0x0001,<code>name_index</code>为0x000F,<code>descriptor_index</code>为0x0010，通过查看常量池可以知道此方法为<code>public int instanceMethod(int param)</code>方法。通过和上面类似的方法我们可以知道instanceMethod的Code属性为下图所示：<br/>
<img class="center" src="/images/2013/01/30/method-two-code-attribute.png"></p>

<p>最后我们来分析一下，Class文件的属性，从00000191h-00000199h为Class文件中的属性表，其中0x0011表示属性的名称，查看常量池可以知道属性名称为SourceFile，我们再来看看SourceFile的结构如下图所示：    <br/>
<img class="center" src="/images/2013/01/30/sourcefile-attribute.png"><br/>
其中<code>attribute_length</code>为属性的长度，<code>sourcefile_index</code>指向常量池中值为源代码文件名称的常量，在本例中SourceFile属性截图如下：
<img class="center" src="/images/2013/01/30/test-class-sourcefile.png"><br/>
其中<code>attribute_length</code>为0x00000002表示长度为2个字节，而<code>soucefile_index</code>的值为0x0012,查看常量池的第18个常量可以知道源代码文件的名称为TestClass.java</p>

<p>通过<a href="/blog/2013/01/30/java-class-file-format/"><code>实例分析Java Class文件的结构-理论篇</code></a>和<a href="/blog/2013/01/30/java-class-file-format-demo/"><code>实例分析Java Class文件的结构-实践篇</code></a>两篇文章，我们采用理论和实践结合方式来学习了Class 文件的格式。掌握它的格式以后，我们也可以试着写个Java Class类文件的反编译器了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实例分析Java Class文件的结构-理论篇]]></title>
    <link href="http://imtiger.github.io/blog/2013/01/30/java-class-file-format/"/>
    <updated>2013-01-30T10:33:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2013/01/30/java-class-file-format</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/01/30/java-logo.jpg" width="500" height="300">  <br/>
今天把之前在Evernote中的笔记重新整理了一下，发上来供对java class 文件结构的有兴趣的同学参考一下。</p>

<p>学习Java的朋友应该都知道Java从刚开始的时候就打着平台无关性的旗号，说“一次编写，到处运行”，其实说到无关性，Java平台还有另外一个无关性那就是语言无关性，要实现语言无关性，那么Java体系中的class的文件结构或者说是字节码就显得相当重要了，其实Java从刚开始的时候就有两套规范，一个是Java语言规范，另外一个是Java虚拟机规范，Java语言规范只是规定了Java语言相关的约束以及规则，而虚拟机规范则才是真正从跨平台的角度去设计的。今天我们就以一个实际的例子来看看，到底Java中一个Class文件对应的字节码应该是什么样子。 这篇文章将首先总体上阐述一下Class到底由哪些内容构成，然后再用一个实际的Java类入手去分析class的文件结构。</p>

<!-- more -->


<p></p>

<p>在继续之前，我们首先需要明确如下几点：<br/>
1. Class文件是有8位为基础的字节流构成的，这些字节流之间都严格按照规定的顺序排列，并且字节之间不存在任何空隙，对于超过8位的数据，将按照Big-Endian的顺序存储的，也就是说高位字节存储在低的地址上面，而低位字节存储到高地址上面，其实这也是class文件要跨平台的关键，因为PowerPC架构的处理采用Big-Endian的存储顺序，而x86系列的处理器则采用Little-Endian的存储顺序，因此为了Class文件在各中处理器架构下保持统一的存储顺序，虚拟机规范必须对起进行统一。    <br/>
2. Class文件结构采用类似C语言的结构体来存储数据的，主要有两类数据项，无符号数和表，无符号数用来表述数字，索引引用以及字符串等，比如u1,u2,u4,u8分别代表1个字节，2个字节，4个字节，8个字节的无符号数，而表是有多个无符号数以及其它的表组成的复合结构。可能大家看到这里对无符号数和表到底是上面也不是很清楚，不过不要紧，等下面实例的时候，我会再以实例来解释。</p>

<p>明确了上面的两点以后，我们接下来后来看看Class文件中按照严格的顺序排列的字节流都具体包含些什么数据：<br/>
<img class="center" src="/images/2013/01/30/java-class-file-format.png"></p>

<p>  <center>（上图来自The Java Virtual Machine Specification Java SE 7 Edition) </center></p>

<p>在看上图的时候，有一点我们需要注意，比如cp_info，cp_info表示常量池，上图中用constant_pool[constant_pool_count-1]的方式来表示常量池有constant_pool_count-1个常量，它这里是采用数组的表现形式，但是大家不要误以为所有的常量池的常量长度都是一样的，其实这个地方只是为了方便描述采用了数组的方式，但是这里并不像编程语言那里，一个int型的数组，每个int长度都一样.明确了这一点以后，我们再回过头来看看上图中每一项都具体代表了什么含义。</p>

<ol>
<li>u4 magic 表示魔数，并且魔数占用了4个字节，魔数到底是做什么的呢？它其实就是表示一下这个文件的类型是一个Class文件，而不是一张JPG图片，或者AVI的电影。而Class文件对应的魔数是0xCAFEBABE.</li>
<li>u2 minor_version 表示Class文件的次版本号，并且此版本号是u2类型的无符号数表示。</li>
<li>u2 major_version 表示Class文件的主版本号，并且主版本号是u2类型的无符号数表示。major_version和minor_version主要用来表示当前的虚拟机是否接受当前这种版本的Class文件。不同版本的Java编译器编译的Class文件对应的版本是不一样的。高版本的虚拟机支持低版本的编译器编译的Class文件结构。比如Java SE 6.0对应的虚拟机支持Java SE 5.0的编译器编译的Class文件结构，反之则不行。</li>
<li>u2 constant_pool_count 表示常量池的数量。这里我们需要重点来说一下常量池是什么东西，请大家不要与Jvm内存模型中的运行时常量池混淆了，Class文件中常量池主要存储了字面量以及符号引用，其中字面量主要包括字符串，final常量的值或者某个属性的初始值等等，而符号引用主要存储类和接口的全限定名称，字段的名称以及描述符，方法的名称以及描述符，这里名称可能大家都容易理解，至于描述符的概念，放到下面说字段表以及方法表的时候再说。另外大家都知道Jvm的内存模型中有堆，栈，方法区，程序计数器构成，而方法区中又存在一块区域叫运行时常量池，运行时常量池中存放的东西其实也就是编译器产生的各种字面量以及符号引用，只不过运行时常量池具有动态性，它可以在运行的时候向其中增加其它的常量进去，最具代表性的就是String的intern方法。</li>
<li>cp_info 表示常量池，这里面就存储了上面说的各种各样的字面量和符号引用。放到常量池的中数据项在<code>The Java Virtual Machine Specification Java SE 7 Edition</code> 中一共有14个常量，每一种常量都是一个表，并且每种常量都用一个公共的部分tag来表示是哪种类型的常量。下面分别简单描述一下,具体细节等到后面的实例中我们再细化。 <br/>
CONSTANT_Utf8_info      tag标志位为1,   UTF-8编码的字符串  <br/>
CONSTANT_Integer_info  tag标志位为3， 整形字面量       <br/>
CONSTANT_Float_info     tag标志位为4， 浮点型字面量    <br/>
CONSTANT_Long_info     tag标志位为5， 长整形字面量 <br/>
CONSTANT_Double_info  tag标志位为6， 双精度字面量 <br/>
CONSTANT_Class_info    tag标志位为7， 类或接口的符号引用<br/>
CONSTANT_String_info    tag标志位为8，字符串类型的字面量<br/>
CONSTANT_Fieldref_info  tag标志位为9,  字段的符号引用 <br/>
CONSTANT_Methodref_info  tag标志位为10，类中方法的符号引用<br/>
CONSTANT_InterfaceMethodref_info tag标志位为11, 接口中方法的符号引用<br/>
CONSTANT_NameAndType_info tag 标志位为12，字段和方法的名称以及类型的符号引用</li>
<li>u2 access_flags 表示类或者接口的访问信息，具体如下图所示：
<img class="center" src="/images/2013/01/30/class-access-and-property-modifiers.png"></li>
<li>u2 this_class 表示类的常量池索引，指向常量池中CONSTANT_Class_info的常量</li>
<li>u2 super_class 表示超类的索引，指向常量池中CONSTANT_Class_info的常量</li>
<li>u2 interface_counts 表示接口的数量</li>
<li>u2 interface[interface_counts]表示接口表，它里面每一项都指向常量池中CONSTANT_Class_info常量</li>
<li>u2 fields_count 表示类的实例变量和类变量的数量</li>
<li>field_info fields[fields_count]表示字段表的信息，其中字段表的结构如下图所示：<br/>
<img class="center" src="/images/2013/01/30/field-info.png"><br/>
上图中access_flags表示字段的访问标示，比如字段是public,private，protect 等，name_index表示字段名 称，指向常量池中类型是CONSTANT_UTF8_info的常量，descriptor_index表示字段的描述符，它也指向常量池中类型为CONSTANT_UTF8_info的常量，attributes_count表示字段表中的属性表的数量，而属性表是则是一种用与描述字段，方法以及类的属性的可扩展的结构，不同版本的Java虚拟机所支持的属性表的数量是不同的。</li>
<li>u2 methods_count表示方法表的数量</li>
<li>method_info 表示方法表，方法表的具体结构如下图所示：
<img class="center" src="/images/2013/01/30/method-info.png"><br/>
其中access_flags表示方法的访问标示，name_index表示名称的索引，descriptor_index表示方法的描述符，attributes_count以及attribute_info类似字段表中的属性表，只不过字段表和方法表中属性表中的属性是不同的，比如方法表中就Code属性，表示方法的代码，而字段表中就没有Code属性。其中具体Class中到底有多少种属性，等到Class文件结构中的属性表的时候再说说。</li>
<li>attribute_count表示属性表的数量，说到属性表，我们需要明确以下几点：<br/>
1.属性表存在于Class文件结构的最后，字段表，方法表以及Code属性中，也就是说属性表中也可以存在属性表。<br/>
2.属性表的长度是不固定的，不同的属性，属性表的长度是不同的。</li>
</ol>


<p>本篇文章描述了Java Class文件方面的理论知识，下面一篇文章将通过一个实际的例子来详细解释一下Class文件内部到底长什么样。具体请参考本系列的第二篇文章：<br/>
<a href="/blog/2013/01/30/java-class-file-format-demo/">实例分析Java Class文件的结构-实践篇</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何构建Java web应用的session框架]]></title>
    <link href="http://imtiger.github.io/blog/2012/05/10/how-to-build-a-session-framework-for-java-web-application/"/>
    <updated>2012-05-10T09:31:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2012/05/10/how-to-build-a-session-framework-for-java-web-application</id>
    <content type="html"><![CDATA[<p>之前写过一个Java web的session框架，并且已经用于生产环境，运行良好。今天将我之前Evernote的笔记重新整理一下发布到博客上供有兴趣的同学参考下，也欢迎各位一起讨论。</p>

<p>做web开发的朋友都知道，一个网站在发展的过程中，随着流量的不断增加，必然会遇到伸缩性的问题，虽然目前硬件的价格已经在减低，有时候可以通过垂直伸缩的方式来达到应对访问量不断增加的麻烦，但是垂直伸缩总是会遇到瓶颈，那么此时就需要水平伸缩了。当水平伸缩的时候，最重要的一点就是状态管理，而web应用的状态通产采用httpsession的管理方式，不同的web server(比如tomcat,jboss,jetty等等)都提供了对httpsession的支持，但是webserver通常采用了集群节点之间互相复制session状态的方式来进行状态管理，这样随着集群节点的增加，集群之间的复制的开销会越来越大，这从某种程度上来说也限制了应用的伸缩性。本文就简单总结一下构建一个Java web 应用的session框架的思路是什么样子。</p>

<p>本文将会从session状态的存储，session信息的管理，安全性问题，以及如何与Servlet Container结合。</p>

<blockquote><p>在开始之前，我们首先需要明确一点这里所说的session的概念是广义的，不仅仅是指httpSession。</p></blockquote>

<!-- more -->


<h1>Session状态存储</h1>

<p>咋们首先来谈谈Session状态的存储。我们先来看看平常的日常工作当中，我们是怎么存储Session状态信息的。我们举个例子来说，比如用户的浏览历史，我们可能会将其保存在http cookie中，另外比如用户是否登陆的信息，我们可能选择保存在httpsession之中。上面说了存储到httpsession中会受限于web server的实现，伸缩性有限。那么我们在构建session框架的时候，可以考虑用一个分布式的缓存服务器来存储session状态，比如可以利用memecached服务器来进行存储。</p>

<p>另外这里面也涉及到另外一个问题，状态的跟踪问题，我们如何区分不同的用户的session信息？这里其实就需要通过cookie来实现了，我们会给每个用户产生的session分配一个唯一的Id，把这个id存放在cookie中，当用户请求服务器的时候会带上sessionId,服务器从cookie中获取sessionId后可以根据Id从缓存中获取到session状态信息。</p>

<p>说到这里，可能有同学会问？为什么我们不能把信息都放到cookie中，这样服务器端都不用存储任何的状态信息，这样对于服务器来说不也是无状态了吗？其实这里面主要涉及安全性以及浏览器的实现问题，因为存储到cookie中的信息是不安全的，黑客可以进行cookie劫持，这样你保存到cookie中的信息就会被非法用户获取了。另外我们知道不同的浏览器对cookie数量以及大小是有限制的，比如IE8限制cookie的大小为4095字节，每个域名cookie的数量为50个，这样以来就可能会遇到cookie丢失的问题。</p>

<p>综上，Session状态的存储，我们需要结合客户端存储和服务器端存储，在客户端存储中，我们借用http cookie来存储sessionId,而session的具体信息我们可以存放到服务器端，而具体实现的过程中，我们可以将起放入分布式缓存服务器中。</p>

<h1>Session信息的管理</h1>

<p>接下来我们再来说说Session信息管理，一些公司可能对这块没有什么重视，session状态的管理完全依赖于开发人员自己，开发人员可以随意将信息写入到cookie或者httpsession中，这样造成的问题就是session状态混乱，最后随着开发人员的离职，新来的人只能通过查看源代码的方式来了解session中都放入了什么信息，到后来可能公司没人知道在cookie或者httpsession中到底存放了哪些信息了？这对与系统的维护以及扩展都是不利的，那么怎么解决这个问题？</p>

<p>其实这个时候我们就可以通过session信息的统一配置话管理来解决了。具体来说就是Session框架通过一个配置文件对可放入的session信息进行统一的管理，要想往cookie或者服务器session中放入任何信息都要在配置文件中配置，这样才容许写入。这样要知道session中存放了哪些信息只需要查看配置文件即可知道了。</p>

<p>不过采用配置文件管理session信息了以后，可能又会遇到一个问题，配置文件如何管理？这个不同的公司可以有不同的做法，比如配置文件可以存放在数据库中，session框架启动的时候去数据库查询到最新的配置信息，或者也可以将其放入classpath文件中，session框架通过启动的时候去classpath中获取，另外一些公司都有统一的配置管理服务器，这样可以将session配置也纳入到配置管理服务器中，这样就更加规范了。</p>

<h1>信息安全性问题</h1>

<p>上面说了session信息的存储，我们的Session框架要支持两种存储方式，一种是cookie的客户端存储，一种是存储到服务端，当存储到客户端cookie中的，信息容易被非法意图的人窃取，如果什么信息都明文保存在cookie中，那么就存在用户信息泄露的风险。那么此时就需要对放入cookie的信息进行加密处理。关于加密和解密算法本人也没有深入研究过，不过这方面已经有很多人给出了解决方案。我在写Session框架的时候，采用了<a href="http://www.schneier.com/blowfish.html">Blowfish</a>，有兴趣的同学可以去看看。</p>

<h1>如何与Servlet Container结合</h1>

<p>本文的最后，咋们来看看在Java web 开发中，自己开发的Session框架如何与Servlet 容器结合起来。
Servlet规范中有过滤器的概念，过滤器是每个请求过来的时候，可以在请求进入Servlet之前和之后可以做一些通用的事情，那么我们的Session框架可以提供一个SessionFilter纳入到Servlet容器的管理。下面通过一个简单图来形象的描述一下Session框架中主要的角色。
<img class="center" src="/images/2012/05/10/sessionFramework.jpg">
上图中绿色的部分为Session框架的核心部分，我们下面分别来描述一下。</p>

<h2>SessionFilter</h2>

<p>SessionFilter的主要职责就是对web server生成的HttpServletRequest和HttpServletReponse进行封装，将其封装为<code>CustomHttpServletRequest</code>和<code>CustomHttpServletReponse</code>.
SessionFilter的核心代码如下：
```java SessionFilter.java</p>

<pre><code>@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    //对原生的HttpServletRequest和HttpServletReponse进行封装。
    CustomSessionServletRequest customRequest = new CustomSessionServletRequest((HttpServletRequest) request);
    CustomSessionServletResponse customResponse = new CustomSessionServletResponse((HttpServletResponse) response); 
    //对于一些静态资源可以不经过session框架过滤
    if (letitgo(request, response, chain, customRequest)) return;
    //reponseBuffer开关，控制服务器刷新响应流的方式，如果打开的话，会等整个请求处理完成后一次性刷到客户端
    if (needResponseBuffered) {
        if (logger.isDebugEnabled()) {
            logger.debug("session framework responseBuffered is on");
        }
        customResponse.setWriterBuffered(true);
    }
    CustomSession customSession = createCustomSession(customRequest, customResponse);
    try {
        chain.doFilter(customRequest, customResponse);
        if (null != customSession) {
            if (logger.isDebugEnabled()) {
                logger.debug("session framework start to commit session--" + "customSession.commit");
            }
            //将后续业务写入session的信息进行存储，这里就涉及到了将信息写入cookie或者缓存
            customSession.commit();
        }
    } catch (Exception ex) {
        logger.error("session framework occur exception", ex);
        throw new RuntimeException(ex);
    } finally {
        if (logger.isDebugEnabled()) {
            logger.debug("session framework start to commit buffer--" + "customResponse.commitBuffer");
        }
        //将响应流刷到客户端
        customResponse.commitBuffer();
    }
}
</code></pre>

<p>```</p>

<h2>CustomHttpServletRequest</h2>

<p>CustomHttpServletRequest包转了原生的HttpServletRequest，它最核心的就是要覆盖getSession方法，主要的代码如下：
```java CustomHttpServletRequest.java</p>

<pre><code>@Override
public CustomSession getSession() {
    return session;
}
@Override
public CustomSession getSession(boolean create) {
    return getSession();
}
</code></pre>

<p>```
这样当应用通过getSession返回的则是经过封装以后的代码。</p>

<h2>CustomHttpServletReponse</h2>

<p>CustomHttpServletReponse封装了原生的HttpServletReponse,此类的实现的时候需要注意在Servlet3.0之前，不支持httponly的cookie，要写入Httponly的cookie需要手动通过addHeader的方法去加入，而Servlet3.0以后，可以直接通过addCookie方法实现，具体的伪代码如下：
```java
public void addCookie(CustomCookie cookie) {</p>

<pre><code>    if (cookie.isHttpOnly()) {
        addHeader(SET_COOKIE, buildHttpOnlyCookie(cookie));
    } else {
        super.addCookie(cookie);
    }
</code></pre>

<p>}
<code>
另外我们知道标准的Servlet 输出流有一个缓存区，当应用向缓存区写入数据的时候，如果缓存区已经满了就会刷流到客户端了，这样的话就有可能造成一种情况：部分流已经刷到客户端了，但是后来服务器处理抛异常了，这样用户可能看到的状态可能和服务器不一致，为了解决这个问题，我们可以重写getOutputStream和getWriter方法，这两个方法在返回一个经过我们包装的输出流，这样Session框架就可以保留应用写入的数据到最后请求处理完了以后再由SessionFilter刷新流到客户端。具体的伪代码可以参考如下：
</code>java</p>

<pre><code>@Override
public ServletOutputStream getOutputStream() throws IOException {
    if (this.isWriterBuffered) {
        if (logger.isDebugEnabled()) {
            logger.debug("Created new byte buffer");
        }
        //这里返回一个ByteArrayOutputStream，方便Session框架控制输出流
        ByteArrayOutputStream bytes = new ByteArrayOutputStream();
        stream = new BufferedServletOutputStream(bytes);
        return stream;
    } else {
        this.getSession().commit();
        return super.getOutputStream();
    }
}

@Override
public PrintWriter getWriter() throws IOException {
    if (this.isWriterBuffered) {
        if (logger.isDebugEnabled()) {
            logger.debug("response.getWriter(): Created new character buffer");
        }
        //这里返回StringWriter 方便Session框架控制输出流
        StringWriter chars = new StringWriter();
        writer = new BufferedServletWriter(chars);
        return writer;
    } else {
        this.getSession().commit();
        return super.getWriter();
    }
}
</code></pre>

<p>```
另外需要重写的一些方法比如sendError,sendRedirect也需要重写。</p>

<h2>CustomHttpSession</h2>

<p>CustomHttpSession主要负责管理Session中的状态信息，它是HttpSession的子类，它会根据Session框架的配置，将不同的信息保存到对应的SessionHolder中，对于CustomHttpSession，我们主要需要重写setAttribute和getAttribute方法。它的伪代码如下：
```java
@Override</p>

<pre><code>public void setAttribute(String name, Object value) {
    //1. 根据Session框架的配置文件，找到name的属性对应的session配置项
    final SessionConfigItem sessionConfigItem = sessionConfig.getSessionConfigItem(name);
    if (sessionConfigItem == null) {
        return;//如果配置项为空，说明此name的属性没有经过session框架配置，不能写入
    }
    //2. 根据配置类型获取具体的SessionHolder
    final SessionHolder sessionHolder = sessionHolders.get(sessionConfigItem.getHolderType());
    //2. 找到对应的SessionHolder将其存储
    sessionHolder.setAttribute(sessionConfigItem, value);

}
@Override
public Object getAttribute(String name) {
    final SessionConfigItem sessionConfigItem = sessionConfig.getSessionConfigItem(name);
    if (sessionConfigItem == null) {
        return null;
    }
    final SessionHolder sessionHolder = sessionHolders.get(sessionConfigItem.getHolderType());
    if (sessionHolder == null) {
        return null;
    }
    return sessionHolder.getAttribute(sessionConfigItem);
}
</code></pre>

<p>```</p>

<h2>SessionHolder</h2>

<p>SessionHolder抽象了Session保存的接口，具体实现可以有好多种，比如你可以选择把session信息保存到cookie中，也可以将其保存到缓存中，甚至你可以将其保存到文件系统中。我自己写的session框架，根据前面的讨论，提供了两种存储方式，CookieHolder和CacheHolder分别对应客户端存储和服务器端缓存存储。在CookieHolder中要涉及到对cookie的解析，保存以及加密等操作，而CacheHolder涉及到从分布式缓存中查询到Session的信息以及同步session信息到缓存等一系列操作，具体代码我就贴了。</p>

<p>上面就是写一个Session框架大体的思路，对此有兴趣的同学可以一起讨论一下。</p>
]]></content>
  </entry>
  
</feed>
