<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 技术 | I'm Tiger,一个有理想爱折腾的程序员!]]></title>
  <link href="http://imtiger.github.io/blog/categories/ji-zhu/atom.xml" rel="self"/>
  <link href="http://imtiger.github.io/"/>
  <updated>2013-10-19T16:45:42+08:00</updated>
  <id>http://imtiger.github.io/</id>
  <author>
    <name><![CDATA[imtiger]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Tomcat启动过程（Tomcat源代码阅读系列之三）]]></title>
    <link href="http://imtiger.github.io/blog/2013/10/17/tomcat-start-process/"/>
    <updated>2013-10-17T11:03:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2013/10/17/tomcat-start-process</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/10/14/apache_tomcat_bag.jpg">
本文是<a href="/blog/2013/10/08/tomcat-source-code-study/">Tomcat源代码阅读系列</a>的第三篇文章，在阅读此文之前，建议先读前面的两篇：<br/>
<a href="/blog/2013/10/14/run-tomcat-in-idea-or-eclipse/">在IntelliJ IDEA 和 Eclipse运行tomcat 7源代码（Tomcat源代码阅读系列之一）</a> <br/>
<a href="/blog/2013/10/16/tomcat-architecture/">Tomcat总体结构                             （Tomcat源代码阅读系列之二）</a></p>

<p>本篇我们来一起分析一下Tomcat的启动过程，启动过程涉及到了Tomcat组件的生命周期管理，本文将从<strong>Tomcat组件生命周期管理</strong>,<strong>Tomcat启动的总过程</strong>，<strong>Tomcat启动过程关键步骤分析</strong>三个方面来进行描述。</p>

<!-- more -->


<h1>Tomcat组件生命周期管理</h1>

<p>在<a href="/blog/2013/10/16/tomcat-architecture/">Tomcat总体结构                             （Tomcat源代码阅读系列之二）</a>中，我们列出了Tomcat中Server,Service,Connector,Engine,Host,Context的继承关系图，你会发现它们都实现了<code>org.apache.catalina.Lifecycle</code>接口，而<code>org.apache.catalina.util.LifecycleBase</code>采用了<code>模板方法模式</code>来对所有支持生命周期管理的组件的生命周期各个阶段进行了总体管理，每个需要生命周期管理的组件只需要继承这个基类，然后覆盖对应的钩子方法即可完成相应的生命周期阶段性的管理工作。
下面我们首先来看看<code>org.apache.catalina.Lifecycle</code>接口的定义，它的类图如下图所示：
<img class="center" src="/images/2013/10/17/LifeCycle.png">
从上图我们可以清楚的看到LifeCycle中主要有四个生命周期阶段，它们分别是init(初始化)，start(启动),stop(停止)，destory(销毁)。知道了这四个生命周期阶段以后，咋们就来看看<code>org.apache.catalina.util.LifecycleBase</code>是如何实现<code>模板方法模式</code>的。
那接下来我们就来看看<code>org.apache.catalina.util.LifecycleBase</code>类的定义，它的类图如下所示：
<img class="center" src="/images/2013/10/17/LifeCycleBase.png">
上图中用红色标注的四个方法就是<code>模板方法模式</code>中的钩子方法，子类可以通过实现钩子方法来纳入到基类已经流程化好的生命周期管理中。<br/>
上面我们对LifeCycle和LifeCycleBase有了一个总体的认识，接下来，我们通过查看<code>org.apache.catalina.util.LifecycleBase</code>的源代码来具体的分析一下。
咋们首先来看<code>org.apache.catalina.util.LifecycleBase</code>的init方法的实现。
```java org.apache.catalina.util.LifecycleBase#init
@Override
public final synchronized void init() throws LifecycleException {</p>

<pre><code>    // 1
    if (!state.equals(LifecycleState.NEW)) {
        invalidTransition(Lifecycle.BEFORE_INIT_EVENT);
    }
    setStateInternal(LifecycleState.INITIALIZING, null, false);

    try {
        // 2 
        initInternal();
    } catch (Throwable t) {
        ExceptionUtils.handleThrowable(t);
        setStateInternal(LifecycleState.FAILED, null, false);
        throw new LifecycleException(
                sm.getString("lifecycleBase.initFail",toString()), t);
    }
    // 3 
    setStateInternal(LifecycleState.INITIALIZED, null, false);
</code></pre>

<p>}
```
下面我们逐一来分析一下上述代码中标注了数字的地方：</p>

<ol>
<li>标注1的代码首先检测当前组件的状态是不是<code>NEW</code>(新建)，如果不是就调用<code>org.apache.catalina.util.LifecycleBase#invalidTransition</code>方法来将当前的状态转换过程终止，而<code>invalidTransition</code>的实现是抛出了<code>org.apache.catalina.LifecycleException</code>异常。接着调用了<code>setStateInternal</code>方法将状态设置为INITIALIZING（正在初始化）</li>
<li>标注2的代码就是init模板方法的钩子，子类可以通过实现<code>protected abstract void initInternal() throws LifecycleException;</code>方法来纳入初始化的流程。</li>
<li>标注3的代码将组件的状态改为<code>INITIALIZED</code>(已初始化)。</li>
</ol>


<p>上面我们分析了init模板方法，接下来我们再看看start方法具体做了什么事情。start的代码如下：
```java org.apache.catalina.util.LifecycleBase#start</p>

<pre><code>public final synchronized void start() throws LifecycleException {
    // 1
    if (LifecycleState.STARTING_PREP.equals(state) ||
            LifecycleState.STARTING.equals(state) ||
            LifecycleState.STARTED.equals(state)) {

        if (log.isDebugEnabled()) {
            Exception e = new LifecycleException();
            log.debug(sm.getString("lifecycleBase.alreadyStarted",
                    toString()), e);
        } else if (log.isInfoEnabled()) {
            log.info(sm.getString("lifecycleBase.alreadyStarted",
                    toString()));
        }

        return;
    }

    // 2
    if (state.equals(LifecycleState.NEW)) {
        init();
    } else if (state.equals(LifecycleState.FAILED)){
        stop();
    } else if (!state.equals(LifecycleState.INITIALIZED) &amp;&amp;
            !state.equals(LifecycleState.STOPPED)) {
        invalidTransition(Lifecycle.BEFORE_START_EVENT);
    }
    // 3
    setStateInternal(LifecycleState.STARTING_PREP, null, false);

    try {
    //4   
        startInternal();
    } catch (Throwable t) {
        ExceptionUtils.handleThrowable(t);
        setStateInternal(LifecycleState.FAILED, null, false);
        throw new LifecycleException(
                sm.getString("lifecycleBase.startFail",toString()), t);
    }

    // 5
    if (state.equals(LifecycleState.FAILED) ||
            state.equals(LifecycleState.MUST_STOP)) {
        stop();
    } else {
        // Shouldn't be necessary but acts as a check that sub-classes are
        // doing what they are supposed to.
        if (!state.equals(LifecycleState.STARTING)) {
            invalidTransition(Lifecycle.AFTER_START_EVENT);
        }

        setStateInternal(LifecycleState.STARTED, null, false);
    }
}
</code></pre>

<p>```
下面我们逐一来分析一下上述代码中标注了数字的地方：</p>

<ol>
<li>标注1的代码检测当前组件的状态是不是<code>STARTING_PREP</code>(准备启动),<code>STARTING</code>（正在启动）,<code>STARTED</code>（已启动）.如果是这三个状态中的任何一个，则抛出<code>LifecycleException</code>。</li>
<li>标注2的代码的检查其实主要是为了保证组件状态的完整性，在正常启动的流程中，应该是不会出现没有初始化就启动，或者还没启动就已经失败的情况。</li>
<li>标注3的代码设置组件的状态为<code>STARTING_PREP</code>（准备启动状态）</li>
<li>标注4的代码是start模板方法的钩子方法，子类通过实现<code>org.apache.catalina.util.LifecycleBase#startInternal</code>这个方法来纳入到组件启动的流程中来。</li>
<li>标注5的代码做了一些状态检查，然后最终将组件的状态设置为<code>STARTED</code>(已启动)</li>
</ol>


<p>上面我们分析了init和start方法的流程，对于stop和destroy方法的总体过程是类似的，大家可以自己阅读一下，但是通过上面的分析，我们可以得出生命周期方法的总体的骨架，如果用伪代码来表示可以简化为如下：
```java org.apache.catalina.util.LifecycleBase#lifeCycleMethod</p>

<pre><code>public final synchronized void lfieCycleMethod() throws LifecycleException {
    stateCheck();//状态检查
    //设置为进入相应的生命周期之前的状态
    setStateInternal(LifecycleState.BEFORE_STATE, null, false);
    lfieCycleMethodInternal();//钩子方法
    //进入相应的生命周期之后的状态
    setStateInternal(LifecycleState.AFTER_STATE, null, false);
}
</code></pre>

<p>```</p>

<h1>Tomcat启动的总过程</h1>

<p>通过上面的介绍，我们总体上清楚了各个组件的生命周期的各个阶段具体都是如何运作的。接下来我们就来看看，Tomcat具体是如何一步步启动起来的。我们都知道任何Java程序都有一个main函数入口，Tomcat中的main入口是<code>org.apache.catalina.startup.Bootstrap#main</code>,下面我们就来分析一下它的代码：
```java org.apache.catalina.startup.Bootstrap#main
public static void main(String args[]) {</p>

<pre><code>if (daemon == null) {
    // Don't set daemon until init() has completed
    // 1 
    Bootstrap bootstrap = new Bootstrap();
    try {
        // 2
        bootstrap.init();
    } catch (Throwable t) {
        handleThrowable(t);
        t.printStackTrace();
        return;
    }
    // 3
    daemon = bootstrap;
} else {
    // When running as a service the call to stop will be on a new
    // thread so make sure the correct class loader is used to prevent
    // a range of class not found exceptions.
    Thread.currentThread().setContextClassLoader(daemon.catalinaLoader);
}

try {
    String command = "start";
    if (args.length &gt; 0) {
        command = args[args.length - 1];
    }

    if (command.equals("startd")) {
        args[args.length - 1] = "start";
        daemon.load(args);
        daemon.start();
    } else if (command.equals("stopd")) {
        args[args.length - 1] = "stop";
        daemon.stop();
    } else if (command.equals("start")) {
        // 4
        daemon.setAwait(true);
        daemon.load(args);
        daemon.start();
    } else if (command.equals("stop")) {
        daemon.stopServer(args);
    } else if (command.equals("configtest")) {
        daemon.load(args);
        if (null==daemon.getServer()) {
            System.exit(1);
        }
        System.exit(0);
    } else {
        log.warn("Bootstrap: command \"" + command + "\" does not exist.");
    }
} catch (Throwable t) {
    // Unwrap the Exception for clearer error reporting
    if (t instanceof InvocationTargetException &amp;&amp;
            t.getCause() != null) {
        t = t.getCause();
    }
    handleThrowable(t);
    t.printStackTrace();
    System.exit(1);
}
</code></pre>

<p>}</p>

<p>```</p>

<p>下面我们逐一来分析一下上述代码中标注了数字的地方：</p>

<ol>
<li>标注1的代码初始化了自举类的实例，标注2的代码对BootStrap实例进行了初始化，标注3的代码将实例赋值给了daemon。</li>
<li>标注4的代码首先调用了BootStrap的load方法，然后调用了start方法。</li>
</ol>


<p>接下来我们分别分析一下BootStrap的init,load，start方法具体做了哪些工作。</p>

<h2>BootStrap#init方法</h2>

<p>首先来看<code>org.apache.catalina.startup.Bootstrap#init</code>方法，它的代码如下：
```java org.apache.catalina.startup.Bootstrap#init
public void init()throws Exception{</p>

<pre><code>// Set Catalina path
setCatalinaHome();
setCatalinaBase();

initClassLoaders();

Thread.currentThread().setContextClassLoader(catalinaLoader);

SecurityClassLoad.securityClassLoad(catalinaLoader);

// Load our startup class and call its process() method
if (log.isDebugEnabled())
    log.debug("Loading startup class");
// 1
Class&lt;?&gt; startupClass =
    catalinaLoader.loadClass
    ("org.apache.catalina.startup.Catalina");
Object startupInstance = startupClass.newInstance();

// Set the shared extensions class loader
if (log.isDebugEnabled())
    log.debug("Setting startup class properties");
String methodName = "setParentClassLoader";
Class&lt;?&gt; paramTypes[] = new Class[1];
paramTypes[0] = Class.forName("java.lang.ClassLoader");
Object paramValues[] = new Object[1];
paramValues[0] = sharedLoader;
Method method =
    startupInstance.getClass().getMethod(methodName, paramTypes);
// 2
method.invoke(startupInstance, paramValues);
// 3
catalinaDaemon = startupInstance;
</code></pre>

<p>}</p>

<p>```
下面我们重点逐一来分析一下上述代码中标注了数字的地方：</p>

<ol>
<li>标注1的代码通过反射实例化了<code>org.apache.catalina.startup.Catalina</code>类的实例;</li>
<li>标注2的代码调用了Catalina实例的setParentClassLoader方法设置了父亲ClassLoader，对于ClassLoader方面的内容，我们在本系列的后续文章再来看看。标注3的代码将Catalina实例赋值给了Bootstrap实例的catalinaDaemon.</li>
</ol>


<h2>BootStrap#load</h2>

<p>接下来我们再来看看<code>org.apache.catalina.startup.Bootstrap#load</code>方法，通过查看源代码，我们知道此方法通过反射调用了<code>org.apache.catalina.startup.Catalina#load</code>方法，那我们就来看看Catalina的load方法，Catalina#load方法代码如下：
```java org.apache.catalina.startup.Catalina#load
public void load() {</p>

<pre><code>// 1 
Digester digester = createStartDigester();

InputSource inputSource = null;
InputStream inputStream = null;
File file = null;
try {
    file = configFile();
    inputStream = new FileInputStream(file);
    inputSource = new InputSource(file.toURI().toURL().toString());
} catch (Exception e) {
    if (log.isDebugEnabled()) {
        log.debug(sm.getString("catalina.configFail", file), e);
    }
}



try {
    inputSource.setByteStream(inputStream);
    digester.push(this);
    digester.parse(inputSource);
} catch (SAXParseException spe) {
    log.warn("Catalina.start using " + getConfigFile() + ": " +
            spe.getMessage());
    return;
} catch (Exception e) {
    log.warn("Catalina.start using " + getConfigFile() + ": " , e);
    return;
} finally {
    try {
        inputStream.close();
    } catch (IOException e) {
        // Ignore
    }
}


getServer().setCatalina(this);

// Stream redirection
initStreams();

// Start the new server
try {
    // 2
    getServer().init();
} catch (LifecycleException e) {
    if (Boolean.getBoolean("org.apache.catalina.startup.EXIT_ON_INIT_FAILURE")) {
        throw new java.lang.Error(e);
    } else {
        log.error("Catalina.start", e);
    }

}
</code></pre>

<p>}
```
上面的代码，我只保留了主流程核心的代码，下面我们重点逐一来分析一下上述代码中标注了数字的地方：</p>

<ol>
<li>标注1的代码创建Digester实例解析"conf/server.xml"文件</li>
<li>标注2的代码最终调用了StandardServer的init方法。</li>
</ol>


<p>大家可以自行查看下源代码，我们会发现如下的一个调用流程：
<code>java init call stack  
org.apache.catalina.core.StandardServer#init   
-&gt;org.apache.catalina.core.StandardService#init  
--&gt;org.apache.catalina.connector.Connector#init  
--&gt;org.apache.catalina.core.StandardEngine#init  
</code></p>

<blockquote><p>因为StandardService，Connector，StandardEngine实现了LifeCycle接口，因此符合我们上文所获的生命周期的管理，最终都是通过他们自己实现的initInternal方法进行初始化</p></blockquote>

<p>读到这里的时候，我想大家应该和我一样，以为StandardEngine#init方法会调用StandardHost#init方法，但是当我们查看StandardEngine#init方法的时候，发现并没有进行StandardHost的初始化，它到底做了什么呢？让我们来具体分析一下,我们首先拿StanderEngine的继承关系图来看下：
<img class="center" src="/images/2013/10/16/StandardEngine.png">
通过上图以及前面说的LifeCyecle的模板方法模式，我们知道StandardEngine的初始化钩子方法initInternal方法最终调用了ContainerBase的initInternal方法，那我们拿ContainerBase#initInternal方法的代码看看：<br/>
```java org.apache.catalina.core.ContainerBase#initInternal
protected void initInternal() throws LifecycleException {</p>

<pre><code>BlockingQueue&lt;Runnable&gt; startStopQueue =
    new LinkedBlockingQueue&lt;Runnable&gt;();
startStopExecutor = new ThreadPoolExecutor(
        getStartStopThreadsInternal(),
        getStartStopThreadsInternal(), 10, TimeUnit.SECONDS,
        startStopQueue,
        new StartStopThreadFactory(getName() + "-startStop-"));
startStopExecutor.allowCoreThreadTimeOut(true);
super.initInternal();
</code></pre>

<p>}
<code>
我们可以看到StandardEngine的初始化仅仅是创建了一个ThreadPoolExecutor，当看到这里的时候，笔者当时也纳闷了，StandardEngine#init竟然没有调用StandardHost#init方法，那么StandardHost的init方法是什么时候被调用的呢？遇到这种不知道到底方法怎么调用的时候怎么办呢？笔者介绍个方法给大家。我们现在需要知道StandardHost#init方法何时被调用的，而我们知道init最终会调用钩子的initInternal方法，因此这个时候，我们可以在StandardHost中override initInternal方法，增加了实现方法以后，有两种方法可以用，一种就是设置个断点debug一下就可以看出线程调用栈了，另外一种就是在新增的方法中打印出调用栈。笔者这里采用第二种方法，我们增加如下的initInternal方法到StandardHost中：
</code>java org.apache.catalina.core.StandardHost#initInternal
protected void initInternal() throws LifecycleException {</p>

<pre><code>Throwable ex = new Throwable();
StackTraceElement[] stackElements = ex.getStackTrace();
if (stackElements != null) {
    for (int i = stackElements.length - 1; i &gt;= 0; i--) {
        System.out.print(stackElements[i].getClassName() + "\t");
        System.out.print(stackElements[i].getMethodName() + "\t");
        System.out.print(stackElements[i].getFileName() + "\t");
        System.out.println(stackElements[i].getLineNumber());
    }
}
super.initInternal();   
</code></pre>

<p>}
<code>
上面的代码将会打印出方法调用堆栈，对于调试非常有用，上面的方法运行以后在控制台打印出了如下的堆栈信息：
</code>java stack info
java.lang.Thread    run Thread.java 680
java.util.concurrent.ThreadPoolExecutor$Worker  run ThreadPoolExecutor.java 918
java.util.concurrent.ThreadPoolExecutor$Worker  runTask ThreadPoolExecutor.java 895
java.util.concurrent.FutureTask run FutureTask.java 138
java.util.concurrent.FutureTask$Sync    innerRun    FutureTask.java 303
org.apache.catalina.core.ContainerBase$StartChild   call    ContainerBase.java  1549
org.apache.catalina.core.ContainerBase$StartChild   call    ContainerBase.java  1559
org.apache.catalina.util.LifecycleBase  start   LifecycleBase.java  139
org.apache.catalina.util.LifecycleBase  init    LifecycleBase.java  102
org.apache.catalina.core.StandardHost   initInternal    StandardHost.java   794
```
通过控制台的信息，我们看到是StartChild#call方法调用的，而我们查看StartChild#call方法其实是在StandardEngine的startInternal方法中通过异步线程池去初始化子容器。因此到这里我们就理清楚了，StarndardHost的init方法是在调用start方法的时候被初始化。那么接下来我们就来看看，start方法的整体调用流程。</p>

<h2>BootStrap#start</h2>

<p>采用分析load方法一样的方法，经过对BootStrap#start的分析，我们最终可以得到得到如下的调用链：
<code>java org.apache.catalina.startup.Bootstrap#start call stack
org.apache.catalina.startup.Bootstrap#start
-&gt;org.apache.catalina.startup.Catalina#start 通过反射调用
--&gt;org.apache.catalina.core.StandardServer#start
---&gt;org.apache.catalina.core.StandardService#start
----&gt;org.apache.catalina.core.StandardEngine#start
----&gt;org.apache.catalina.Executor#start
----&gt;org.apache.catalina.connector.Connector#start
</code></p>

<p>综合上文的描述我们总体得到如下的调用链：
```java org.apache.catalina.startup.Bootstrap#main call stack
org.apache.catalina.startup.Bootstrap#main
&ndash;>org.apache.catalina.startup.Bootstrap#init
&ndash;>org.apache.catalina.startup.Bootstrap#load
&mdash;>org.apache.catalina.startup.Catalina#load
&mdash;&ndash;>org.apache.catalina.core.StandardServer#init
&mdash;&mdash;>org.apache.catalina.core.StandardService#init
&mdash;&mdash;&ndash;>org.apache.catalina.connector.Connector#init
&mdash;&mdash;&ndash;>org.apache.catalina.core.StandardEngine#init
&ndash;>org.apache.catalina.startup.Bootstrap#start
&mdash;>org.apache.catalina.startup.Catalina#start 通过反射调用
&mdash;&ndash;>org.apache.catalina.core.StandardServer#start
&mdash;&mdash;>org.apache.catalina.core.StandardService#start
&mdash;&mdash;&ndash;>org.apache.catalina.core.StandardEngine#start
&mdash;&mdash;&ndash;>org.apache.catalina.Executor#start
&mdash;&mdash;&ndash;>org.apache.catalina.connector.Connector#start</p>

<p>```
通过上面的分析我们已经搞清楚了Tomcat启动的总体的过程，但是有一些关键的步骤，我们还需要进行进一步的深入探究。let&rsquo;s do it.</p>

<h1>Tomcat启动过程关键步骤分析</h1>

<h2>Connector#init</h2>

<p>我们首先来看一下<strong>org.apache.catalina.connector.Connector#init</strong>,我们知道Connector的生命周期也是通过LifeCycle的模板方法模式来管理的，那么我们只需要查看一下它的initInternal方法即可知道它是如何初始化的。接下来我们就来看一下initInternal方法，代码如下：</p>

<p>```java org.apache.catalina.connector.Connector#initInternal
protected void initInternal() throws LifecycleException {</p>

<pre><code>    super.initInternal();

    // Initialize adapter
    adapter = new CoyoteAdapter(this);
    protocolHandler.setAdapter(adapter);

    // Make sure parseBodyMethodsSet has a default
    if( null == parseBodyMethodsSet ) {
        setParseBodyMethods(getParseBodyMethods());
    }

    if (protocolHandler.isAprRequired() &amp;&amp;
            !AprLifecycleListener.isAprAvailable()) {
        throw new LifecycleException(
                sm.getString("coyoteConnector.protocolHandlerNoApr",
                        getProtocolHandlerClassName()));
    }

    try {
        // 1 
        protocolHandler.init();
    } catch (Exception e) {
        throw new LifecycleException
            (sm.getString
             ("coyoteConnector.protocolHandlerInitializationFailed"), e);
    }

    // Initialize mapper listener
    mapperListener.init();
}
</code></pre>

<p>```</p>

<p>上面代码中，本文最关心的是标注了1的地方，这个地方调用了<code>org.apache.coyote.ProtocolHandler#init</code>方法，而ProtocolHandler是在Connector的构造函数中初始化，而Connector的构造函数又是Digester类解析conf/server.xml的时候调用的，明白了这点，我们在来具体看看Connector构造函数中调用的一个核心的方法setProtocol方法，下面是其代码：</p>

<p>```java org.apache.catalina.connector.Connector#setProtocol
public void setProtocol(String protocol) {</p>

<pre><code>    if (AprLifecycleListener.isAprAvailable()) {
        //这里统一使用AprEndpoint
        if ("HTTP/1.1".equals(protocol)) {
            setProtocolHandlerClassName
                ("org.apache.coyote.http11.Http11AprProtocol");   //Http11AprProtocol$Http11ConnectionHandler
        } else if ("AJP/1.3".equals(protocol)) {
            setProtocolHandlerClassName
                ("org.apache.coyote.ajp.AjpAprProtocol");     //AjpAprProtocol$AjpConnectionHandler
        } else if (protocol != null) {
            setProtocolHandlerClassName(protocol);
        } else {
            setProtocolHandlerClassName
                ("org.apache.coyote.http11.Http11AprProtocol");
        }
    } else {
        // 1 
        if ("HTTP/1.1".equals(protocol)) {
            setProtocolHandlerClassName
                ("org.apache.coyote.http11.Http11Protocol");  //Http11Protocol$Http11ConnectionHandler
        } else if ("AJP/1.3".equals(protocol)) {
            setProtocolHandlerClassName
                ("org.apache.coyote.ajp.AjpProtocol");    //AjpProtocol$AjpConnectionHandler
        } else if (protocol != null) {
            setProtocolHandlerClassName(protocol);
        }
    }
</code></pre>

<p>}</p>

<p>```</p>

<p>从setProtocol的代码中，我们可以看出主要逻辑分为了两块，一种情况是使用<a href="http://tomcat.apache.org/tomcat-7.0-doc/apr.html">APR(Apache Portable Runtime)</a>，另外一种是不使用APR的情况。缺省情况下不采用APR库，这样的话，代码会走到标注1的代码分支，这里通过协议的不同，最终初始化了不同的类。如果是http1.1协议就采用<code>org.apache.coyote.http11.Http11Protocol</code>,如果是AJP(Apache Jserv Protocol)协议，就采用<code>org.apache.coyote.ajp.AjpProtocol</code>类，下面我们来看一下Http11Protocol和AjpProtocol的继承关系图如下：
<img class="center" src="/images/2013/10/17/Http11Protocol.png"><br/>
<img class="center" src="/images/2013/10/17/AJPProtocol.png">
通过上图我们可以看到它们都继承了公共的基类<code>org.apache.coyote.AbstractProtocol</code>,而它们自己的init方法最终其实都是调用了AbstractProtocol的init方法，通过查看AbstractProtocol#init代码，我们可以看到最终是调用了<code>org.apache.tomcat.util.net.AbstractEndpoint#init</code>,而AbstractEndpoint的实例化操作是在实例化AjpProtocol和Http11Protocol的时候在其构造函数中实例化的，而AjpProtocol和Http11Protocol构造函数中，其实都是初始化了<code>org.apache.tomcat.util.net.JIoEndpoint</code>类，只不过根据是http协议还是AJP协议，它们具有不同的连接处理类。其中Http11Protocol的连接处理类为<code>org.apache.coyote.http11.Http11Protocol.Http11ConnectionHandler</code>,而连接处理类为<code>org.apache.coyote.ajp.AjpProtocol.AjpConnectionHandler</code>，因此到这里我们基本清楚了Connector的初始化流程，总结如下：
```java Connect init 采用APR的情况
//1 HTTP/1.1协议连接器
org.apache.catalina.connector.Connector#init
&ndash;>org.apache.coyote.http11.Http11AprProtocol#init
&mdash;>org.apache.tomcat.util.net.AprEndpoint#init
(org.apache.coyote.http11.Http11AprProtocol.Http11ConnectionHandler)</p>

<p>// 2 AJP/1.3协议连接器
org.apache.catalina.connector.Connector#init
&ndash;>org.apache.coyote.ajp.AjpAprProtocol#init
&mdash;>org.apache.tomcat.util.net.AprEndpoint#init
(org.apache.coyote.ajp.AjpAprProtocol.AjpConnectionHandler)</p>

<p><code>
</code>java Connector init 不采用APR的情况
// 1 HTTP/1.1协议连接器
org.apache.catalina.connector.Connector#init
&ndash;>org.apache.coyote.http11.Http11Protocol#init
&mdash;>org.apache.tomcat.util.net.JIoEndpoint#init
(org.apache.coyote.http11.Http11Protocol.Http11ConnectionHandler)</p>

<p>// 2 AJP/1.3协议连接器
org.apache.catalina.connector.Connector#init
&ndash;>org.apache.coyote.ajp.AjpProtocol#init
&mdash;>org.apache.tomcat.util.net.JIoEndpoint#init
(org.apache.coyote.ajp.AjpProtocol.AjpConnectionHandler)</p>

<p>```</p>

<blockquote><p>这里需要注意，除了JIoEndpoint外，还有NIoEndpoint，对于Tomcat7.0.24的代码，并没有采用NIOEndPoint，NIOEndpoint采用了NIO的方式进行Socket的处理。</p></blockquote>

<p>最后，咋们再来看看org.apache.tomcat.util.net.JIoEndpoint#init的初始化过程，我们首先来看一下JIoEndpoint的继承关系图如下：
<img class="center" src="/images/2013/10/17/JIoEndpoint.png">
通过上图我们知道JIoEndpoint继承了AbstractEndpoint，而通过查看源码可知，JIoEndpoint没有实现自己的init方法，它默认采用了父类的init方法，那么我们就来看看AbstractEndpoint的init，它的代码如下：
```java org.apache.tomcat.util.net.AbstractEndpoint#init
 public final void init() throws Exception {</p>

<pre><code>    if (bindOnInit) {
        bind();
        bindState = BindState.BOUND_ON_INIT;
    }
</code></pre>

<p>}
<code>
通过查看上面的代码可知，因为bindOnInit默认是true,所以init调用了bind方法，而bind方法是抽象方法，最终由JIoEndpoint来实现，代码如下：
</code>java org.apache.tomcat.util.net.JIoEndpoint#bind
@Override
public void bind() throws Exception {</p>

<pre><code>    // Initialize thread count defaults for acceptor
    if (acceptorThreadCount == 0) {
        acceptorThreadCount = 1;
    }
    // Initialize maxConnections
    if (getMaxConnections() == 0) {
        // User hasn't set a value - use the default
        setMaxConnections(getMaxThreadsExecutor(true));
    }

    if (serverSocketFactory == null) {
        if (isSSLEnabled()) {
            serverSocketFactory =
                handler.getSslImplementation().getServerSocketFactory(this);
        } else {
            serverSocketFactory = new DefaultServerSocketFactory(this);
        }
    }

    if (serverSocket == null) {
        try {
            if (getAddress() == null) {
                serverSocket = serverSocketFactory.createSocket(getPort(),
                        getBacklog());
            } else {
                serverSocket = serverSocketFactory.createSocket(getPort(),
                        getBacklog(), getAddress());
            }
        } catch (BindException orig) {
            String msg;
            if (getAddress() == null)
                msg = orig.getMessage() + " &lt;null&gt;:" + getPort();
            else
                msg = orig.getMessage() + " " +
                        getAddress().toString() + ":" + getPort();
            BindException be = new BindException(msg);
            be.initCause(orig);
            throw be;
        }
    }
</code></pre>

<p>}
<code>``
通过上面代码可以看出，最终是调用了</code>org.apache.tomcat.util.net.ServerSocketFactory#createSocket<code>方法创建一个</code>java.net.ServerSocket`，并绑定在conf/server.xml中Connector中配置的端口。</p>

<p>综上我们可以得出如下结论：</p>

<blockquote><p>Connector#init的时候，无论是AJP还是HTTP最终其实是调用了JioEndpoint的初始化，默认情况在初始化的时候就会创建java.net.ServerSocket绑到到配置的端口上。</p></blockquote>

<h2>Connector#start</h2>

<p>接着我们再来分析一下Connector#start，因为Connector符合LifeCycle模板方法生命周期管理的机制，因此它的start最终会调用startInternal,org.apache.catalina.connector.Connector#startInternal代码如下：
```java org.apache.catalina.connector.Connector#startInternal</p>

<pre><code>protected void startInternal() throws LifecycleException {

    // Validate settings before starting
    if (getPort() &lt; 0) {
        throw new LifecycleException(sm.getString(
                "coyoteConnector.invalidPort", Integer.valueOf(getPort())));
    }

    setState(LifecycleState.STARTING);

    try {
        protocolHandler.start();
    } catch (Exception e) {
        String errPrefix = "";
        if(this.service != null) {
            errPrefix += "service.getName(): \"" + this.service.getName() + "\"; ";
        }

        throw new LifecycleException
            (errPrefix + " " + sm.getString
             ("coyoteConnector.protocolHandlerStartFailed"), e);
    }

    mapperListener.start();
}
</code></pre>

<p>```
通过上面的代码，我们可以清晰的看到最终调用了protocolHandler.start()，而根据Connector#init流程的分析，这里会分是否采用APR，默认是不采用APR的，这里会根据不同的协议（AJP，HTTP）来调用对应的org.apache.coyote.ProtocolHandler#start.
其中AJP会采用org.apache.coyote.ajp.AjpProtocol，HTTP协议采用org.apache.coyote.http11.Http11Protocol,而无论是AjpProtocol还是Http11Protocol都会调用JIoEndpoint的方法，那么接下来我们就来看看JioEndpoint的start方法，它的代码如下：</p>

<p>```java org.apache.tomcat.util.net.JIoEndpoint#startInternal
public void startInternal() throws Exception {</p>

<pre><code>    if (!running) {
        running = true;
        paused = false;

        // Create worker collection
        if (getExecutor() == null) {
            createExecutor();
        }

        initializeConnectionLatch();

        startAcceptorThreads();

        // Start async timeout thread
        Thread timeoutThread = new Thread(new AsyncTimeout(),
                getName() + "-AsyncTimeout");
        timeoutThread.setPriority(threadPriority);
        timeoutThread.setDaemon(true);
        timeoutThread.start();
    }
</code></pre>

<p>}
```
从上面的代码可以看出，启动了Acceptor线程和AsyncTimeout线程，首先来看看Acceptor线程，我们再来看看startAcceptorThreads方法，代码如下：</p>

<p>```java  org.apache.tomcat.util.net.AbstractEndpoint#startAcceptorThreads
protected final void startAcceptorThreads() {</p>

<pre><code>    int count = getAcceptorThreadCount();
    acceptors = new Acceptor[count];

    for (int i = 0; i &lt; count; i++) {
        acceptors[i] = createAcceptor();
        String threadName = getName() + "-Acceptor-" + i;
        acceptors[i].setThreadName(threadName);
        Thread t = new Thread(acceptors[i], threadName);
        t.setPriority(getAcceptorThreadPriority());
        t.setDaemon(getDaemon());
        t.start();
    }
</code></pre>

<p>}
<code>``
通过上面的代码，我们可以看出其实是通过</code>org.apache.tomcat.util.net.AbstractEndpoint.Acceptor<code>这个Runable接口的实现类来启动线程，接下来我们就来看看Acceptor#run方法，通过查看run方法，它里面其实就是调用了</code>java.net.ServerSocket#accept`的方法来接受一个Socket连接。</p>

<h2>StandardEngine#start</h2>

<p>从本文上面的分析中，我们得知StandardEngine继承了ContainerBase，而StandardEngine的startInternal钩子方法也仅仅是调用了父类ContainerBase的startInternal方法，那接下来我们分析一下ContainerBase的startInternal方法，代码如下：</p>

<p>```java org.apache.catalina.core.ContainerBase#startInternal
protected synchronized void startInternal() throws LifecycleException {</p>

<pre><code>// Start our child containers, if any
Container children[] = findChildren();
List&lt;Future&lt;Void&gt;&gt; results = new ArrayList&lt;Future&lt;Void&gt;&gt;();
for (int i = 0; i &lt; children.length; i++) {
    results.add(startStopExecutor.submit(new StartChild(children[i])));
}

boolean fail = false;
for (Future&lt;Void&gt; result : results) {
    try {
        result.get();
    } catch (Exception e) {
        log.error(sm.getString("containerBase.threadedStartFailed"), e);
        fail = true;
    }

}
if (fail) {
    throw new LifecycleException(
            sm.getString("containerBase.threadedStartFailed"));
}


setState(LifecycleState.STARTING);
</code></pre>

<p>}
```</p>

<p>我们删除了对本文的分析不相关的代码，只留下一些核心的代码，我们可以看到通过startStopExecutor异步的对子容器进行了启动，然后设置状态为<code>STARTING</code>的状态。而startStopExecutor是在容器的initInternal方法中进行初始化好的，接下来我们就来看看StartChild,StardChild的代码如下：
``` java org.apache.catalina.core.ContainerBase.StartChild
private static class StartChild implements Callable<Void> {</p>

<pre><code>    private Container child;

    public StartChild(Container child) {
        this.child = child;
    }

    @Override
    public Void call() throws LifecycleException {
        child.start();
        return null;
    }
</code></pre>

<p>}
<code>
通过上面的代码，我们可以看到StartChild实现了Callable接口，实现这个接口的类可以将其放到对应的executor中执行（对于executor不熟悉的童鞋可以去看一下相关的文章，本文不做介绍），StartChild在运行的时候就会调用到子容器的start方法，而此时的父容器是StandardEngine，子容器就是StandardHost,接下来我们就来看看StandardHost的启动过程。通过前面对于init流程的分析，我们知道StandardHost不是在StandardEngine#init的时候初始化，因此在执行StandardHost#start的时候，要首先进行init方法的调用，具体的代码如下：
</code>java org.apache.catalina.util.LifecycleBase#start
public final synchronized void start() throws LifecycleException {</p>

<pre><code>if (state.equals(LifecycleState.NEW)) {
    init(); //因为此时的StandardHost还没有初始化，因此会走到这一步代码
} else if (state.equals(LifecycleState.FAILED)){
    stop();
} else if (!state.equals(LifecycleState.INITIALIZED) &amp;&amp;
        !state.equals(LifecycleState.STOPPED)) {
    invalidTransition(Lifecycle.BEFORE_START_EVENT);
}

setStateInternal(LifecycleState.STARTING_PREP, null, false);

try {
    startInternal();
} catch (Throwable t) {
    ExceptionUtils.handleThrowable(t);
    setStateInternal(LifecycleState.FAILED, null, false);
    throw new LifecycleException(
            sm.getString("lifecycleBase.startFail",toString()), t);
}  
</code></pre>

<p>   setStateInternal(LifecycleState.STARTED, null, false);</p>

<p>}
```
上面省略了部分不相关的代码，在调用中我们可以清楚的看到，对于StandardHost的初始化，是在start的时候进行的。那接下来我们在来看一下StandardHost的init方法，通过查看代码，我们发现StandardHost本身没有实现initInternal的钩子方法，也就意味着最终初始化会调用ContainerBase#initInternal方法，而通过上文的描述，我们已经清楚ContainerBase#initInternal主要是初始化了一个startStopExecutor，这个线程池主要是为了异步的初始化子容器来用的。</p>

<blockquote><p>我们知道StandardEngine初始化的时候，也是初始化了一个线程池，而StandardHost也初始化了一个线程池，他们的不同点在与创建线程的工厂方法不同，在采用缺省配置的情况下，StandardEngine的线程池中的线程是以<code>Catalina-startStop</code>的形式命名的，而StandardHost是以<code>localhost-startStop</code>的方式进行命名的。大家注意区分。</p></blockquote>

<p>StandardHost#start调用init方法初始化完StandardHost以后，会调用钩子的startInternal方法，而startInternal方法又是调用了ContainerBased#startInternal方法，而ContainerBase#startInternal方法最终又会去启动子容器的，对于StandardHost来说，子容器就是StandardContext。
因此分析到这里我们可以得出如下结论：</p>

<blockquote><p>对于StandardEngine，StandardHost的启动，父容器在init的时候创建一个启动和停止子容器的线程池，然后父容器启动的时候首先通过异步的方式将子容器的启动通过<code>org.apache.catalina.core.ContainerBase.StartChild</code>提交到父容器中对应的线程池中进行启动，而子容器启动的时候首先会初始化，然后再启动。</p></blockquote>

<p>经过上面的分析，我们已经清楚了StandardEngine启动的过程了，但是我们还有一个地方需要进一步的分析。因为上面的分析我们仅仅只是分析了容器通过conf/server.xml配置文件的配置结构进行的启动，而我们都知道<code>CATALINA-HOME/webapps/</code>中的应用也是需要启动的，那么webapps目录的应用又是如何启动的呢？我们下面来分析一下，通过<a href="/blog/2013/10/16/tomcat-architecture/">Tomcat总体结构</a>的描述，我们已经知道，webapps目录下面的应用其实是属于Context的，而Context对应Tomcat中的StandardContext类，因此我们就知道应该对谁下手了，知道了目标以后，咋们还是采用之前的那种方式，要么debug,要么打印调用栈，这里我们还是通过打印调用栈的方式进行，我们在<code>org.apache.catalina.core.StandardContext#initInternal</code>中增加打印调用栈的方法，具体代码如下：
```java org.apache.catalina.core.StandardContext#initInternal
protected void initInternal() throws LifecycleException {</p>

<pre><code>    super.initInternal();
    Throwable ex = new Throwable();
    StackTraceElement[] stackElements = ex.getStackTrace();
    if (stackElements != null) {
        for (int i = stackElements.length - 1; i &gt;= 0; i--) {
            System.out.print(stackElements[i].getClassName() + "\t");
            System.out.print(stackElements[i].getMethodName() + "\t");
            System.out.print(stackElements[i].getFileName() + "\t");
            System.out.println(stackElements[i].getLineNumber());
        }
    }
    if (processTlds) {
        this.addLifecycleListener(new TldConfig());
    }

    // Register the naming resources
    if (namingResources != null) {
        namingResources.init();
    }

    // Send j2ee.object.created notification 
    if (this.getObjectName() != null) {
        Notification notification = new Notification("j2ee.object.created",
                this.getObjectName(), sequenceNumber.getAndIncrement());
        broadcaster.sendNotification(notification);
    }
</code></pre>

<p>}
<code>
运行代码，可以看到控制台有如下的输出：
</code>java terminal info
java.util.concurrent.ThreadPoolExecutor$Worker  run ThreadPoolExecutor.java 918
java.util.concurrent.ThreadPoolExecutor$Worker  runTask ThreadPoolExecutor.java 895
java.util.concurrent.FutureTask run FutureTask.java 138
java.util.concurrent.FutureTask$Sync    innerRun    FutureTask.java 303
java.util.concurrent.Executors$RunnableAdapter  call    Executors.java  439
org.apache.catalina.startup.HostConfig$DeployDirectory  run HostConfig.java 1671
org.apache.catalina.startup.HostConfig  deployDirectory HostConfig.java 1113
org.apache.catalina.core.StandardHost   addChild    StandardHost.java   622
org.apache.catalina.core.ContainerBase  addChild    ContainerBase.java  877
org.apache.catalina.core.ContainerBase  addChildInternal    ContainerBase.java  901
org.apache.catalina.util.LifecycleBase  start   LifecycleBase.java  139
org.apache.catalina.util.LifecycleBase  init    LifecycleBase.java  102
org.apache.catalina.core.StandardContext    initInternal    StandardContext.java    6449
```</p>

<p>通过查看控制台的输出，我们可以看到有一个<code>org.apache.catalina.startup.HostConfig$DeployDirectory</code>类，于是乎找到这个类去看看呗。打开一看它是一个Runable接口的实现类，因此我们推断它也是放到某个线程池中进行异步运行的，最终通过IntellIJ IDEA提供的类调用栈分析工具（ctrl+alt+h）得到DeployDirectory构造器方法的调用栈如下图所示：
<img class="center" src="/images/2013/10/17/DeployDirectory-call-stack.png">
通过上图我们可以清楚的看到，最终的调用方是<code>org.apache.catalina.startup.HostConfig#lifecycleEvent</code>,到这里我们就知道了Context的启动是通过某个组件的生命周期事件的监听器来启动的，而HostConfig到底是谁的监听器呢？通过名称我们应该可以猜测出它是StandardHost的监听器,那么它到底监听哪个事件呢？我们查看下org.apache.catalina.startup.HostConfig#lifecycleEvent的代码如下：
```java org.apache.catalina.startup.HostConfig#lifecycleEvent
public void lifecycleEvent(LifecycleEvent event) {</p>

<pre><code>    // Identify the host we are associated with
    try {
        host = (Host) event.getLifecycle();
        if (host instanceof StandardHost) {
            setCopyXML(((StandardHost) host).isCopyXML());
            setDeployXML(((StandardHost) host).isDeployXML());
            setUnpackWARs(((StandardHost) host).isUnpackWARs());
        }
    } catch (ClassCastException e) {
        log.error(sm.getString("hostConfig.cce", event.getLifecycle()), e);
        return;
    }

    // Process the event that has occurred
    if (event.getType().equals(Lifecycle.PERIODIC_EVENT)) {
        check();
    } else if (event.getType().equals(Lifecycle.START_EVENT)) {
        start();
    } else if (event.getType().equals(Lifecycle.STOP_EVENT)) {
        stop();
    }
</code></pre>

<p>}
```</p>

<p>通过上面的代码，我们可以看出监听的事件是<code>Lifecycle.START_EVENT</code>,而通过查看<code>org.apache.catalina.LifecycleState</code>的代码<code>STARTING(true,Lifecycle.START_EVENT)</code>就可以得知，此时生命周期状态应该是STARTING,到这里我们应该已经猜到了，HostConfig是在StandardHost#start的时候通过监听器调用，为了验证我们的猜测，我们debug一下代码，我们可以在HostConfig#start方法中打个断点，运行以后得到如下内存结构：
<img class="center" src="/images/2013/10/17/HostConfig.png">
通过上图也就验证了我们刚才的猜测。</p>

<p>通过上面的分析我们清楚了webapps目录中context的启动，总结如下：</p>

<blockquote><p>webapps目录中应用的启动在StandardHost#start的时候，通过<code>Lifecycle.START_EVENT</code>这个事件的监听器HostConfig进行进一步的启动。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tomcat总体结构（Tomcat源代码阅读系列之二）]]></title>
    <link href="http://imtiger.github.io/blog/2013/10/16/tomcat-architecture/"/>
    <updated>2013-10-16T14:33:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2013/10/16/tomcat-architecture</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/10/14/apache_tomcat_bag.jpg">
本文是<a href="/blog/2013/10/08/tomcat-source-code-study/">Tomcat源代码阅读系列</a>的第二篇文章，我们在本系列的第一篇文章：<a href="/blog/2013/10/14/run-tomcat-in-idea-or-eclipse/">在IntelliJ IDEA 和 Eclipse运行tomcat 7源代码</a>一文中介绍了如何在intelliJ IDEA 和 Eclipse中运行Tomcat源代码，本文介绍一下Tomcat的总体结构。</p>

<blockquote><p>本文没有特别指明的地方，源代码都是针对tomcat7.0.42来说。</p></blockquote>

<h1>Tomcat的总体结构</h1>

<p>Tomcat即是一个Http服务器也是一个Servlet容器，它的总体结构我们可以用下图来描述：</p>

<!-- more -->


<p><img class="center" src="/images/2013/10/16/TomcatArchitecture.png">
通过上图我们可以看出Tomcat中主要涉及Server,Service,Engine,Connector,Host,Context组件，之前用过Tomcat的童鞋是不是觉得这些组件的名称有点似曾相识的赶脚，没赶脚？！您再想想。好吧，不用你想了，我来告诉你吧。其实在Tomcat二进制分发包解压后,在conf目录中有一个server.xml文件，你打开它瞄两眼看看，是不是发现server.xml文件中已经包含了上述的几个名称。我拿我本地Tomcat7.0.42分发包中的server.xml来具体分析一下，它的内容如下：
```xml conf/server.xml(Tomcat 7.0.42)
&lt;?xml version=&lsquo;1.0&rsquo; encoding=&lsquo;utf-8&rsquo;?></p>

<!--
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->


<!-- Note:  A "Server" is not itself a "Container", so you may not
     define subcomponents such as "Valves" at this level.
     Documentation at /docs/config/server.html
 -->


<p><Server port="8005" shutdown="SHUTDOWN">
  <!-- Security listener. Documentation at /docs/config/listeners.html
  <Listener className="org.apache.catalina.security.SecurityListener" />
  &mdash;>
  <!--APR library loader. Documentation at /docs/apr.html -->
  <Listener className="org.apache.catalina.core.AprLifecycleListener" SSLEngine="on" />
  <!--Initialize Jasper prior to webapps are loaded. Documentation at /docs/jasper-howto.html -->
  <Listener className="org.apache.catalina.core.JasperListener" />
  <!-- Prevent memory leaks due to use of particular java/javax APIs-->
  <Listener className="org.apache.catalina.core.JreMemoryLeakPreventionListener" />
  <Listener className="org.apache.catalina.mbeans.GlobalResourcesLifecycleListener" />
  <Listener className="org.apache.catalina.core.ThreadLocalLeakPreventionListener" /></p>

<p>  &lt;!&mdash; Global JNDI resources</p>

<pre><code>   Documentation at /docs/jndi-resources-howto.html
</code></pre>

<p>  &mdash;>
  <GlobalNamingResources></p>

<pre><code>&lt;!-- Editable user database that can also be used by
     UserDatabaseRealm to authenticate users
--&gt;
&lt;Resource name="UserDatabase" auth="Container"
          type="org.apache.catalina.UserDatabase"
          description="User database that can be updated and saved"
          factory="org.apache.catalina.users.MemoryUserDatabaseFactory"
          pathname="conf/tomcat-users.xml" /&gt;
</code></pre>

<p>  </GlobalNamingResources></p>

<p>  &lt;!&mdash; A &ldquo;Service&rdquo; is a collection of one or more &ldquo;Connectors&rdquo; that share</p>

<pre><code>   a single "Container" Note:  A "Service" is not itself a "Container",
   so you may not define subcomponents such as "Valves" at this level.
   Documentation at /docs/config/service.html
</code></pre>

<p>   &mdash;>
  <Service name="Catalina"></p>

<pre><code>&lt;!--The connectors can use a shared executor, you can define one or more named thread pools--&gt;
&lt;!--
&lt;Executor name="tomcatThreadPool" namePrefix="catalina-exec-"
    maxThreads="150" minSpareThreads="4"/&gt;
--&gt;


&lt;!-- A "Connector" represents an endpoint by which requests are received
     and responses are returned. Documentation at :
     Java HTTP Connector: /docs/config/http.html (blocking &amp; non-blocking)
     Java AJP  Connector: /docs/config/ajp.html
     APR (HTTP/AJP) Connector: /docs/apr.html
     Define a non-SSL HTTP/1.1 Connector on port 8080
--&gt;
&lt;Connector port="8080" protocol="HTTP/1.1"
           connectionTimeout="20000"
           redirectPort="8443" /&gt;
&lt;!-- A "Connector" using the shared thread pool--&gt;
&lt;!--
&lt;Connector executor="tomcatThreadPool"
           port="8080" protocol="HTTP/1.1"
           connectionTimeout="20000"
           redirectPort="8443" /&gt;
--&gt;
&lt;!-- Define a SSL HTTP/1.1 Connector on port 8443
     This connector uses the JSSE configuration, when using APR, the
     connector should be using the OpenSSL style configuration
     described in the APR documentation --&gt;
&lt;!--
&lt;Connector port="8443" protocol="HTTP/1.1" SSLEnabled="true"
           maxThreads="150" scheme="https" secure="true"
           clientAuth="false" sslProtocol="TLS" /&gt;
--&gt;

&lt;!-- Define an AJP 1.3 Connector on port 8009 --&gt;
&lt;Connector port="8009" protocol="AJP/1.3" redirectPort="8443" /&gt;


&lt;!-- An Engine represents the entry point (within Catalina) that processes
     every request.  The Engine implementation for Tomcat stand alone
     analyzes the HTTP headers included with the request, and passes them
     on to the appropriate Host (virtual host).
     Documentation at /docs/config/engine.html --&gt;

&lt;!-- You should set jvmRoute to support load-balancing via AJP ie :
&lt;Engine name="Catalina" defaultHost="localhost" jvmRoute="jvm1"&gt;
--&gt;
&lt;Engine name="Catalina" defaultHost="localhost"&gt;

  &lt;!--For clustering, please take a look at documentation at:
      /docs/cluster-howto.html  (simple how to)
      /docs/config/cluster.html (reference documentation) --&gt;
  &lt;!--
  &lt;Cluster className="org.apache.catalina.ha.tcp.SimpleTcpCluster"/&gt;
  --&gt;

  &lt;!-- Use the LockOutRealm to prevent attempts to guess user passwords
       via a brute-force attack --&gt;
  &lt;Realm className="org.apache.catalina.realm.LockOutRealm"&gt;
    &lt;!-- This Realm uses the UserDatabase configured in the global JNDI
         resources under the key "UserDatabase".  Any edits
         that are performed against this UserDatabase are immediately
         available for use by the Realm.  --&gt;
    &lt;Realm className="org.apache.catalina.realm.UserDatabaseRealm"
           resourceName="UserDatabase"/&gt;
  &lt;/Realm&gt;

  &lt;Host name="localhost"  appBase="webapps"
        unpackWARs="true" autoDeploy="true"&gt;

    &lt;!-- SingleSignOn valve, share authentication between web applications
         Documentation at: /docs/config/valve.html --&gt;
    &lt;!--
    &lt;Valve className="org.apache.catalina.authenticator.SingleSignOn" /&gt;
    --&gt;

    &lt;!-- Access log processes all example.
         Documentation at: /docs/config/valve.html
         Note: The pattern used is equivalent to using pattern="common" --&gt;
    &lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"
           prefix="localhost_access_log." suffix=".txt"
           pattern="%h %l %u %t &amp;quot;%r&amp;quot; %s %b" /&gt;

  &lt;/Host&gt;
&lt;/Engine&gt;
</code></pre>

<p>  </Service>
</Server></p>

<p>```
接下来我们就根据上图以及conf/server.xml的内容来一步步描述一下上面所说的各种组件吧。</p>

<h2>Server</h2>

<p>首先闪联登场的是咋们的Server大哥（大家能给点掌声吗？），Server是Tomcat中最顶层的组件，它可以包含多个Service组件。在Tomcat源代码中Server组件对应源码中的<code>org.apache.catalina.core.StandardServer</code>类。StandardServer的继承关系图如下图所示：
<img class="center" src="/images/2013/10/16/StandardServer.jpg"></p>

<h2>Service</h2>

<p>接下来咋们来看看Service组件，Service组件相当于Connetor和Engine组件的包装器，它将一个或者多个Connector组件和一个Engine建立关联。缺省的的配置文件中，定义一个叫<code>Catalina</code>的服务，并将Http,AJP这两个Connector关联到了一个名为<code>Catalina</code>的Engine.Service组件对应Tomcat源代码中的<code>org.apache.catalina.core.StandardService</code>,StandardService的继承关系图如下图所示：
<img class="center" src="/images/2013/10/16/StandardService.png"></p>

<h2>Connector</h2>

<p>既然Tomcat需要提供http服务，而我们知道http应用层协议最终都是需要通过TCP层的协议进行包传递的，而Connector正是Tomcat中监听TCP网络连接的组件，一个Connector会监听一个独立的端口来处理来自客户端的连接。缺省的情况下Tomcat提供了如下两个Connector。我们分别描述一下：</p>

<ol>
<li>HTTP/1.1<br/>
<code>&lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt;</code>
上面定义了一个Connector，它缺省监听端口8080,这个端口我们可以根据具体情况进行改动。<code>connectionTimeout</code>定义了连接超时时间，单位是毫秒，<code>redirectPort</code>定义了ssl的重定向接口，根据缺省的配置，Connector会将ssl请求重定向到8443端口。</li>
<li>AJP/1.3<br/>
AJP表示<code>Apache Jserv Protocol</code>,此连接器将处理Tomcat和Aapache http服务器之间的交互，这个连机器是用来处理我们将Tomcat和Apache http服务器结合使用的情况。假如在同样的一台物理Server上面部署了一台Apache http服务器和多台Tomcat服务器，通过Apache服务器来处理静态资源以及负载均衡的时候，针对不同的Tomcat实例需要AJP监听不同的端口。</li>
</ol>


<p>Connector对应源代码中的<code>org.apache.catalina.connector.Connector</code>,它的继承关系图如下所示：
<img class="center" src="/images/2013/10/16/Connector.png"></p>

<h2>Engine</h2>

<p>Tomcat中有一个容器的概念，而Engine,Host,Context都属于Contanier，我们先来说说最顶层的容器Engine.<br/>
一个Engine可以包含一个或者多个Host,也就是说我们一个Tomcat的实例可以配置多个虚拟主机。<br/>
缺省的情况下<code>&lt;Engine name="Catalina" defaultHost="localhost"&gt;</code>定义了一个名称为Cataline的Engine.Engine对应源代码中的<code>org.apache.catalina.core.StandardEngine</code>，它的继承关系图如下图所示：
<img class="center" src="/images/2013/10/16/StandardEngine.png"></p>

<h2>Host</h2>

<p>Host定义了一个虚拟主机，一个虚拟主机可以有多个Context，缺省的配置如下：<br/>
<code>&lt;Host name="localhost"  appBase="webapps" unpackWARs="true" autoDeploy="true"&gt;….&lt;/Host&gt;</code> 其中<code>appBase</code>为webapps，也就是<code>&lt;CATALINA_HOME&gt;\webapps</code>目录，<code>unpackingWARS</code>属性指定在appBase指定的目录中的war包都自动的解压，缺省配置为true,<code>autoDeploy</code>属性指定是否对加入到appBase目录的war包进行自动的部署，缺省为true.<br/>
Host对应源代码中的<code>org.apache.catalina.core.StandardHost</code>,它的继承关系图如下所示：
<img class="center" src="/images/2013/10/16/StandardHost.png"></p>

<h2>Context</h2>

<p>在Tomcat中，每一个运行的webapp其实最终都是以Context的形成存在，每个Context都有一个根路径和请求URL路径，Context对应源代码中的<code>org.apache.catalina.core.StandardContext</code>,它的继承关系图如下图所示：
<img class="center" src="/images/2013/10/16/StandardContext.png">
在Tomcat中我们通常采用如下的两种方式创建一个Context.下面分别描述一下：</p>

<ol>
<li>在<code>&lt;CATALINA-HOME&gt;\webapps</code>目录中创建一个目录，这个时候将自动创建一个context，默认context的访问url为<code>http://host:port/dirname</code>,你也可以通过在<code>ContextRoot\META-INF</code>中创建一个context.xml的文件，其中包含如下的内容来指定应用的访问路径。
<code>&lt;Context path="/yourUrlPath" /&gt;</code></li>
<li>conf\server.xml文件中增加context元素。
第二种创建context的方法，我们可以选择在server.xml文件的<code>&lt;Host&gt;</code>元素，比如我们在server.xml文件中增加如下内容：
<code>xml server.xml
     ......
     ......
     &lt;Context path="/mypath" docBase="/Users/tiger/develop/xxx" reloadable="true"&gt;
     &lt;/Context&gt;
   &lt;/Host&gt;
 &lt;/Engine&gt;
&lt;/Service&gt;
&lt;/Server&gt;
</code>
这样的话，我们就可以通过<code>http://host:port/mypath</code>访问上面配置的context了。</li>
</ol>


<h2>Valve</h2>

<p>Valve中文意思是阀门，Valve是Tomcat中责任链模式的实现，通过链接多个Valve对请求进行处理。其中Valve可以定义在任何的Container中，上面说的Engine,Host,Context都属于容器。tomcat 默认定义了一个名为<code>org.apache.catalina.valves.AccessLogValve</code>的Valve,这个Valve负责拦截每个请求，然后记录一条访问日志。</p>

<p>通过上面的分析，我们发现Server,Service,Engine,Host,Context都实现了<code>org.apache.catalina.Lifecycle</code>接口，通过这个接口管理了这些核心组件的生命周期，关于这些组件的生命周期，我们在下一篇文章描述。</p>

<p>下篇：<br/>
<a href="/blog/2013/10/17/tomcat-start-process/">Tomcat启动过程（Tomcat源代码阅读系列之三）</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在IntelliJ IDEA 和 Eclipse运行tomcat 7源代码（Tomcat源代码阅读系列之一）]]></title>
    <link href="http://imtiger.github.io/blog/2013/10/14/run-tomcat-in-idea-or-eclipse/"/>
    <updated>2013-10-14T14:39:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2013/10/14/run-tomcat-in-idea-or-eclipse</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/10/14/apache_tomcat_bag.jpg">
本文是<a href="/blog/2013/10/08/tomcat-source-code-study/">Tomcat源代码阅读系列</a>的第一篇文章，在阅读Tomcat源代码之前，我们首先需要将Tomcat的源代码在IDE里面运行起来，这样方便我们阅读的过程中调试。本文总结一下在IDEA 或者 Eclipse中运行Tomcat源代码环境的搭建过程，同时我们通过Maven来负责项目的构建。</p>

<p>在进行搭建之前，我们首先来说一下总体的思路。我们知道Tomcat运行的时候，一部分是源代码编译以后的可运行的Jar,另外一部分则是运行时的环境（也就是我们从官方下载下来的二进制分发包中的一系列的配置文件以及目录结构，说的更直白点就是CATALINA_HOME环境变量指定的目录）,本文对于第一部分采用IntelliJ IDEA 运行tomcat-7.0.42 tag的源代码，而对于第二部分运行环境，我们则直接采用tomcat-7.0.42的二进制分发包。明白了上述的思路以后，咋们就来一步步的搭建吧。</p>

<!-- more -->


<p>首先咋们来看看搭建完成以后的总体的目录结构，然后再一步步的去分解搭建过程。笔者搭建完以后，最终的运行结构如下图所示：
<img class="center" src="/images/2013/10/14/project-structure.png"></p>

<p>下面分别解释一下上图工程结构中涉及到的文件和目录：</p>

<ol>
<li>.idea和tomcat-study.iml是IntelliJ IDEA的文件，如果你用Eclipse的话不会存在这两个东东 。</li>
<li>catalina-home是从官方下载的7.0.42的二进制分发包解压后的目录</li>
<li>target是Maven编译项目以后生成的文件夹，熟悉Maven的读者应该很熟悉此目录</li>
<li>tomcat-7.0.42-sourcecode是从Tomcat<a href="http://svn.apache.org/repos/asf/tomcat/tc7.0.x/tags/TOMCAT_7_0_42/">官方仓库</a>下载的tags的源代码</li>
<li>pom.xml是Maven的配置文件,此工程中有两个pom.xml，这里运用了Maven聚合的特性。</li>
</ol>


<p>了解了最终的结构以后，咋们就来一步步的搭建它吧。</p>

<h3>第一步 创建项目目录结构</h3>

<p>本文假设我们将项目放在<code>~/develop/java</code>目录中。
<code>bash create project structure
cd ~/develop/java
mkdir Tomcat
cd Tomcat
touch pom.xml
</code></p>

<h3>第二步 下载Tomcat 7.0.42二进制分发包</h3>

<p>我们通过apache-tomcat-7.0.42的<a href="http://mirrors.hust.edu.cn/apache/tomcat/tomcat-7/v7.0.42/bin/apache-tomcat-7.0.42.tar.gz">官方地址</a>下载它。具体的过程如下：
<code>bash download apache-tomcat-7.0.42 binary distribution
cd ~/develop/java/Tomcat
wget http://mirrors.hust.edu.cn/apache/tomcat/tomcat-7/v7.0.42/bin/apache-tomcat-7.0.42.tar.gz
tar -zxvf apache-tomcat-7.0.42.tar.gz
rm apache-tomcat-7.0.42.tar.gz
mv apache-tomcat-7.0.42 catalina-home
</code></p>

<h3>第三步 下载Tomcat 7.0.42 源代码</h3>

<p>接下来我们从Tomcat的<a href="http://svn.apache.org/repos/asf/tomcat/tc7.0.x/tags/TOMCAT_7_0_42/">官方SVN仓库</a>下载Tomcat 7.0.42源代码，具体的步骤如下：
<code>bash download Tomcat 7.0.42 source code
cd ~/develop/java/Tomcat
svn co http://svn.apache.org/repos/asf/tomcat/tc7.0.x/tags/TOMCAT_7_0_42/  tomcat-7.0.42-sourcecode
</code>
在这一步中，我们将7.0.42的源代码迁入到了tomcat-7.0.42-sourcecode目录中。</p>

<h3>第四步 创建聚合模块pom.xml</h3>

<p>因为我们通过maven来对项目进行构建，这就需要我们来创建一个pom.xml文件，具体过程如下：
<code>bash create aggregation child project pom.xml
cd ~/develop/java/Tomcat/tomcat-7.0.42-sourcecode
touch pom.xml
</code>
用你喜欢的编辑器打开pom.xml然后用下面的内容替换它的内容：</p>

<p>```xml pom.xml
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
&lt;project xmlns=&ldquo;<a href="http://maven.apache.org/POM/4.0.0">http://maven.apache.org/POM/4.0.0</a>&rdquo;</p>

<pre><code>     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;


&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
&lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;
&lt;artifactId&gt;Tomcat7.0&lt;/artifactId&gt;
&lt;name&gt;Tomcat7.0&lt;/name&gt;
&lt;version&gt;7.0&lt;/version&gt;

&lt;build&gt;
    &lt;finalName&gt;Tomcat7.0&lt;/finalName&gt;
    &lt;sourceDirectory&gt;java&lt;/sourceDirectory&gt;
    &lt;testSourceDirectory&gt;test&lt;/testSourceDirectory&gt;
    &lt;resources&gt;
        &lt;resource&gt;
            &lt;directory&gt;java&lt;/directory&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
    &lt;testResources&gt;
        &lt;testResource&gt;
            &lt;directory&gt;test&lt;/directory&gt;
        &lt;/testResource&gt;
    &lt;/testResources&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
            &lt;version&gt;2.3&lt;/version&gt;

            &lt;configuration&gt;
                &lt;encoding&gt;UTF-8&lt;/encoding&gt;
                &lt;source&gt;1.6&lt;/source&gt;
                &lt;target&gt;1.6&lt;/target&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.4&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;ant&lt;/groupId&gt;
        &lt;artifactId&gt;ant&lt;/artifactId&gt;
        &lt;version&gt;1.7.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;wsdl4j&lt;/groupId&gt;
        &lt;artifactId&gt;wsdl4j&lt;/artifactId&gt;
        &lt;version&gt;1.6.2&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.xml&lt;/groupId&gt;
        &lt;artifactId&gt;jaxrpc&lt;/artifactId&gt;
        &lt;version&gt;1.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.eclipse.jdt.core.compiler&lt;/groupId&gt;
        &lt;artifactId&gt;ecj&lt;/artifactId&gt;
        &lt;version&gt;4.2.2&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>

<p></project></p>

<p>```
对于pom.xml文件我们需要注意以下几点：</p>

<ol>
<li>因为下载代码不符合Maven默认的目录结构约定，因此需要修改<code>resources</code>和<code>testResources</code>为<code>java</code>和 <code>test</code>，而不是默认的<code>src/main/resource</code>和<code>src/test/resource</code>,修改<code>sourceDirectory</code>和<code>testSourceDirectory</code>为，<code>java</code>和<code>test</code>,而不是默认的<code>src/main/java</code>和<code>src/test/java</code>.</li>
<li>因为Tomcat源代码的编译需要wsdl4j，jaxrpc,ecj等jar包，因此需要增加相关的依赖。</li>
</ol>


<h3>第五步 创建项目的根pom.xml文件</h3>

<p>这一步我么在Tomcat目录中创建pom.xml文件，这里采用了Maven中聚合的概念.具体过程如下：
<code>bash create root pom.xml
cd ~/develop/java/Tomcat
touch pom.xml
</code>
用你喜欢的编辑器打开刚创建的空的pom.xml文件，修改它的内容如下：
```xml ~/develop/java/Tomcat/pom.xml
&lt;project xmlns=&ldquo;<a href="http://maven.apache.org/POM/4.0.0">http://maven.apache.org/POM/4.0.0</a>&rdquo; xmlns:xsi=&ldquo;<a href="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</a>&rdquo;</p>

<pre><code>     xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt;

&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
&lt;groupId&gt;net.imtiger&lt;/groupId&gt;
&lt;artifactId&gt;tomcat-study&lt;/artifactId&gt;
&lt;name&gt;Tomcat 7.0 Study&lt;/name&gt;
&lt;version&gt;1.0&lt;/version&gt;
&lt;packaging&gt;pom&lt;/packaging&gt;

&lt;modules&gt;
    &lt;module&gt;tomcat-7.0.42-sourcecode&lt;/module&gt;
&lt;/modules&gt;
</code></pre>

<p></project>
```</p>

<h3>第六步 用IntelliJ IDEA 打开项目根目录的pom.xml</h3>

<p>这一步需要注意，要用IDEA 打开项目根目录的pom.xml文件（也就是~/develop/java/Tomcat/pom.xml）</p>

<h3>第七步 运行Tomcat</h3>

<p>终于到激动人心的时刻了,我们知道任何Java程序都会有一个<code>public static void main(String… args)</code>的入口，Tomcat本身是用Java写的，因此它也不例外，对于Tomcat来说，入口类是<code>org.apache.catalina.startup.Bootstrap</code>,我们找到这个类，然后在IntelliJ IDEA中创建一个运行配置，其中最主要的就是VM options的配置了，在VM options里面填写如下的参数：</p>

<p><code>java VM options
-Dcatalina.home=catalina-home -Dcatalina.base=catalina-home
-Djava.endorsed.dirs=catalina-home/endorsed -Djava.io.tmpdir=catalina-home/temp
-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager
-Djava.util.logging.config.file=catalina-home/conf/logging.properties
</code>
配置好后，IntelliJ IDEA的配置界面如下：
<img class="center" src="/images/2013/10/14/vm-options.png"></p>

<p>点击运行，即可看到Tomcat已经启动了，日志已经打到了IntelliJ IDEA的控制台上了，这个时候可以启动浏览器输入<a href="http://127.0.0.1:8080">http://127.0.0.1:8080</a>看看是否启动成功。</p>

<p>接下来，咋们在Bootstrap的main方法中，增加一句<code>System.out.println("Have fun and Enjoy!");</code>,然后运行一下，看看加入的信息是否被打入到了控制台，在笔者的电脑上打印可以看到信息已经输出如下信息：
<code>java console log
Have fun and Enjoy!
//ignore other log info
2013-10-14 17:19:35 org.apache.catalina.startup.Catalina start
信息: Server startup in 908 ms
</code>
上面就是Tomcat7.0.42源代码在IntelliJ IDEA运行环境搭建的完整的过程。因为笔者日常开发采用的是IntelliJ IDEA,所以本文就只写了IntelliJ IDEA的搭建，但是本文采用了Maven来进行构建的，理论上来说其它IDE，比如Eclipse，只要支持Maven,则可以采用本文同样的方法进行，用Eclipse开发的童鞋，按照本文的步骤理论上也是可以运行起来的。</p>

<p>最后，列出几个笔者在搭建的过程中遇到的几个小问题。</p>

<ol>
<li><code>org.apache.catalina.connector.TestRequest</code>类的<code>prepareRequestBug54984</code>中有两个特殊字符<code>äö</code>,在SVN 迁出的时候变为了乱码，导致Maven在编译的时候编译不过，大家可以复制<code>äö</code>替换乱码的字符即可。</li>
<li><code>CompilationUnit</code>类中的<code>public boolean ignoreOptionalProblems()</code>方法被标记为了@Override，但是其实现的接口<code>ICompilationUnit</code>属于<code>org.eclipse.jdt.core.compiler:ecj</code>，而3.x版本的<code>ICompilationUnit</code>中没有<code>ignoreOptionalProblems</code>方法，4.x的版本中才有，因此为了编译通过，本文采用了4.2.2版本。</li>
</ol>


<p>另外本文最终搭建好的环境，我已经放在Github上了，不想搭建的童鞋可以直接clone一份使用。<a href="https://github.com/imtiger/Tomcat">Github仓库地址</a></p>

<p>下篇：<br/>
<a href="/blog/2013/10/16/tomcat-architecture/">Tomcat总体结构（Tomcat源代码阅读系列之二）</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[电子商务网站的类目设计]]></title>
    <link href="http://imtiger.github.io/blog/2013/10/11/category-design-of-e-commerce-website/"/>
    <updated>2013-10-11T11:07:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2013/10/11/category-design-of-e-commerce-website</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/10/11/ejushang.png"></p>

<p>电子商务网站中都会涉及到类目，而类目的设计也是一个电商网站设计的核心之一。本文总结一下总体的设计思路。</p>

<p>首先我们从一个简单的例子说起，假如你要打算买一双<code>耐克40码黑色运动鞋</code>，我们来看看这里面涉及到了哪些关键的信息，其中<code>耐克</code>,<code>40码</code>,<code>黑色</code>,<code>运动鞋</code>是关键的信息，我们再来进一步的分析，耐克是鞋的品牌，40码是鞋的尺寸，黑色是鞋子的颜色，运动鞋是鞋子的分类，对于分类我想大家应该都比较好理解，但是对于品牌（耐克），尺寸（40码），颜色（黑色）我们应该怎么来理解呢？接下来我们就来分析一下如何通过这个具体的例子来抽象出一个公共的模型出来。</p>

<p>在上面的例子中，品牌，尺寸，颜色我们可以抽象出来<code>类目属性</code>的模型，而耐克，40码，黑色我们可以抽象出<code>类目属性值</code>的模型，这样以来我们就知道运动鞋这个类目，它有品牌，尺寸，以及颜色这几个类目属性，而品牌这个类目属性有耐克，阿迪达斯等属性值，尺寸类目属性有38码，39码，40码等类目属性值，而颜色类目属性有黑色，黄色等类目属性值。</p>

<!-- more -->


<p>明白了上面的类目属性和类目属性值的概念以后，咋们再来进一步的分析，我们再来举一个例子，张三买了一双<code>耐克40码黑色的运动鞋</code>，李四买了一双<code>耐克39码蓝色的运动鞋</code>,张三和李四购买的鞋子是同样一款耐克的鞋，只是尺码和颜色不同，从这里我们又可以引入另外两个概念<code>销售属性</code>,<code>关键属性</code>，上面的例子中，尺寸，颜色这些属于销售属性，而品牌就属于关键属性，可能说到这里大家又糊涂了，到底什么样子的属性才算销售属性，什么样子的属性是关键属性呢？要给出这个问题的答案，咋们还得进一步的进行分析，上面说的<code>耐克39码蓝色的运动鞋</code>,<code>耐克40码黑色的运动鞋</code>到底应该怎么抽象，这里需要引入一个线下标准的概念叫<code>SKU（StockKeepintUint）</code>,从字面上面来看sku表示最小存放的单元，怎么理解？当确定了这款运动鞋以后，张三和李四还需要进行进一步的选择，比如要选择尺寸，颜色，才可以确定到底要买哪一款，这里面通过不同的类目属性和类目属性值的组合就可以确定一个SKU，因此构成SKU的属性（比如上例中的尺寸，颜色），我们就将其称之为<code>销售属性</code>,而不影响SKU的属性（比如上例中的品牌），我们可以称之为关键属性（至于关键属性有什么用，我们下面再来讨论。）</p>

<p>接下来，我们来总结一下上面的分析结果，通过上面的分析，我们得到了如下几个模型，每个模型我都会通过简单的代码来标示出最核心的一些属性。</p>

<h3>1. 商品</h3>

<p>商品表示某个可以销售的物品，比如上面所说的耐克的运动鞋就是一个商品。
```java Product.java
public class Product {</p>

<pre><code>private int id;

/**
 * 所在的行业标准类目
 */
private int categoryId;

private String name;

//其它省略
</code></pre>

<p>}
```</p>

<h3>2. 类目</h3>

<p>类目也好理解，它是商品的一个分类。
```java ProductCategory.java
public class ProductCategory{</p>

<pre><code>private int id;

private String name;

//父亲类目
private ProductCategory parent;

//子类目
private List&lt;ProductCategory&gt; children = new LinkedList&lt;ProductCategory&gt;();

private String description = "";

//其它省略
</code></pre>

<p>}
```</p>

<h3>3. 属性</h3>

<p>属性模型可以被多个类目共用，比如品牌，尺寸，颜色，很多类目都要用到这个属性，我们抽象出来以后，类目属性仅仅是引用属性即可。
```java Property.java
public class Property {</p>

<pre><code>private int id;
//属性名称，比如品牌，尺寸，颜色等等
private String name;
</code></pre>

<p>}
```</p>

<h3>4. 属性值</h3>

<p>属性值顾名思义就是上面品牌，尺寸等属性的属性值，例如耐克，38码，黑色，蓝色等等。
```java Value.java
public class Value {</p>

<pre><code>private int id;

//属性值名称，比如耐克，38码，39码，黑色，蓝色等等 
private String valueName;
</code></pre>

<p>}
```</p>

<h3>5. 类目属性</h3>

<p>类目属性反应了某个类目公共的特征，比如对于鞋子来说就有品牌，尺寸，颜色，对于一个杯子来说可能有容量，颜色等属性。
```java CategoryProperty.java
public class CategoryProperty {</p>

<pre><code>private int id; 

//类目id 
private int categoryId;

//属性id,引用Property类的id.
private int propertyId;

//表示属性类型，分为销售属性和关键属性
private PropertyType propertyType;
</code></pre>

<p>}</p>

<p>public enum PropertyType {</p>

<pre><code>/* 销售属性 */
SELL_PROPERTY {
    @Override
    public String getDescription() {
        return "销售属性";
    }
},

/* 关键属性 */
KEY_PROPERTY {
    @Override
    public String getDescription() {
        return "关键属性";
    }
};

public abstract String getDescription();
</code></pre>

<p>}
```</p>

<h3>6. 类目属性值</h3>

<p>类目属性值就是类目属性对应的不同的值，比如尺寸这个鞋子的类目属性就具有38码，39码等，颜色有黄色，黑色等。
```java CategoryPropertyValue.java
public class CategoryPropertyValue {</p>

<pre><code>//没有业务意义，只是数据库主键
private int id;

//类目id
private int categoryId;

//属性id,引用Property类的id.
private int propertyId;

//属性值id,引用Value类的id.
private int valueId;
</code></pre>

<p>}
```</p>

<h3>7. SKU</h3>

<p>SKU是可以确定一个商品的最小的单元，只有确定了SKU，我们才能最终确定某个商品。
```java StockKeepingUnit.java
public class StockKeepingUnit {</p>

<pre><code>/**
 * SKU  ID
 */
private int id;

/**
 * 商品ID，一个商品可以有多个sku
 */
private int productId;

/**
 * 库存数量，查询sku的时候如果提供仓库则可读出库存数量
 */
private int stockQuantity;

/**
 * 价格
 */
private long price;


/**
 * SKU 属性列表
 */
private List&lt;SkuProperty&gt; skuProperties;
</code></pre>

<p>}
/<em>*
 * sku 属性
 * 比如颜色红色或者尺存38码等
 * @author Tiger
 * @version 1.0.0
 </em>/
public class SkuProperty {</p>

<pre><code>private long skuId;

private int propertyId;

private int valueId;
</code></pre>

<p>}
```</p>

<p>通过上面的描述，我们清楚了电子商务网站关于商品和类目设计中涉及的主要的模型。接下来我们来看看，这样的设计如何与电子商务网站的搜索相结合。一般电子商务网站都会类似下图所示的搜索界面：<br/>
<img class="center" src="/images/2013/10/11/e-commerce-category.png"></p>

<p>在上图中所列的其实就是我们上面所说的类目属性以及类目属性值，那么当我们点击其中一个类目属性和类目属性值的时候，怎么去通过搜索检索商品呢？根据上面的描述，我们知道一个商品有多个SKU，而每个SKU又有可能会有多个属性和属性值组合而成，这样的话，我们就可以根据属性和值的Id来对商品进行索引，查询的时候传递属性的id以及属性值的id即可搜索了。我们还是通过上图的例子来简要描述一下。假如我们要买<code>品牌为戴德适用人数为1-2人价格为500-999的汤锅</code>假设品牌的这个属性的id为100，戴德这个属性值的id为200，那么<code>品牌:戴德</code> 这一组属性和属性值就可以表示为<code>100:200</code>,适用人数这个属性的Id为101，而1-2人这个属性值的id为201，那么<code>适用人数:1-2人</code>我们就可以表示为<code>101:201</code>，价格这个属性的id为102，而500-999这个属性值的id为202，那么<code>价格:500-990</code>我们就可以表示为<code>102:202</code>,那么我们的搜索引擎就可以通过100:200,101:201,102:202这3个字符串来建立索引，查询的时候就可以根据同样的字符串来进行查询。</p>

<p>上面我们所说的类目都是指相对稳定的行业标准类目，这种类目结构线下也已经运营了好多年，基本上稳定，不会经常发生变化，标准类目也是面对行业的类目管理人员来说，但是对于电子商务网站的普通用户或者消费者来说，行业的类目可能太过于专业不能理解，这个时候就要引入一个导航类目的概念，导航类目主要目的就是站在消费者的角度来对类目进行划分，那么划分了以后，电商系统中就会存在两套类目：<code>导航类目</code>和<code>行业标准类目</code>，这样做其实也算是体现了软件设计中很重要的一个原则<code>开闭原则</code>，我们通过行业标准类目将商品进行规范话的管理，然后再用导航类目来适应消费者不断变化的需求。说到这里大家可能会想导航类目和行业标准类目又是如何进行关联的呢？接下来我们就来具体分析一下。</p>

<p>假如锅这个类目下面有个炒锅一个子类目，如果随着运营的不断深化，我们发现消费者非常关注炒锅是铁的还是不锈钢的，从行业标准类目的角度来说，铁，不锈钢是炒锅类目材质这个类目属性的两个不同的类目属性值，但是消费者认为铁炒锅是一个类，不锈钢炒锅是另外一个类，那么我们其实就可以做一个导航类目叫<code>铁质炒锅</code>，另外一个导航类目叫<code>不锈钢炒锅</code>，这样用户就可以直接通过类目导航到最终的搜索结果，而不用首先选择炒锅，然后在列表页面选择铁或者不锈钢再来检索了。这个时候不锈钢炒锅对于我们的系统来说，其实是<code>炒锅+材质:不锈钢</code>这个搜索条件的组合，假如炒锅类目id为100，材质属性id为200，不锈钢属性值id为300，那么上面的查询请求，我们就可以转化为<code>100+200:300</code>查询条件，说到这里大家可能已经猜到了我们导航类目应该如何和行业标准类目关联了，其实最简单的方式就是在导航类目中用一个属性保存它关联的后台标准类目id，用另外一个属性保存对应的属性和属性值组合就可以了，当然了你也可以指定一个数据结构来对<code>[类目]* + [属性:属性值]*</code>这中结构进行抽象，然后在导航类目中用一个属性来保存以上的数据结构即可。说到这里我们会发现<code>导航类目</code>其实就是一种对<code>行业标准类目</code>，<code>类目属性</code>和<code>类目属性值</code>的组合。</p>

<p>本文通过一个简单的例子来总结了一下电子商务网站类目设计中相关的一些问题，也欢迎有这方面经验的朋友一起讨论一下。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tomcat源代码阅读系列开篇]]></title>
    <link href="http://imtiger.github.io/blog/2013/10/08/tomcat-source-code-study/"/>
    <updated>2013-10-08T11:18:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2013/10/08/tomcat-source-code-study</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/10/14/apache_tomcat_bag.jpg">
我想学习Java开发的童鞋，或多或少的都应该接触过Tomcat，Tomcat在Java web开发中占据着非常重要的地位。</p>

<p>之前的时候也林林总总的阅读过Tomcat源代码，但是没有进行过总结。另外我觉得一个技术自己掌握了是一个层次，能将自己掌握的技术，通过文字或者语言跟其他人交流，并让其他人也能快速的理解自己表达意思有是另外一个层次了。因此我决定将自己阅读Tomcat源代码的过程记录一下，并分享到博客中，让有同样兴趣的童鞋可以参考下，也欢迎各位童鞋讨论。</p>

<p>接下来我们就来说说本系列所涉及的主要内容吧。<br/>
<a href="/blog/2013/10/14/run-tomcat-in-idea-or-eclipse/">在IntelliJ IDEA 和 Eclipse运行tomcat 7源代码（Tomcat源代码阅读系列之一）</a>  <br/>
<a href="/blog/2013/10/16/tomcat-architecture/">Tomcat总体结构（Tomcat源代码阅读系列之二）</a><br/>
<a href="/blog/2013/10/17/tomcat-start-process/">Tomcat启动过程（Tomcat源代码阅读系列之三）</a><br/>
<a href="#">Tomcat关闭过程</a>  (未完成)<br/>
<a href="#">Tomcat请求处理流程</a> (未完成)    <br/>
<a href="#">Tomcat类加载器机制</a> (未完成) <br/>
<a href="#">Tomcat Session管理机制</a>(未完成)  <br/>
<a href="#">Tomcat 涉及的设计模式总结</a> (未完成)</p>
]]></content>
  </entry>
  
</feed>
