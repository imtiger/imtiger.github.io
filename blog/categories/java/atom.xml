<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | I'm Tiger,一个有理想爱折腾的程序员!]]></title>
  <link href="http://imtiger.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://imtiger.github.io/"/>
  <updated>2013-10-19T16:42:24+08:00</updated>
  <id>http://imtiger.github.io/</id>
  <author>
    <name><![CDATA[imtiger]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Tomcat启动过程（Tomcat源代码阅读系列之三）]]></title>
    <link href="http://imtiger.github.io/blog/2013/10/17/tomcat-start-process/"/>
    <updated>2013-10-17T11:03:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2013/10/17/tomcat-start-process</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/10/14/apache_tomcat_bag.jpg">
本文是<a href="/blog/2013/10/08/tomcat-source-code-study/">Tomcat源代码阅读系列</a>的第三篇文章，在阅读此文之前，建议先读前面的两篇：
<a href="/blog/2013/10/14/run-tomcat-in-idea-or-eclipse/">在IntelliJ IDEA 和 Eclipse运行tomcat 7源代码（Tomcat源代码阅读系列之一）</a> <br/>
<a href="/blog/2013/10/16/tomcat-architecture/">Tomcat总体结构                             （Tomcat源代码阅读系列之二）</a></p>

<p>本篇我们来一起分析一下Tomcat的启动过程，启动过程涉及到了Tomcat组件的生命周期管理，本文将从<strong>Tomcat组件生命周期管理</strong>,<strong>Tomcat启动的总过程</strong>，<strong>Tomcat启动过程关键步骤分析</strong>三个方面来进行描述。</p>

<!-- more -->


<h1>Tomcat组件生命周期管理</h1>

<p>在<a href="/blog/2013/10/16/tomcat-architecture/">Tomcat总体结构                             （Tomcat源代码阅读系列之二）</a>中，我们列出了Tomcat中Server,Service,Connector,Engine,Host,Context的继承关系图，你会发现它们都实现了<code>org.apache.catalina.Lifecycle</code>接口，而<code>org.apache.catalina.util.LifecycleBase</code>采用了<code>模板方法模式</code>来对所有支持生命周期管理的组件的生命周期各个阶段进行了总体管理，每个需要生命周期管理的组件只需要继承这个基类，然后覆盖对应的钩子方法即可完成相应的生命周期阶段性的管理工作。
下面我们首先来看看<code>org.apache.catalina.Lifecycle</code>接口的定义，它的类图如下图所示：
<img class="center" src="/images/2013/10/17/LifeCycle.png">
从上图我们可以清楚的看到LifeCycle中主要有四个生命周期阶段，它们分别是init(初始化)，start(启动),stop(停止)，destory(销毁)。知道了这四个生命周期阶段以后，咋们就来看看<code>org.apache.catalina.util.LifecycleBase</code>是如何实现<code>模板方法模式</code>的。
那接下来我们就来看看<code>org.apache.catalina.util.LifecycleBase</code>类的定义，它的类图如下所示：
<img class="center" src="/images/2013/10/17/LifeCycleBase.png">
上图中用红色标注的四个方法就是<code>模板方法模式</code>中的钩子方法，子类可以通过实现钩子方法来纳入到基类已经流程化好的生命周期管理中。<br/>
上面我们对LifeCycle和LifeCycleBase有了一个总体的认识，接下来，我们通过查看<code>org.apache.catalina.util.LifecycleBase</code>的源代码来具体的分析一下。
咋们首先来看<code>org.apache.catalina.util.LifecycleBase</code>的init方法的实现。
```java org.apache.catalina.util.LifecycleBase#init
@Override
public final synchronized void init() throws LifecycleException {</p>

<pre><code>    // 1
    if (!state.equals(LifecycleState.NEW)) {
        invalidTransition(Lifecycle.BEFORE_INIT_EVENT);
    }
    setStateInternal(LifecycleState.INITIALIZING, null, false);

    try {
        // 2 
        initInternal();
    } catch (Throwable t) {
        ExceptionUtils.handleThrowable(t);
        setStateInternal(LifecycleState.FAILED, null, false);
        throw new LifecycleException(
                sm.getString("lifecycleBase.initFail",toString()), t);
    }
    // 3 
    setStateInternal(LifecycleState.INITIALIZED, null, false);
</code></pre>

<p>}
```
下面我们逐一来分析一下上述代码中标注了数字的地方：</p>

<ol>
<li>标注1的代码首先检测当前组件的状态是不是<code>NEW</code>(新建)，如果不是就调用<code>org.apache.catalina.util.LifecycleBase#invalidTransition</code>方法来将当前的状态转换过程终止，而<code>invalidTransition</code>的实现是抛出了<code>org.apache.catalina.LifecycleException</code>异常。接着调用了<code>setStateInternal</code>方法将状态设置为INITIALIZING（正在初始化）</li>
<li>标注2的代码就是init模板方法的钩子，子类可以通过实现<code>protected abstract void initInternal() throws LifecycleException;</code>方法来纳入初始化的流程。</li>
<li>标注3的代码将组件的状态改为<code>INITIALIZED</code>(已初始化)。</li>
</ol>


<p>上面我们分析了init模板方法，接下来我们再看看start方法具体做了什么事情。start的代码如下：
```java org.apache.catalina.util.LifecycleBase#start</p>

<pre><code>public final synchronized void start() throws LifecycleException {
    // 1
    if (LifecycleState.STARTING_PREP.equals(state) ||
            LifecycleState.STARTING.equals(state) ||
            LifecycleState.STARTED.equals(state)) {

        if (log.isDebugEnabled()) {
            Exception e = new LifecycleException();
            log.debug(sm.getString("lifecycleBase.alreadyStarted",
                    toString()), e);
        } else if (log.isInfoEnabled()) {
            log.info(sm.getString("lifecycleBase.alreadyStarted",
                    toString()));
        }

        return;
    }

    // 2
    if (state.equals(LifecycleState.NEW)) {
        init();
    } else if (state.equals(LifecycleState.FAILED)){
        stop();
    } else if (!state.equals(LifecycleState.INITIALIZED) &amp;&amp;
            !state.equals(LifecycleState.STOPPED)) {
        invalidTransition(Lifecycle.BEFORE_START_EVENT);
    }
    // 3
    setStateInternal(LifecycleState.STARTING_PREP, null, false);

    try {
    //4   
        startInternal();
    } catch (Throwable t) {
        ExceptionUtils.handleThrowable(t);
        setStateInternal(LifecycleState.FAILED, null, false);
        throw new LifecycleException(
                sm.getString("lifecycleBase.startFail",toString()), t);
    }

    // 5
    if (state.equals(LifecycleState.FAILED) ||
            state.equals(LifecycleState.MUST_STOP)) {
        stop();
    } else {
        // Shouldn't be necessary but acts as a check that sub-classes are
        // doing what they are supposed to.
        if (!state.equals(LifecycleState.STARTING)) {
            invalidTransition(Lifecycle.AFTER_START_EVENT);
        }

        setStateInternal(LifecycleState.STARTED, null, false);
    }
}
</code></pre>

<p>```
下面我们逐一来分析一下上述代码中标注了数字的地方：</p>

<ol>
<li>标注1的代码检测当前组件的状态是不是<code>STARTING_PREP</code>(准备启动),<code>STARTING</code>（正在启动）,<code>STARTED</code>（已启动）.如果是这三个状态中的任何一个，则抛出<code>LifecycleException</code>。</li>
<li>标注2的代码的检查其实主要是为了保证组件状态的完整性，在正常启动的流程中，应该是不会出现没有初始化就启动，或者还没启动就已经失败的情况。</li>
<li>标注3的代码设置组件的状态为<code>STARTING_PREP</code>（准备启动状态）</li>
<li>标注4的代码是start模板方法的钩子方法，子类通过实现<code>org.apache.catalina.util.LifecycleBase#startInternal</code>这个方法来纳入到组件启动的流程中来。</li>
<li>标注5的代码做了一些状态检查，然后最终将组件的状态设置为<code>STARTED</code>(已启动)</li>
</ol>


<p>上面我们分析了init和start方法的流程，对于stop和destroy方法的总体过程是类似的，大家可以自己阅读一下，但是通过上面的分析，我们可以得出生命周期方法的总体的骨架，如果用伪代码来表示可以简化为如下：
```java org.apache.catalina.util.LifecycleBase#lifeCycleMethod</p>

<pre><code>public final synchronized void lfieCycleMethod() throws LifecycleException {
    stateCheck();//状态检查
    //设置为进入相应的生命周期之前的状态
    setStateInternal(LifecycleState.BEFORE_STATE, null, false);
    lfieCycleMethodInternal();//钩子方法
    //进入相应的生命周期之后的状态
    setStateInternal(LifecycleState.AFTER_STATE, null, false);
}
</code></pre>

<p>```</p>

<h1>Tomcat启动的总过程</h1>

<p>通过上面的介绍，我们总体上清楚了各个组件的生命周期的各个阶段具体都是如何运作的。接下来我们就来看看，Tomcat具体是如何一步步启动起来的。我们都知道任何Java程序都有一个main函数入口，Tomcat中的main入口是<code>org.apache.catalina.startup.Bootstrap#main</code>,下面我们就来分析一下它的代码：
```java org.apache.catalina.startup.Bootstrap#main
public static void main(String args[]) {</p>

<pre><code>if (daemon == null) {
    // Don't set daemon until init() has completed
    // 1 
    Bootstrap bootstrap = new Bootstrap();
    try {
        // 2
        bootstrap.init();
    } catch (Throwable t) {
        handleThrowable(t);
        t.printStackTrace();
        return;
    }
    // 3
    daemon = bootstrap;
} else {
    // When running as a service the call to stop will be on a new
    // thread so make sure the correct class loader is used to prevent
    // a range of class not found exceptions.
    Thread.currentThread().setContextClassLoader(daemon.catalinaLoader);
}

try {
    String command = "start";
    if (args.length &gt; 0) {
        command = args[args.length - 1];
    }

    if (command.equals("startd")) {
        args[args.length - 1] = "start";
        daemon.load(args);
        daemon.start();
    } else if (command.equals("stopd")) {
        args[args.length - 1] = "stop";
        daemon.stop();
    } else if (command.equals("start")) {
        // 4
        daemon.setAwait(true);
        daemon.load(args);
        daemon.start();
    } else if (command.equals("stop")) {
        daemon.stopServer(args);
    } else if (command.equals("configtest")) {
        daemon.load(args);
        if (null==daemon.getServer()) {
            System.exit(1);
        }
        System.exit(0);
    } else {
        log.warn("Bootstrap: command \"" + command + "\" does not exist.");
    }
} catch (Throwable t) {
    // Unwrap the Exception for clearer error reporting
    if (t instanceof InvocationTargetException &amp;&amp;
            t.getCause() != null) {
        t = t.getCause();
    }
    handleThrowable(t);
    t.printStackTrace();
    System.exit(1);
}
</code></pre>

<p>}</p>

<p>```</p>

<p>下面我们逐一来分析一下上述代码中标注了数字的地方：</p>

<ol>
<li>标注1的代码初始化了自举类的实例，标注2的代码对BootStrap实例进行了初始化，标注3的代码将实例赋值给了daemon。</li>
<li>标注4的代码首先调用了BootStrap的load方法，然后调用了start方法。</li>
</ol>


<p>接下来我们分别分析一下BootStrap的init,load，start方法具体做了哪些工作。</p>

<h2>BootStrap#init方法</h2>

<p>首先来看<code>org.apache.catalina.startup.Bootstrap#init</code>方法，它的代码如下：
```java org.apache.catalina.startup.Bootstrap#init
public void init()throws Exception{</p>

<pre><code>// Set Catalina path
setCatalinaHome();
setCatalinaBase();

initClassLoaders();

Thread.currentThread().setContextClassLoader(catalinaLoader);

SecurityClassLoad.securityClassLoad(catalinaLoader);

// Load our startup class and call its process() method
if (log.isDebugEnabled())
    log.debug("Loading startup class");
// 1
Class&lt;?&gt; startupClass =
    catalinaLoader.loadClass
    ("org.apache.catalina.startup.Catalina");
Object startupInstance = startupClass.newInstance();

// Set the shared extensions class loader
if (log.isDebugEnabled())
    log.debug("Setting startup class properties");
String methodName = "setParentClassLoader";
Class&lt;?&gt; paramTypes[] = new Class[1];
paramTypes[0] = Class.forName("java.lang.ClassLoader");
Object paramValues[] = new Object[1];
paramValues[0] = sharedLoader;
Method method =
    startupInstance.getClass().getMethod(methodName, paramTypes);
// 2
method.invoke(startupInstance, paramValues);
// 3
catalinaDaemon = startupInstance;
</code></pre>

<p>}</p>

<p>```
下面我们重点逐一来分析一下上述代码中标注了数字的地方：</p>

<ol>
<li>标注1的代码通过反射实例化了<code>org.apache.catalina.startup.Catalina</code>类的实例;</li>
<li>标注2的代码调用了Catalina实例的setParentClassLoader方法设置了父亲ClassLoader，对于ClassLoader方面的内容，我们在本系列的后续文章再来看看。标注3的代码将Catalina实例赋值给了Bootstrap实例的catalinaDaemon.</li>
</ol>


<h2>BootStrap#load</h2>

<p>接下来我们再来看看<code>org.apache.catalina.startup.Bootstrap#load</code>方法，通过查看源代码，我们知道此方法通过反射调用了<code>org.apache.catalina.startup.Catalina#load</code>方法，那我们就来看看Catalina的load方法，Catalina#load方法代码如下：
```java org.apache.catalina.startup.Catalina#load
public void load() {</p>

<pre><code>// 1 
Digester digester = createStartDigester();

InputSource inputSource = null;
InputStream inputStream = null;
File file = null;
try {
    file = configFile();
    inputStream = new FileInputStream(file);
    inputSource = new InputSource(file.toURI().toURL().toString());
} catch (Exception e) {
    if (log.isDebugEnabled()) {
        log.debug(sm.getString("catalina.configFail", file), e);
    }
}



try {
    inputSource.setByteStream(inputStream);
    digester.push(this);
    digester.parse(inputSource);
} catch (SAXParseException spe) {
    log.warn("Catalina.start using " + getConfigFile() + ": " +
            spe.getMessage());
    return;
} catch (Exception e) {
    log.warn("Catalina.start using " + getConfigFile() + ": " , e);
    return;
} finally {
    try {
        inputStream.close();
    } catch (IOException e) {
        // Ignore
    }
}


getServer().setCatalina(this);

// Stream redirection
initStreams();

// Start the new server
try {
    // 2
    getServer().init();
} catch (LifecycleException e) {
    if (Boolean.getBoolean("org.apache.catalina.startup.EXIT_ON_INIT_FAILURE")) {
        throw new java.lang.Error(e);
    } else {
        log.error("Catalina.start", e);
    }

}
</code></pre>

<p>}
```
上面的代码，我只保留了主流程核心的代码，下面我们重点逐一来分析一下上述代码中标注了数字的地方：</p>

<ol>
<li>标注1的代码创建Digester实例解析"conf/server.xml"文件</li>
<li>标注2的代码最终调用了StandardServer的init方法。</li>
</ol>


<p>大家可以自行查看下源代码，我们会发现如下的一个调用流程：
<code>java init call stack  
org.apache.catalina.core.StandardServer#init   
-&gt;org.apache.catalina.core.StandardService#init  
--&gt;org.apache.catalina.connector.Connector#init  
--&gt;org.apache.catalina.core.StandardEngine#init  
</code></p>

<blockquote><p>因为StandardService，Connector，StandardEngine实现了LifeCycle接口，因此符合我们上文所获的生命周期的管理，最终都是通过他们自己实现的initInternal方法进行初始化</p></blockquote>

<p>读到这里的时候，我想大家应该和我一样，以为StandardEngine#init方法会调用StandardHost#init方法，但是当我们查看StandardEngine#init方法的时候，发现并没有进行StandardHost的初始化，它到底做了什么呢？让我们来具体分析一下,我们首先拿StanderEngine的继承关系图来看下：
<img class="center" src="/images/2013/10/16/StandardEngine.png">
通过上图以及前面说的LifeCyecle的模板方法模式，我们知道StandardEngine的初始化钩子方法initInternal方法最终调用了ContainerBase的initInternal方法，那我们拿ContainerBase#initInternal方法的代码看看：<br/>
```java org.apache.catalina.core.ContainerBase#initInternal
protected void initInternal() throws LifecycleException {</p>

<pre><code>BlockingQueue&lt;Runnable&gt; startStopQueue =
    new LinkedBlockingQueue&lt;Runnable&gt;();
startStopExecutor = new ThreadPoolExecutor(
        getStartStopThreadsInternal(),
        getStartStopThreadsInternal(), 10, TimeUnit.SECONDS,
        startStopQueue,
        new StartStopThreadFactory(getName() + "-startStop-"));
startStopExecutor.allowCoreThreadTimeOut(true);
super.initInternal();
</code></pre>

<p>}
<code>
我们可以看到StandardEngine的初始化仅仅是创建了一个ThreadPoolExecutor，当看到这里的时候，笔者当时也纳闷了，StandardEngine#init竟然没有调用StandardHost#init方法，那么StandardHost的init方法是什么时候被调用的呢？遇到这种不知道到底方法怎么调用的时候怎么办呢？笔者介绍个方法给大家。我们现在需要知道StandardHost#init方法何时被调用的，而我们知道init最终会调用钩子的initInternal方法，因此这个时候，我们可以在StandardHost中override initInternal方法，增加了实现方法以后，有两种方法可以用，一种就是设置个断点debug一下就可以看出线程调用栈了，另外一种就是在新增的方法中打印出调用栈。笔者这里采用第二种方法，我们增加如下的initInternal方法到StandardHost中：
</code>java org.apache.catalina.core.StandardHost#initInternal
protected void initInternal() throws LifecycleException {</p>

<pre><code>Throwable ex = new Throwable();
StackTraceElement[] stackElements = ex.getStackTrace();
if (stackElements != null) {
    for (int i = stackElements.length - 1; i &gt;= 0; i--) {
        System.out.print(stackElements[i].getClassName() + "\t");
        System.out.print(stackElements[i].getMethodName() + "\t");
        System.out.print(stackElements[i].getFileName() + "\t");
        System.out.println(stackElements[i].getLineNumber());
    }
}
super.initInternal();   
</code></pre>

<p>}
<code>
上面的代码将会打印出方法调用堆栈，对于调试非常有用，上面的方法运行以后在控制台打印出了如下的堆栈信息：
</code>java stack info
java.lang.Thread    run Thread.java 680
java.util.concurrent.ThreadPoolExecutor$Worker  run ThreadPoolExecutor.java 918
java.util.concurrent.ThreadPoolExecutor$Worker  runTask ThreadPoolExecutor.java 895
java.util.concurrent.FutureTask run FutureTask.java 138
java.util.concurrent.FutureTask$Sync    innerRun    FutureTask.java 303
org.apache.catalina.core.ContainerBase$StartChild   call    ContainerBase.java  1549
org.apache.catalina.core.ContainerBase$StartChild   call    ContainerBase.java  1559
org.apache.catalina.util.LifecycleBase  start   LifecycleBase.java  139
org.apache.catalina.util.LifecycleBase  init    LifecycleBase.java  102
org.apache.catalina.core.StandardHost   initInternal    StandardHost.java   794
```
通过控制台的信息，我们看到是StartChild#call方法调用的，而我们查看StartChild#call方法其实是在StandardEngine的startInternal方法中通过异步线程池去初始化子容器。因此到这里我们就理清楚了，StarndardHost的init方法是在调用start方法的时候被初始化。那么接下来我们就来看看，start方法的整体调用流程。</p>

<h2>BootStrap#start</h2>

<p>采用分析load方法一样的方法，经过对BootStrap#start的分析，我们最终可以得到得到如下的调用链：
<code>java org.apache.catalina.startup.Bootstrap#start call stack
org.apache.catalina.startup.Bootstrap#start
-&gt;org.apache.catalina.startup.Catalina#start 通过反射调用
--&gt;org.apache.catalina.core.StandardServer#start
---&gt;org.apache.catalina.core.StandardService#start
----&gt;org.apache.catalina.core.StandardEngine#start
----&gt;org.apache.catalina.Executor#start
----&gt;org.apache.catalina.connector.Connector#start
</code></p>

<p>综合上文的描述我们总体得到如下的调用链：
```java org.apache.catalina.startup.Bootstrap#main call stack
org.apache.catalina.startup.Bootstrap#main
&ndash;>org.apache.catalina.startup.Bootstrap#init
&ndash;>org.apache.catalina.startup.Bootstrap#load
&mdash;>org.apache.catalina.startup.Catalina#load
&mdash;&ndash;>org.apache.catalina.core.StandardServer#init
&mdash;&mdash;>org.apache.catalina.core.StandardService#init
&mdash;&mdash;&ndash;>org.apache.catalina.connector.Connector#init
&mdash;&mdash;&ndash;>org.apache.catalina.core.StandardEngine#init
&ndash;>org.apache.catalina.startup.Bootstrap#start
&mdash;>org.apache.catalina.startup.Catalina#start 通过反射调用
&mdash;&ndash;>org.apache.catalina.core.StandardServer#start
&mdash;&mdash;>org.apache.catalina.core.StandardService#start
&mdash;&mdash;&ndash;>org.apache.catalina.core.StandardEngine#start
&mdash;&mdash;&ndash;>org.apache.catalina.Executor#start
&mdash;&mdash;&ndash;>org.apache.catalina.connector.Connector#start</p>

<p>```
通过上面的分析我们已经搞清楚了Tomcat启动的总体的过程，但是有一些关键的步骤，我们还需要进行进一步的深入探究。let&rsquo;s do it.</p>

<h1>Tomcat启动过程关键步骤分析</h1>

<h2>Connector#init</h2>

<p>我们首先来看一下<strong>org.apache.catalina.connector.Connector#init</strong>,我们知道Connector的生命周期也是通过LifeCycle的模板方法模式来管理的，那么我们只需要查看一下它的initInternal方法即可知道它是如何初始化的。接下来我们就来看一下initInternal方法，代码如下：</p>

<p>```java org.apache.catalina.connector.Connector#initInternal
protected void initInternal() throws LifecycleException {</p>

<pre><code>    super.initInternal();

    // Initialize adapter
    adapter = new CoyoteAdapter(this);
    protocolHandler.setAdapter(adapter);

    // Make sure parseBodyMethodsSet has a default
    if( null == parseBodyMethodsSet ) {
        setParseBodyMethods(getParseBodyMethods());
    }

    if (protocolHandler.isAprRequired() &amp;&amp;
            !AprLifecycleListener.isAprAvailable()) {
        throw new LifecycleException(
                sm.getString("coyoteConnector.protocolHandlerNoApr",
                        getProtocolHandlerClassName()));
    }

    try {
        // 1 
        protocolHandler.init();
    } catch (Exception e) {
        throw new LifecycleException
            (sm.getString
             ("coyoteConnector.protocolHandlerInitializationFailed"), e);
    }

    // Initialize mapper listener
    mapperListener.init();
}
</code></pre>

<p>```</p>

<p>上面代码中，本文最关心的是标注了1的地方，这个地方调用了<code>org.apache.coyote.ProtocolHandler#init</code>方法，而ProtocolHandler是在Connector的构造函数中初始化，而Connector的构造函数又是Digester类解析conf/server.xml的时候调用的，明白了这点，我们在来具体看看Connector构造函数中调用的一个核心的方法setProtocol方法，下面是其代码：</p>

<p>```java org.apache.catalina.connector.Connector#setProtocol
public void setProtocol(String protocol) {</p>

<pre><code>    if (AprLifecycleListener.isAprAvailable()) {
        //这里统一使用AprEndpoint
        if ("HTTP/1.1".equals(protocol)) {
            setProtocolHandlerClassName
                ("org.apache.coyote.http11.Http11AprProtocol");   //Http11AprProtocol$Http11ConnectionHandler
        } else if ("AJP/1.3".equals(protocol)) {
            setProtocolHandlerClassName
                ("org.apache.coyote.ajp.AjpAprProtocol");     //AjpAprProtocol$AjpConnectionHandler
        } else if (protocol != null) {
            setProtocolHandlerClassName(protocol);
        } else {
            setProtocolHandlerClassName
                ("org.apache.coyote.http11.Http11AprProtocol");
        }
    } else {
        // 1 
        if ("HTTP/1.1".equals(protocol)) {
            setProtocolHandlerClassName
                ("org.apache.coyote.http11.Http11Protocol");  //Http11Protocol$Http11ConnectionHandler
        } else if ("AJP/1.3".equals(protocol)) {
            setProtocolHandlerClassName
                ("org.apache.coyote.ajp.AjpProtocol");    //AjpProtocol$AjpConnectionHandler
        } else if (protocol != null) {
            setProtocolHandlerClassName(protocol);
        }
    }
</code></pre>

<p>}</p>

<p>```</p>

<p>从setProtocol的代码中，我们可以看出主要逻辑分为了两块，一种情况是使用<a href="http://tomcat.apache.org/tomcat-7.0-doc/apr.html">APR(Apache Portable Runtime)</a>，另外一种是不使用APR的情况。缺省情况下不采用APR库，这样的话，代码会走到标注1的代码分支，这里通过协议的不同，最终初始化了不同的类。如果是http1.1协议就采用<code>org.apache.coyote.http11.Http11Protocol</code>,如果是AJP(Apache Jserv Protocol)协议，就采用<code>org.apache.coyote.ajp.AjpProtocol</code>类，下面我们来看一下Http11Protocol和AjpProtocol的继承关系图如下：
<img class="center" src="/images/2013/10/17/Http11Protocol.png"><br/>
<img class="center" src="/images/2013/10/17/AJPProtocol.png">
通过上图我们可以看到它们都继承了公共的基类<code>org.apache.coyote.AbstractProtocol</code>,而它们自己的init方法最终其实都是调用了AbstractProtocol的init方法，通过查看AbstractProtocol#init代码，我们可以看到最终是调用了<code>org.apache.tomcat.util.net.AbstractEndpoint#init</code>,而AbstractEndpoint的实例化操作是在实例化AjpProtocol和Http11Protocol的时候在其构造函数中实例化的，而AjpProtocol和Http11Protocol构造函数中，其实都是初始化了<code>org.apache.tomcat.util.net.JIoEndpoint</code>类，只不过根据是http协议还是AJP协议，它们具有不同的连接处理类。其中Http11Protocol的连接处理类为<code>org.apache.coyote.http11.Http11Protocol.Http11ConnectionHandler</code>,而连接处理类为<code>org.apache.coyote.ajp.AjpProtocol.AjpConnectionHandler</code>，因此到这里我们基本清楚了Connector的初始化流程，总结如下：
```java Connect init 采用APR的情况
//1 HTTP/1.1协议连接器
org.apache.catalina.connector.Connector#init
&ndash;>org.apache.coyote.http11.Http11AprProtocol#init
&mdash;>org.apache.tomcat.util.net.AprEndpoint#init
(org.apache.coyote.http11.Http11AprProtocol.Http11ConnectionHandler)</p>

<p>// 2 AJP/1.3协议连接器
org.apache.catalina.connector.Connector#init
&ndash;>org.apache.coyote.ajp.AjpAprProtocol#init
&mdash;>org.apache.tomcat.util.net.AprEndpoint#init
(org.apache.coyote.ajp.AjpAprProtocol.AjpConnectionHandler)</p>

<p><code>
</code>java Connector init 不采用APR的情况
// 1 HTTP/1.1协议连接器
org.apache.catalina.connector.Connector#init
&ndash;>org.apache.coyote.http11.Http11Protocol#init
&mdash;>org.apache.tomcat.util.net.JIoEndpoint#init
(org.apache.coyote.http11.Http11Protocol.Http11ConnectionHandler)</p>

<p>// 2 AJP/1.3协议连接器
org.apache.catalina.connector.Connector#init
&ndash;>org.apache.coyote.ajp.AjpProtocol#init
&mdash;>org.apache.tomcat.util.net.JIoEndpoint#init
(org.apache.coyote.ajp.AjpProtocol.AjpConnectionHandler)</p>

<p>```</p>

<blockquote><p>这里需要注意，除了JIoEndpoint外，还有NIoEndpoint，对于Tomcat7.0.24的代码，并没有采用NIOEndPoint，NIOEndpoint采用了NIO的方式进行Socket的处理。</p></blockquote>

<p>最后，咋们再来看看org.apache.tomcat.util.net.JIoEndpoint#init的初始化过程，我们首先来看一下JIoEndpoint的继承关系图如下：
<img class="center" src="/images/2013/10/17/JIoEndpoint.png">
通过上图我们知道JIoEndpoint继承了AbstractEndpoint，而通过查看源码可知，JIoEndpoint没有实现自己的init方法，它默认采用了父类的init方法，那么我们就来看看AbstractEndpoint的init，它的代码如下：
```java org.apache.tomcat.util.net.AbstractEndpoint#init
 public final void init() throws Exception {</p>

<pre><code>    if (bindOnInit) {
        bind();
        bindState = BindState.BOUND_ON_INIT;
    }
</code></pre>

<p>}
<code>
通过查看上面的代码可知，因为bindOnInit默认是true,所以init调用了bind方法，而bind方法是抽象方法，最终由JIoEndpoint来实现，代码如下：
</code>java org.apache.tomcat.util.net.JIoEndpoint#bind
@Override
public void bind() throws Exception {</p>

<pre><code>    // Initialize thread count defaults for acceptor
    if (acceptorThreadCount == 0) {
        acceptorThreadCount = 1;
    }
    // Initialize maxConnections
    if (getMaxConnections() == 0) {
        // User hasn't set a value - use the default
        setMaxConnections(getMaxThreadsExecutor(true));
    }

    if (serverSocketFactory == null) {
        if (isSSLEnabled()) {
            serverSocketFactory =
                handler.getSslImplementation().getServerSocketFactory(this);
        } else {
            serverSocketFactory = new DefaultServerSocketFactory(this);
        }
    }

    if (serverSocket == null) {
        try {
            if (getAddress() == null) {
                serverSocket = serverSocketFactory.createSocket(getPort(),
                        getBacklog());
            } else {
                serverSocket = serverSocketFactory.createSocket(getPort(),
                        getBacklog(), getAddress());
            }
        } catch (BindException orig) {
            String msg;
            if (getAddress() == null)
                msg = orig.getMessage() + " &lt;null&gt;:" + getPort();
            else
                msg = orig.getMessage() + " " +
                        getAddress().toString() + ":" + getPort();
            BindException be = new BindException(msg);
            be.initCause(orig);
            throw be;
        }
    }
</code></pre>

<p>}
<code>``
通过上面代码可以看出，最终是调用了</code>org.apache.tomcat.util.net.ServerSocketFactory#createSocket<code>方法创建一个</code>java.net.ServerSocket`，并绑定在conf/server.xml中Connector中配置的端口。</p>

<p>综上我们可以得出如下结论：</p>

<blockquote><p>Connector#init的时候，无论是AJP还是HTTP最终其实是调用了JioEndpoint的初始化，默认情况在初始化的时候就会创建java.net.ServerSocket绑到到配置的端口上。</p></blockquote>

<h2>Connector#start</h2>

<p>接着我们再来分析一下Connector#start，因为Connector符合LifeCycle模板方法生命周期管理的机制，因此它的start最终会调用startInternal,org.apache.catalina.connector.Connector#startInternal代码如下：
```java org.apache.catalina.connector.Connector#startInternal</p>

<pre><code>protected void startInternal() throws LifecycleException {

    // Validate settings before starting
    if (getPort() &lt; 0) {
        throw new LifecycleException(sm.getString(
                "coyoteConnector.invalidPort", Integer.valueOf(getPort())));
    }

    setState(LifecycleState.STARTING);

    try {
        protocolHandler.start();
    } catch (Exception e) {
        String errPrefix = "";
        if(this.service != null) {
            errPrefix += "service.getName(): \"" + this.service.getName() + "\"; ";
        }

        throw new LifecycleException
            (errPrefix + " " + sm.getString
             ("coyoteConnector.protocolHandlerStartFailed"), e);
    }

    mapperListener.start();
}
</code></pre>

<p>```
通过上面的代码，我们可以清晰的看到最终调用了protocolHandler.start()，而根据Connector#init流程的分析，这里会分是否采用APR，默认是不采用APR的，这里会根据不同的协议（AJP，HTTP）来调用对应的org.apache.coyote.ProtocolHandler#start.
其中AJP会采用org.apache.coyote.ajp.AjpProtocol，HTTP协议采用org.apache.coyote.http11.Http11Protocol,而无论是AjpProtocol还是Http11Protocol都会调用JIoEndpoint的方法，那么接下来我们就来看看JioEndpoint的start方法，它的代码如下：</p>

<p>```java org.apache.tomcat.util.net.JIoEndpoint#startInternal
public void startInternal() throws Exception {</p>

<pre><code>    if (!running) {
        running = true;
        paused = false;

        // Create worker collection
        if (getExecutor() == null) {
            createExecutor();
        }

        initializeConnectionLatch();

        startAcceptorThreads();

        // Start async timeout thread
        Thread timeoutThread = new Thread(new AsyncTimeout(),
                getName() + "-AsyncTimeout");
        timeoutThread.setPriority(threadPriority);
        timeoutThread.setDaemon(true);
        timeoutThread.start();
    }
</code></pre>

<p>}
```
从上面的代码可以看出，启动了Acceptor线程和AsyncTimeout线程，首先来看看Acceptor线程，我们再来看看startAcceptorThreads方法，代码如下：</p>

<p>```java  org.apache.tomcat.util.net.AbstractEndpoint#startAcceptorThreads
protected final void startAcceptorThreads() {</p>

<pre><code>    int count = getAcceptorThreadCount();
    acceptors = new Acceptor[count];

    for (int i = 0; i &lt; count; i++) {
        acceptors[i] = createAcceptor();
        String threadName = getName() + "-Acceptor-" + i;
        acceptors[i].setThreadName(threadName);
        Thread t = new Thread(acceptors[i], threadName);
        t.setPriority(getAcceptorThreadPriority());
        t.setDaemon(getDaemon());
        t.start();
    }
</code></pre>

<p>}
<code>``
通过上面的代码，我们可以看出其实是通过</code>org.apache.tomcat.util.net.AbstractEndpoint.Acceptor<code>这个Runable接口的实现类来启动线程，接下来我们就来看看Acceptor#run方法，通过查看run方法，它里面其实就是调用了</code>java.net.ServerSocket#accept`的方法来接受一个Socket连接。</p>

<h2>StandardEngine#start</h2>

<p>从本文上面的分析中，我们得知StandardEngine继承了ContainerBase，而StandardEngine的startInternal钩子方法也仅仅是调用了父类ContainerBase的startInternal方法，那接下来我们分析一下ContainerBase的startInternal方法，代码如下：</p>

<p>```java org.apache.catalina.core.ContainerBase#startInternal
protected synchronized void startInternal() throws LifecycleException {</p>

<pre><code>// Start our child containers, if any
Container children[] = findChildren();
List&lt;Future&lt;Void&gt;&gt; results = new ArrayList&lt;Future&lt;Void&gt;&gt;();
for (int i = 0; i &lt; children.length; i++) {
    results.add(startStopExecutor.submit(new StartChild(children[i])));
}

boolean fail = false;
for (Future&lt;Void&gt; result : results) {
    try {
        result.get();
    } catch (Exception e) {
        log.error(sm.getString("containerBase.threadedStartFailed"), e);
        fail = true;
    }

}
if (fail) {
    throw new LifecycleException(
            sm.getString("containerBase.threadedStartFailed"));
}


setState(LifecycleState.STARTING);
</code></pre>

<p>}
```</p>

<p>我们删除了对本文的分析不相关的代码，只留下一些核心的代码，我们可以看到通过startStopExecutor异步的对子容器进行了启动，然后设置状态为<code>STARTING</code>的状态。而startStopExecutor是在容器的initInternal方法中进行初始化好的，接下来我们就来看看StartChild,StardChild的代码如下：
``` java org.apache.catalina.core.ContainerBase.StartChild
private static class StartChild implements Callable<Void> {</p>

<pre><code>    private Container child;

    public StartChild(Container child) {
        this.child = child;
    }

    @Override
    public Void call() throws LifecycleException {
        child.start();
        return null;
    }
</code></pre>

<p>}
<code>
通过上面的代码，我们可以看到StartChild实现了Callable接口，实现这个接口的类可以将其放到对应的executor中执行（对于executor不熟悉的童鞋可以去看一下相关的文章，本文不做介绍），StartChild在运行的时候就会调用到子容器的start方法，而此时的父容器是StandardEngine，子容器就是StandardHost,接下来我们就来看看StandardHost的启动过程。通过前面对于init流程的分析，我们知道StandardHost不是在StandardEngine#init的时候初始化，因此在执行StandardHost#start的时候，要首先进行init方法的调用，具体的代码如下：
</code>java org.apache.catalina.util.LifecycleBase#start
public final synchronized void start() throws LifecycleException {</p>

<pre><code>if (state.equals(LifecycleState.NEW)) {
    init(); //因为此时的StandardHost还没有初始化，因此会走到这一步代码
} else if (state.equals(LifecycleState.FAILED)){
    stop();
} else if (!state.equals(LifecycleState.INITIALIZED) &amp;&amp;
        !state.equals(LifecycleState.STOPPED)) {
    invalidTransition(Lifecycle.BEFORE_START_EVENT);
}

setStateInternal(LifecycleState.STARTING_PREP, null, false);

try {
    startInternal();
} catch (Throwable t) {
    ExceptionUtils.handleThrowable(t);
    setStateInternal(LifecycleState.FAILED, null, false);
    throw new LifecycleException(
            sm.getString("lifecycleBase.startFail",toString()), t);
}  
</code></pre>

<p>   setStateInternal(LifecycleState.STARTED, null, false);</p>

<p>}
```
上面省略了部分不相关的代码，在调用中我们可以清楚的看到，对于StandardHost的初始化，是在start的时候进行的。那接下来我们在来看一下StandardHost的init方法，通过查看代码，我们发现StandardHost本身没有实现initInternal的钩子方法，也就意味着最终初始化会调用ContainerBase#initInternal方法，而通过上文的描述，我们已经清楚ContainerBase#initInternal主要是初始化了一个startStopExecutor，这个线程池主要是为了异步的初始化子容器来用的。</p>

<blockquote><p>我们知道StandardEngine初始化的时候，也是初始化了一个线程池，而StandardHost也初始化了一个线程池，他们的不同点在与创建线程的工厂方法不同，在采用缺省配置的情况下，StandardEngine的线程池中的线程是以<code>Catalina-startStop</code>的形式命名的，而StandardHost是以<code>localhost-startStop</code>的方式进行命名的。大家注意区分。</p></blockquote>

<p>StandardHost#start调用init方法初始化完StandardHost以后，会调用钩子的startInternal方法，而startInternal方法又是调用了ContainerBased#startInternal方法，而ContainerBase#startInternal方法最终又会去启动子容器的，对于StandardHost来说，子容器就是StandardContext。
因此分析到这里我们可以得出如下结论：</p>

<blockquote><p>对于StandardEngine，StandardHost的启动，父容器在init的时候创建一个启动和停止子容器的线程池，然后父容器启动的时候首先通过异步的方式将子容器的启动通过<code>org.apache.catalina.core.ContainerBase.StartChild</code>提交到父容器中对应的线程池中进行启动，而子容器启动的时候首先会初始化，然后再启动。</p></blockquote>

<p>经过上面的分析，我们已经清楚了StandardEngine启动的过程了，但是我们还有一个地方需要进一步的分析。因为上面的分析我们仅仅只是分析了容器通过conf/server.xml配置文件的配置结构进行的启动，而我们都知道<code>CATALINA-HOME/webapps/</code>中的应用也是需要启动的，那么webapps目录的应用又是如何启动的呢？我们下面来分析一下，通过<a href="/blog/2013/10/16/tomcat-architecture/">Tomcat总体结构</a>的描述，我们已经知道，webapps目录下面的应用其实是属于Context的，而Context对应Tomcat中的StandardContext类，因此我们就知道应该对谁下手了，知道了目标以后，咋们还是采用之前的那种方式，要么debug,要么打印调用栈，这里我们还是通过打印调用栈的方式进行，我们在<code>org.apache.catalina.core.StandardContext#initInternal</code>中增加打印调用栈的方法，具体代码如下：
```java org.apache.catalina.core.StandardContext#initInternal
protected void initInternal() throws LifecycleException {</p>

<pre><code>    super.initInternal();
    Throwable ex = new Throwable();
    StackTraceElement[] stackElements = ex.getStackTrace();
    if (stackElements != null) {
        for (int i = stackElements.length - 1; i &gt;= 0; i--) {
            System.out.print(stackElements[i].getClassName() + "\t");
            System.out.print(stackElements[i].getMethodName() + "\t");
            System.out.print(stackElements[i].getFileName() + "\t");
            System.out.println(stackElements[i].getLineNumber());
        }
    }
    if (processTlds) {
        this.addLifecycleListener(new TldConfig());
    }

    // Register the naming resources
    if (namingResources != null) {
        namingResources.init();
    }

    // Send j2ee.object.created notification 
    if (this.getObjectName() != null) {
        Notification notification = new Notification("j2ee.object.created",
                this.getObjectName(), sequenceNumber.getAndIncrement());
        broadcaster.sendNotification(notification);
    }
</code></pre>

<p>}
<code>
运行代码，可以看到控制台有如下的输出：
</code>java terminal info
java.util.concurrent.ThreadPoolExecutor$Worker  run ThreadPoolExecutor.java 918
java.util.concurrent.ThreadPoolExecutor$Worker  runTask ThreadPoolExecutor.java 895
java.util.concurrent.FutureTask run FutureTask.java 138
java.util.concurrent.FutureTask$Sync    innerRun    FutureTask.java 303
java.util.concurrent.Executors$RunnableAdapter  call    Executors.java  439
org.apache.catalina.startup.HostConfig$DeployDirectory  run HostConfig.java 1671
org.apache.catalina.startup.HostConfig  deployDirectory HostConfig.java 1113
org.apache.catalina.core.StandardHost   addChild    StandardHost.java   622
org.apache.catalina.core.ContainerBase  addChild    ContainerBase.java  877
org.apache.catalina.core.ContainerBase  addChildInternal    ContainerBase.java  901
org.apache.catalina.util.LifecycleBase  start   LifecycleBase.java  139
org.apache.catalina.util.LifecycleBase  init    LifecycleBase.java  102
org.apache.catalina.core.StandardContext    initInternal    StandardContext.java    6449
```</p>

<p>通过查看控制台的输出，我们可以看到有一个<code>org.apache.catalina.startup.HostConfig$DeployDirectory</code>类，于是乎找到这个类去看看呗。打开一看它是一个Runable接口的实现类，因此我们推断它也是放到某个线程池中进行异步运行的，最终通过IntellIJ IDEA提供的类调用栈分析工具（ctrl+alt+h）得到DeployDirectory构造器方法的调用栈如下图所示：
<img class="center" src="/images/2013/10/17/DeployDirectory-call-stack.png">
通过上图我们可以清楚的看到，最终的调用方是<code>org.apache.catalina.startup.HostConfig#lifecycleEvent</code>,到这里我们就知道了Context的启动是通过某个组件的生命周期事件的监听器来启动的，而HostConfig到底是谁的监听器呢？通过名称我们应该可以猜测出它是StandardHost的监听器,那么它到底监听哪个事件呢？我们查看下org.apache.catalina.startup.HostConfig#lifecycleEvent的代码如下：
```java org.apache.catalina.startup.HostConfig#lifecycleEvent
public void lifecycleEvent(LifecycleEvent event) {</p>

<pre><code>    // Identify the host we are associated with
    try {
        host = (Host) event.getLifecycle();
        if (host instanceof StandardHost) {
            setCopyXML(((StandardHost) host).isCopyXML());
            setDeployXML(((StandardHost) host).isDeployXML());
            setUnpackWARs(((StandardHost) host).isUnpackWARs());
        }
    } catch (ClassCastException e) {
        log.error(sm.getString("hostConfig.cce", event.getLifecycle()), e);
        return;
    }

    // Process the event that has occurred
    if (event.getType().equals(Lifecycle.PERIODIC_EVENT)) {
        check();
    } else if (event.getType().equals(Lifecycle.START_EVENT)) {
        start();
    } else if (event.getType().equals(Lifecycle.STOP_EVENT)) {
        stop();
    }
</code></pre>

<p>}
```</p>

<p>通过上面的代码，我们可以看出监听的事件是<code>Lifecycle.START_EVENT</code>,而通过查看<code>org.apache.catalina.LifecycleState</code>的代码<code>STARTING(true,Lifecycle.START_EVENT)</code>就可以得知，此时生命周期状态应该是STARTING,到这里我们应该已经猜到了，HostConfig是在StandardHost#start的时候通过监听器调用，为了验证我们的猜测，我们debug一下代码，我们可以在HostConfig#start方法中打个断点，运行以后得到如下内存结构：
<img class="center" src="/images/2013/10/17/HostConfig.png">
通过上图也就验证了我们刚才的猜测。</p>

<p>通过上面的分析我们清楚了webapps目录中context的启动，总结如下：</p>

<blockquote><p>webapps目录中应用的启动在StandardHost#start的时候，通过<code>Lifecycle.START_EVENT</code>这个事件的监听器HostConfig进行进一步的启动。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tomcat总体结构（Tomcat源代码阅读系列之二）]]></title>
    <link href="http://imtiger.github.io/blog/2013/10/16/tomcat-architecture/"/>
    <updated>2013-10-16T14:33:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2013/10/16/tomcat-architecture</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/10/14/apache_tomcat_bag.jpg">
本文是<a href="/blog/2013/10/08/tomcat-source-code-study/">Tomcat源代码阅读系列</a>的第二篇文章，我们在本系列的第一篇文章：<a href="/blog/2013/10/14/run-tomcat-in-idea-or-eclipse/">在IntelliJ IDEA 和 Eclipse运行tomcat 7源代码</a>一文中介绍了如何在intelliJ IDEA 和 Eclipse中运行Tomcat源代码，本文介绍一下Tomcat的总体结构。</p>

<blockquote><p>本文没有特别指明的地方，源代码都是针对tomcat7.0.42来说。</p></blockquote>

<h1>Tomcat的总体结构</h1>

<p>Tomcat即是一个Http服务器也是一个Servlet容器，它的总体结构我们可以用下图来描述：</p>

<!-- more -->


<p><img class="center" src="/images/2013/10/16/TomcatArchitecture.png">
通过上图我们可以看出Tomcat中主要涉及Server,Service,Engine,Connector,Host,Context组件，之前用过Tomcat的童鞋是不是觉得这些组件的名称有点似曾相识的赶脚，没赶脚？！您再想想。好吧，不用你想了，我来告诉你吧。其实在Tomcat二进制分发包解压后,在conf目录中有一个server.xml文件，你打开它瞄两眼看看，是不是发现server.xml文件中已经包含了上述的几个名称。我拿我本地Tomcat7.0.42分发包中的server.xml来具体分析一下，它的内容如下：
```xml conf/server.xml(Tomcat 7.0.42)
&lt;?xml version=&lsquo;1.0&rsquo; encoding=&lsquo;utf-8&rsquo;?></p>

<!--
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->


<!-- Note:  A "Server" is not itself a "Container", so you may not
     define subcomponents such as "Valves" at this level.
     Documentation at /docs/config/server.html
 -->


<p><Server port="8005" shutdown="SHUTDOWN">
  <!-- Security listener. Documentation at /docs/config/listeners.html
  <Listener className="org.apache.catalina.security.SecurityListener" />
  &mdash;>
  <!--APR library loader. Documentation at /docs/apr.html -->
  <Listener className="org.apache.catalina.core.AprLifecycleListener" SSLEngine="on" />
  <!--Initialize Jasper prior to webapps are loaded. Documentation at /docs/jasper-howto.html -->
  <Listener className="org.apache.catalina.core.JasperListener" />
  <!-- Prevent memory leaks due to use of particular java/javax APIs-->
  <Listener className="org.apache.catalina.core.JreMemoryLeakPreventionListener" />
  <Listener className="org.apache.catalina.mbeans.GlobalResourcesLifecycleListener" />
  <Listener className="org.apache.catalina.core.ThreadLocalLeakPreventionListener" /></p>

<p>  &lt;!&mdash; Global JNDI resources</p>

<pre><code>   Documentation at /docs/jndi-resources-howto.html
</code></pre>

<p>  &mdash;>
  <GlobalNamingResources></p>

<pre><code>&lt;!-- Editable user database that can also be used by
     UserDatabaseRealm to authenticate users
--&gt;
&lt;Resource name="UserDatabase" auth="Container"
          type="org.apache.catalina.UserDatabase"
          description="User database that can be updated and saved"
          factory="org.apache.catalina.users.MemoryUserDatabaseFactory"
          pathname="conf/tomcat-users.xml" /&gt;
</code></pre>

<p>  </GlobalNamingResources></p>

<p>  &lt;!&mdash; A &ldquo;Service&rdquo; is a collection of one or more &ldquo;Connectors&rdquo; that share</p>

<pre><code>   a single "Container" Note:  A "Service" is not itself a "Container",
   so you may not define subcomponents such as "Valves" at this level.
   Documentation at /docs/config/service.html
</code></pre>

<p>   &mdash;>
  <Service name="Catalina"></p>

<pre><code>&lt;!--The connectors can use a shared executor, you can define one or more named thread pools--&gt;
&lt;!--
&lt;Executor name="tomcatThreadPool" namePrefix="catalina-exec-"
    maxThreads="150" minSpareThreads="4"/&gt;
--&gt;


&lt;!-- A "Connector" represents an endpoint by which requests are received
     and responses are returned. Documentation at :
     Java HTTP Connector: /docs/config/http.html (blocking &amp; non-blocking)
     Java AJP  Connector: /docs/config/ajp.html
     APR (HTTP/AJP) Connector: /docs/apr.html
     Define a non-SSL HTTP/1.1 Connector on port 8080
--&gt;
&lt;Connector port="8080" protocol="HTTP/1.1"
           connectionTimeout="20000"
           redirectPort="8443" /&gt;
&lt;!-- A "Connector" using the shared thread pool--&gt;
&lt;!--
&lt;Connector executor="tomcatThreadPool"
           port="8080" protocol="HTTP/1.1"
           connectionTimeout="20000"
           redirectPort="8443" /&gt;
--&gt;
&lt;!-- Define a SSL HTTP/1.1 Connector on port 8443
     This connector uses the JSSE configuration, when using APR, the
     connector should be using the OpenSSL style configuration
     described in the APR documentation --&gt;
&lt;!--
&lt;Connector port="8443" protocol="HTTP/1.1" SSLEnabled="true"
           maxThreads="150" scheme="https" secure="true"
           clientAuth="false" sslProtocol="TLS" /&gt;
--&gt;

&lt;!-- Define an AJP 1.3 Connector on port 8009 --&gt;
&lt;Connector port="8009" protocol="AJP/1.3" redirectPort="8443" /&gt;


&lt;!-- An Engine represents the entry point (within Catalina) that processes
     every request.  The Engine implementation for Tomcat stand alone
     analyzes the HTTP headers included with the request, and passes them
     on to the appropriate Host (virtual host).
     Documentation at /docs/config/engine.html --&gt;

&lt;!-- You should set jvmRoute to support load-balancing via AJP ie :
&lt;Engine name="Catalina" defaultHost="localhost" jvmRoute="jvm1"&gt;
--&gt;
&lt;Engine name="Catalina" defaultHost="localhost"&gt;

  &lt;!--For clustering, please take a look at documentation at:
      /docs/cluster-howto.html  (simple how to)
      /docs/config/cluster.html (reference documentation) --&gt;
  &lt;!--
  &lt;Cluster className="org.apache.catalina.ha.tcp.SimpleTcpCluster"/&gt;
  --&gt;

  &lt;!-- Use the LockOutRealm to prevent attempts to guess user passwords
       via a brute-force attack --&gt;
  &lt;Realm className="org.apache.catalina.realm.LockOutRealm"&gt;
    &lt;!-- This Realm uses the UserDatabase configured in the global JNDI
         resources under the key "UserDatabase".  Any edits
         that are performed against this UserDatabase are immediately
         available for use by the Realm.  --&gt;
    &lt;Realm className="org.apache.catalina.realm.UserDatabaseRealm"
           resourceName="UserDatabase"/&gt;
  &lt;/Realm&gt;

  &lt;Host name="localhost"  appBase="webapps"
        unpackWARs="true" autoDeploy="true"&gt;

    &lt;!-- SingleSignOn valve, share authentication between web applications
         Documentation at: /docs/config/valve.html --&gt;
    &lt;!--
    &lt;Valve className="org.apache.catalina.authenticator.SingleSignOn" /&gt;
    --&gt;

    &lt;!-- Access log processes all example.
         Documentation at: /docs/config/valve.html
         Note: The pattern used is equivalent to using pattern="common" --&gt;
    &lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"
           prefix="localhost_access_log." suffix=".txt"
           pattern="%h %l %u %t &amp;quot;%r&amp;quot; %s %b" /&gt;

  &lt;/Host&gt;
&lt;/Engine&gt;
</code></pre>

<p>  </Service>
</Server></p>

<p>```
接下来我们就根据上图以及conf/server.xml的内容来一步步描述一下上面所说的各种组件吧。</p>

<h2>Server</h2>

<p>首先闪联登场的是咋们的Server大哥（大家能给点掌声吗？），Server是Tomcat中最顶层的组件，它可以包含多个Service组件。在Tomcat源代码中Server组件对应源码中的<code>org.apache.catalina.core.StandardServer</code>类。StandardServer的继承关系图如下图所示：
<img class="center" src="/images/2013/10/16/StandardServer.jpg"></p>

<h2>Service</h2>

<p>接下来咋们来看看Service组件，Service组件相当于Connetor和Engine组件的包装器，它将一个或者多个Connector组件和一个Engine建立关联。缺省的的配置文件中，定义一个叫<code>Catalina</code>的服务，并将Http,AJP这两个Connector关联到了一个名为<code>Catalina</code>的Engine.Service组件对应Tomcat源代码中的<code>org.apache.catalina.core.StandardService</code>,StandardService的继承关系图如下图所示：
<img class="center" src="/images/2013/10/16/StandardService.png"></p>

<h2>Connector</h2>

<p>既然Tomcat需要提供http服务，而我们知道http应用层协议最终都是需要通过TCP层的协议进行包传递的，而Connector正是Tomcat中监听TCP网络连接的组件，一个Connector会监听一个独立的端口来处理来自客户端的连接。缺省的情况下Tomcat提供了如下两个Connector。我们分别描述一下：</p>

<ol>
<li>HTTP/1.1<br/>
<code>&lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt;</code>
上面定义了一个Connector，它缺省监听端口8080,这个端口我们可以根据具体情况进行改动。<code>connectionTimeout</code>定义了连接超时时间，单位是毫秒，<code>redirectPort</code>定义了ssl的重定向接口，根据缺省的配置，Connector会将ssl请求重定向到8443端口。</li>
<li>AJP/1.3<br/>
AJP表示<code>Apache Jserv Protocol</code>,此连接器将处理Tomcat和Aapache http服务器之间的交互，这个连机器是用来处理我们将Tomcat和Apache http服务器结合使用的情况。假如在同样的一台物理Server上面部署了一台Apache http服务器和多台Tomcat服务器，通过Apache服务器来处理静态资源以及负载均衡的时候，针对不同的Tomcat实例需要AJP监听不同的端口。</li>
</ol>


<p>Connector对应源代码中的<code>org.apache.catalina.connector.Connector</code>,它的继承关系图如下所示：
<img class="center" src="/images/2013/10/16/Connector.png"></p>

<h2>Engine</h2>

<p>Tomcat中有一个容器的概念，而Engine,Host,Context都属于Contanier，我们先来说说最顶层的容器Engine.<br/>
一个Engine可以包含一个或者多个Host,也就是说我们一个Tomcat的实例可以配置多个虚拟主机。<br/>
缺省的情况下<code>&lt;Engine name="Catalina" defaultHost="localhost"&gt;</code>定义了一个名称为Cataline的Engine.Engine对应源代码中的<code>org.apache.catalina.core.StandardEngine</code>，它的继承关系图如下图所示：
<img class="center" src="/images/2013/10/16/StandardEngine.png"></p>

<h2>Host</h2>

<p>Host定义了一个虚拟主机，一个虚拟主机可以有多个Context，缺省的配置如下：<br/>
<code>&lt;Host name="localhost"  appBase="webapps" unpackWARs="true" autoDeploy="true"&gt;….&lt;/Host&gt;</code> 其中<code>appBase</code>为webapps，也就是<code>&lt;CATALINA_HOME&gt;\webapps</code>目录，<code>unpackingWARS</code>属性指定在appBase指定的目录中的war包都自动的解压，缺省配置为true,<code>autoDeploy</code>属性指定是否对加入到appBase目录的war包进行自动的部署，缺省为true.<br/>
Host对应源代码中的<code>org.apache.catalina.core.StandardHost</code>,它的继承关系图如下所示：
<img class="center" src="/images/2013/10/16/StandardHost.png"></p>

<h2>Context</h2>

<p>在Tomcat中，每一个运行的webapp其实最终都是以Context的形成存在，每个Context都有一个根路径和请求URL路径，Context对应源代码中的<code>org.apache.catalina.core.StandardContext</code>,它的继承关系图如下图所示：
<img class="center" src="/images/2013/10/16/StandardContext.png">
在Tomcat中我们通常采用如下的两种方式创建一个Context.下面分别描述一下：</p>

<ol>
<li>在<code>&lt;CATALINA-HOME&gt;\webapps</code>目录中创建一个目录，这个时候将自动创建一个context，默认context的访问url为<code>http://host:port/dirname</code>,你也可以通过在<code>ContextRoot\META-INF</code>中创建一个context.xml的文件，其中包含如下的内容来指定应用的访问路径。
<code>&lt;Context path="/yourUrlPath" /&gt;</code></li>
<li>conf\server.xml文件中增加context元素。
第二种创建context的方法，我们可以选择在server.xml文件的<code>&lt;Host&gt;</code>元素，比如我们在server.xml文件中增加如下内容：
<code>xml server.xml
     ......
     ......
     &lt;Context path="/mypath" docBase="/Users/tiger/develop/xxx" reloadable="true"&gt;
     &lt;/Context&gt;
   &lt;/Host&gt;
 &lt;/Engine&gt;
&lt;/Service&gt;
&lt;/Server&gt;
</code>
这样的话，我们就可以通过<code>http://host:port/mypath</code>访问上面配置的context了。</li>
</ol>


<h2>Valve</h2>

<p>Valve中文意思是阀门，Valve是Tomcat中责任链模式的实现，通过链接多个Valve对请求进行处理。其中Valve可以定义在任何的Container中，上面说的Engine,Host,Context都属于容器。tomcat 默认定义了一个名为<code>org.apache.catalina.valves.AccessLogValve</code>的Valve,这个Valve负责拦截每个请求，然后记录一条访问日志。</p>

<p>通过上面的分析，我们发现Server,Service,Engine,Host,Context都实现了<code>org.apache.catalina.Lifecycle</code>接口，通过这个接口管理了这些核心组件的生命周期，关于这些组件的生命周期，我们在下一篇文章描述。</p>

<p>下篇：<br/>
<a href="/blog/2013/10/17/tomcat-start-process/">Tomcat启动过程（Tomcat源代码阅读系列之三）</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在IntelliJ IDEA 和 Eclipse运行tomcat 7源代码（Tomcat源代码阅读系列之一）]]></title>
    <link href="http://imtiger.github.io/blog/2013/10/14/run-tomcat-in-idea-or-eclipse/"/>
    <updated>2013-10-14T14:39:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2013/10/14/run-tomcat-in-idea-or-eclipse</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/10/14/apache_tomcat_bag.jpg">
本文是<a href="/blog/2013/10/08/tomcat-source-code-study/">Tomcat源代码阅读系列</a>的第一篇文章，在阅读Tomcat源代码之前，我们首先需要将Tomcat的源代码在IDE里面运行起来，这样方便我们阅读的过程中调试。本文总结一下在IDEA 或者 Eclipse中运行Tomcat源代码环境的搭建过程，同时我们通过Maven来负责项目的构建。</p>

<p>在进行搭建之前，我们首先来说一下总体的思路。我们知道Tomcat运行的时候，一部分是源代码编译以后的可运行的Jar,另外一部分则是运行时的环境（也就是我们从官方下载下来的二进制分发包中的一系列的配置文件以及目录结构，说的更直白点就是CATALINA_HOME环境变量指定的目录）,本文对于第一部分采用IntelliJ IDEA 运行tomcat-7.0.42 tag的源代码，而对于第二部分运行环境，我们则直接采用tomcat-7.0.42的二进制分发包。明白了上述的思路以后，咋们就来一步步的搭建吧。</p>

<!-- more -->


<p>首先咋们来看看搭建完成以后的总体的目录结构，然后再一步步的去分解搭建过程。笔者搭建完以后，最终的运行结构如下图所示：
<img class="center" src="/images/2013/10/14/project-structure.png"></p>

<p>下面分别解释一下上图工程结构中涉及到的文件和目录：</p>

<ol>
<li>.idea和tomcat-study.iml是IntelliJ IDEA的文件，如果你用Eclipse的话不会存在这两个东东 。</li>
<li>catalina-home是从官方下载的7.0.42的二进制分发包解压后的目录</li>
<li>target是Maven编译项目以后生成的文件夹，熟悉Maven的读者应该很熟悉此目录</li>
<li>tomcat-7.0.42-sourcecode是从Tomcat<a href="http://svn.apache.org/repos/asf/tomcat/tc7.0.x/tags/TOMCAT_7_0_42/">官方仓库</a>下载的tags的源代码</li>
<li>pom.xml是Maven的配置文件,此工程中有两个pom.xml，这里运用了Maven聚合的特性。</li>
</ol>


<p>了解了最终的结构以后，咋们就来一步步的搭建它吧。</p>

<h3>第一步 创建项目目录结构</h3>

<p>本文假设我们将项目放在<code>~/develop/java</code>目录中。
<code>bash create project structure
cd ~/develop/java
mkdir Tomcat
cd Tomcat
touch pom.xml
</code></p>

<h3>第二步 下载Tomcat 7.0.42二进制分发包</h3>

<p>我们通过apache-tomcat-7.0.42的<a href="http://mirrors.hust.edu.cn/apache/tomcat/tomcat-7/v7.0.42/bin/apache-tomcat-7.0.42.tar.gz">官方地址</a>下载它。具体的过程如下：
<code>bash download apache-tomcat-7.0.42 binary distribution
cd ~/develop/java/Tomcat
wget http://mirrors.hust.edu.cn/apache/tomcat/tomcat-7/v7.0.42/bin/apache-tomcat-7.0.42.tar.gz
tar -zxvf apache-tomcat-7.0.42.tar.gz
rm apache-tomcat-7.0.42.tar.gz
mv apache-tomcat-7.0.42 catalina-home
</code></p>

<h3>第三步 下载Tomcat 7.0.42 源代码</h3>

<p>接下来我们从Tomcat的<a href="http://svn.apache.org/repos/asf/tomcat/tc7.0.x/tags/TOMCAT_7_0_42/">官方SVN仓库</a>下载Tomcat 7.0.42源代码，具体的步骤如下：
<code>bash download Tomcat 7.0.42 source code
cd ~/develop/java/Tomcat
svn co http://svn.apache.org/repos/asf/tomcat/tc7.0.x/tags/TOMCAT_7_0_42/  tomcat-7.0.42-sourcecode
</code>
在这一步中，我们将7.0.42的源代码迁入到了tomcat-7.0.42-sourcecode目录中。</p>

<h3>第四步 创建聚合模块pom.xml</h3>

<p>因为我们通过maven来对项目进行构建，这就需要我们来创建一个pom.xml文件，具体过程如下：
<code>bash create aggregation child project pom.xml
cd ~/develop/java/Tomcat/tomcat-7.0.42-sourcecode
touch pom.xml
</code>
用你喜欢的编辑器打开pom.xml然后用下面的内容替换它的内容：</p>

<p>```xml pom.xml
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
&lt;project xmlns=&ldquo;<a href="http://maven.apache.org/POM/4.0.0">http://maven.apache.org/POM/4.0.0</a>&rdquo;</p>

<pre><code>     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;


&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
&lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;
&lt;artifactId&gt;Tomcat7.0&lt;/artifactId&gt;
&lt;name&gt;Tomcat7.0&lt;/name&gt;
&lt;version&gt;7.0&lt;/version&gt;

&lt;build&gt;
    &lt;finalName&gt;Tomcat7.0&lt;/finalName&gt;
    &lt;sourceDirectory&gt;java&lt;/sourceDirectory&gt;
    &lt;testSourceDirectory&gt;test&lt;/testSourceDirectory&gt;
    &lt;resources&gt;
        &lt;resource&gt;
            &lt;directory&gt;java&lt;/directory&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
    &lt;testResources&gt;
        &lt;testResource&gt;
            &lt;directory&gt;test&lt;/directory&gt;
        &lt;/testResource&gt;
    &lt;/testResources&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
            &lt;version&gt;2.3&lt;/version&gt;

            &lt;configuration&gt;
                &lt;encoding&gt;UTF-8&lt;/encoding&gt;
                &lt;source&gt;1.6&lt;/source&gt;
                &lt;target&gt;1.6&lt;/target&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.4&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;ant&lt;/groupId&gt;
        &lt;artifactId&gt;ant&lt;/artifactId&gt;
        &lt;version&gt;1.7.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;wsdl4j&lt;/groupId&gt;
        &lt;artifactId&gt;wsdl4j&lt;/artifactId&gt;
        &lt;version&gt;1.6.2&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.xml&lt;/groupId&gt;
        &lt;artifactId&gt;jaxrpc&lt;/artifactId&gt;
        &lt;version&gt;1.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.eclipse.jdt.core.compiler&lt;/groupId&gt;
        &lt;artifactId&gt;ecj&lt;/artifactId&gt;
        &lt;version&gt;4.2.2&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>

<p></project></p>

<p>```
对于pom.xml文件我们需要注意以下几点：</p>

<ol>
<li>因为下载代码不符合Maven默认的目录结构约定，因此需要修改<code>resources</code>和<code>testResources</code>为<code>java</code>和 <code>test</code>，而不是默认的<code>src/main/resource</code>和<code>src/test/resource</code>,修改<code>sourceDirectory</code>和<code>testSourceDirectory</code>为，<code>java</code>和<code>test</code>,而不是默认的<code>src/main/java</code>和<code>src/test/java</code>.</li>
<li>因为Tomcat源代码的编译需要wsdl4j，jaxrpc,ecj等jar包，因此需要增加相关的依赖。</li>
</ol>


<h3>第五步 创建项目的根pom.xml文件</h3>

<p>这一步我么在Tomcat目录中创建pom.xml文件，这里采用了Maven中聚合的概念.具体过程如下：
<code>bash create root pom.xml
cd ~/develop/java/Tomcat
touch pom.xml
</code>
用你喜欢的编辑器打开刚创建的空的pom.xml文件，修改它的内容如下：
```xml ~/develop/java/Tomcat/pom.xml
&lt;project xmlns=&ldquo;<a href="http://maven.apache.org/POM/4.0.0">http://maven.apache.org/POM/4.0.0</a>&rdquo; xmlns:xsi=&ldquo;<a href="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</a>&rdquo;</p>

<pre><code>     xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt;

&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
&lt;groupId&gt;net.imtiger&lt;/groupId&gt;
&lt;artifactId&gt;tomcat-study&lt;/artifactId&gt;
&lt;name&gt;Tomcat 7.0 Study&lt;/name&gt;
&lt;version&gt;1.0&lt;/version&gt;
&lt;packaging&gt;pom&lt;/packaging&gt;

&lt;modules&gt;
    &lt;module&gt;tomcat-7.0.42-sourcecode&lt;/module&gt;
&lt;/modules&gt;
</code></pre>

<p></project>
```</p>

<h3>第六步 用IntelliJ IDEA 打开项目根目录的pom.xml</h3>

<p>这一步需要注意，要用IDEA 打开项目根目录的pom.xml文件（也就是~/develop/java/Tomcat/pom.xml）</p>

<h3>第七步 运行Tomcat</h3>

<p>终于到激动人心的时刻了,我们知道任何Java程序都会有一个<code>public static void main(String… args)</code>的入口，Tomcat本身是用Java写的，因此它也不例外，对于Tomcat来说，入口类是<code>org.apache.catalina.startup.Bootstrap</code>,我们找到这个类，然后在IntelliJ IDEA中创建一个运行配置，其中最主要的就是VM options的配置了，在VM options里面填写如下的参数：</p>

<p><code>java VM options
-Dcatalina.home=catalina-home -Dcatalina.base=catalina-home
-Djava.endorsed.dirs=catalina-home/endorsed -Djava.io.tmpdir=catalina-home/temp
-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager
-Djava.util.logging.config.file=catalina-home/conf/logging.properties
</code>
配置好后，IntelliJ IDEA的配置界面如下：
<img class="center" src="/images/2013/10/14/vm-options.png"></p>

<p>点击运行，即可看到Tomcat已经启动了，日志已经打到了IntelliJ IDEA的控制台上了，这个时候可以启动浏览器输入<a href="http://127.0.0.1:8080">http://127.0.0.1:8080</a>看看是否启动成功。</p>

<p>接下来，咋们在Bootstrap的main方法中，增加一句<code>System.out.println("Have fun and Enjoy!");</code>,然后运行一下，看看加入的信息是否被打入到了控制台，在笔者的电脑上打印可以看到信息已经输出如下信息：
<code>java console log
Have fun and Enjoy!
//ignore other log info
2013-10-14 17:19:35 org.apache.catalina.startup.Catalina start
信息: Server startup in 908 ms
</code>
上面就是Tomcat7.0.42源代码在IntelliJ IDEA运行环境搭建的完整的过程。因为笔者日常开发采用的是IntelliJ IDEA,所以本文就只写了IntelliJ IDEA的搭建，但是本文采用了Maven来进行构建的，理论上来说其它IDE，比如Eclipse，只要支持Maven,则可以采用本文同样的方法进行，用Eclipse开发的童鞋，按照本文的步骤理论上也是可以运行起来的。</p>

<p>最后，列出几个笔者在搭建的过程中遇到的几个小问题。</p>

<ol>
<li><code>org.apache.catalina.connector.TestRequest</code>类的<code>prepareRequestBug54984</code>中有两个特殊字符<code>äö</code>,在SVN 迁出的时候变为了乱码，导致Maven在编译的时候编译不过，大家可以复制<code>äö</code>替换乱码的字符即可。</li>
<li><code>CompilationUnit</code>类中的<code>public boolean ignoreOptionalProblems()</code>方法被标记为了@Override，但是其实现的接口<code>ICompilationUnit</code>属于<code>org.eclipse.jdt.core.compiler:ecj</code>，而3.x版本的<code>ICompilationUnit</code>中没有<code>ignoreOptionalProblems</code>方法，4.x的版本中才有，因此为了编译通过，本文采用了4.2.2版本。</li>
</ol>


<p>另外本文最终搭建好的环境，我已经放在Github上了，不想搭建的童鞋可以直接clone一份使用。<a href="https://github.com/imtiger/Tomcat">Github仓库地址</a></p>

<p>下篇：<br/>
<a href="/blog/2013/10/16/tomcat-architecture/">Tomcat总体结构（Tomcat源代码阅读系列之二）</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tomcat源代码阅读系列开篇]]></title>
    <link href="http://imtiger.github.io/blog/2013/10/08/tomcat-source-code-study/"/>
    <updated>2013-10-08T11:18:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2013/10/08/tomcat-source-code-study</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/10/14/apache_tomcat_bag.jpg">
我想学习Java开发的童鞋，或多或少的都应该接触过Tomcat，Tomcat在Java web开发中占据着非常重要的地位。</p>

<p>之前的时候也林林总总的阅读过Tomcat源代码，但是没有进行过总结。另外我觉得一个技术自己掌握了是一个层次，能将自己掌握的技术，通过文字或者语言跟其他人交流，并让其他人也能快速的理解自己表达意思有是另外一个层次了。因此我决定将自己阅读Tomcat源代码的过程记录一下，并分享到博客中，让有同样兴趣的童鞋可以参考下，也欢迎各位童鞋讨论。</p>

<p>接下来我们就来说说本系列所涉及的主要内容吧。<br/>
<a href="/blog/2013/10/14/run-tomcat-in-idea-or-eclipse/">在IntelliJ IDEA 和 Eclipse运行tomcat 7源代码（Tomcat源代码阅读系列之一）</a>  <br/>
<a href="/blog/2013/10/16/tomcat-architecture/">Tomcat总体结构（Tomcat源代码阅读系列之二）</a><br/>
<a href="/blog/2013/10/17/tomcat-start-process/">Tomcat启动过程（Tomcat源代码阅读系列之三）</a><br/>
<a href="#">Tomcat关闭过程</a>  (未完成)<br/>
<a href="#">Tomcat请求处理流程</a> (未完成)    <br/>
<a href="#">Tomcat类加载器机制</a> (未完成) <br/>
<a href="#">Tomcat Session管理机制</a>(未完成)  <br/>
<a href="#">Tomcat 涉及的设计模式总结</a> (未完成)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实例分析Java Class文件的结构-实践篇]]></title>
    <link href="http://imtiger.github.io/blog/2013/01/30/java-class-file-format-demo/"/>
    <updated>2013-01-30T12:16:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2013/01/30/java-class-file-format-demo</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/01/30/java-logo.jpg" width="500" height="300"><br/>
在<a href="/blog/2013/01/30/java-class-file-format/"><code>实例分析Java Class文件的结构-理论篇</code></a>一文中，我们说了Java Class文件结构的理论知识，接下来我们来通过一个具体的例子来理论结合实践的学习一下。
首先我们有一个TestClass类，代码如下：
```java TestClass.java</p>

<pre><code> package com.ejushang.TestClass;
 public class TestClass implements Super{

         private static final int staticVar = 0;

         private int instanceVar=0;

         public int instanceMethod(int param){
             return param+1;
         }

 }

 interface Super{ }
</code></pre>

<p>```</p>

<p>通过jdk1.6.0_37的javac 编译后的TestClass.java对应的TestClass.class的二进制结构如下图所示：</p>

<!-- more -->


<p><img class="center" src="/images/2013/01/30/test-class-file.png"></p>

<ol>
<li><p>魔数<br/>
从Class的文件结构我们知道，刚开始的4个字节是魔数，上图中从地址00000000h-00000003h的内容就是魔数，从上图可知Class的文件的魔数是0xCAFEBABE。</p></li>
<li><p>主次版本号 <br/>
接下来的4个字节是主次版本号，由上图可知从00000004h-00000005h对应的是0x0000,因此Class的minor_version为0x0000,从00000006h-00000007h对应的内容为0x0032,因此Class文件的major_version版本为0x0032,这正好就是jdk1.6.0不带target参数编译后的Class对应的主次版本。</p></li>
<li><p>常量池的数量 <br/>
接下来的2个字节从00000008h-00000009h表示常量池的数量，由上图可以知道其值为0x0018，十进制为24个,但是对于常量池的数量需要明确一点，常量池的数量是constant_pool_count-1，为什么减一，是因为索引0表示class中的数据项不引用任何常量池中的常量。</p></li>
<li><p>常量池
我们上面说了常量池中有不同类型的常量，下面就来看看TestClass.class的第一个常量，我们知道每个常量都有一个u1类型的tag标识来表示常量的类型，上图中0000000ah处的内容为0x0A，转换成二级制是10，由上面的关于常量类型的描述可知tag为10的常量是Constant_Methodref_info,而Constant_Methodref_info的结够如下图所示：
<img class="center" src="/images/2013/01/30/constant-methodref-info.png"> <br/>
<code>class_index</code>指向常量池中类型为CONSTANT_Class_info的常量，从TestClass的二进制文件结构中可以看出class_index的值为0x0004（地址为0000000bh-0000000ch)，也就是说指向第四个常量。 <br/>
<code>name_and_type_index</code>指向常量池中类型为CONSTANT_NameAndType_info常量。从上图可以看出name_and_type_index的值为0x0013，表示指向常量池中的第19个常量.接下来又可以通过同样的方法来找到常量池中的所有常量。不过JDK提供了一个方便的工具可以让我们查看常量池中所包含的常量。通过javap -verbose TestClass 即可得到所有常量池中的常量，截图如下：<br/>
<img class="center" src="/images/2013/01/30/test-class-javap.png"> <br/>
从上图我们可以清楚的看到，TestClass中常量池有24个常量，不要忘记了第0个常量，因为第0个常量被用来表示 Class中的数据项不引用任何常量池中的常量。从上面的分析中我们得知TestClass的第一个常量表示方法，其中class_index指向的第四个常量为java/lang/Object，name_and_type_index指向的第19个常量值为<init>:()V,从这里可以看出第一个表示方法的常量表示的是java编译器生成的实例构造器方法。通过同样的方法可以分析常量池的其它常量。OK，分析完常量池，我们接下来再分析下access_flags。</p></li>
<li>u2 access_flags
表示类或者接口方面的访问信息，比如Class表示的是类还是接口，是否为public,static，final等。具体访问标示的含义之前已经说过了，下面我们就来看看TestClass的访问标示。Class的访问标示是从0000010dh-0000010e，其值为0x0021，根据前面说的各种访问标示的标志位，我们可以知道：0x0021=0x0001|0x0020 也即ACC_PUBLIC 和 ACC_SUPER为真，其中ACC_PUBLIC大家好理解，ACC_SUPER是jdk1.2之后编译的类都会带有的标志。</li>
<li><p>u2 this_class <br/>
表示类的索引值，用来表示类的全限定名称，类的索引值如下图所示：<br/>
<img class="center" src="/images/2013/01/30/class-index.png"><br/>
从上图可以清楚到看到，类索引值为0x0003，对应常量池的第三个常量，通过javap的结果，我们知道第三个常量为CONSTANT_Class_info类型的常量，通过它可以知道类的全限定名称为：com/ejushang/TestClass/TestClass</p></li>
<li><p>u2 super_class <br/>
表示当前类的父类的索引值，索引值指向常量池中类型为CONSTANT_Class_info的常量，父类的索引值如下图所示，其值为0x0004,查看常量池的第四个常量，可知TestClass的父类的全限定名称为：java/lang/Object.
<img class="center" src="/images/2013/01/30/super-class.png"></p></li>
<li><p>interfaces_count 、 interfaces[interfaces_count]<br/>
表示接口数量以及具体的每一个接口，TestClass的接口数量以及接口如下图所示，其中0x0001表示接口数量为1，而0x0005表示接口在常量池的索引值，找到常量池的第五个常量，其类型为CONSTANT_Class_info，其值为：com/ejushang/TestClass/Super
<img class="center" src="/images/2013/01/30/interface-count.png"></p></li>
<li><p>fields_count、field_info <br/>
fields_count表示类中field_info表的数量，而field_info表示类的实例变量和类变量，这里需要注意的是field_info不包含从父类继承过来的字段，field_info的结构如下图所示：<br/>
<img class="center" src="/images/2013/01/30/field-info.png"><br/>
<code>access_flags</code>表示字段的访问标识，比如public,private,protected，static,final等，access_flags的取值如下图所示：<br/>
<img class="center" src="/images/2013/01/30/access-flags.png"><br/>
<code>name_index</code> 和 <code>descriptor_index</code>都是常量池的索引值，分别表示字段的名称和字段的描述符，字段的名称容易理解，但是字段的描述符如何理解呢？其实在JVM 规范中，对于字段的描述符规定如下图所示：<br/>
<img class="center" src="/images/2013/01/30/field-descriptor.png"><br/>
其中大家需要关注一下上图最后一行，它表示的是对一维数组的描述符，对于String[][]的描述符将是[[ Ljava/lang/String,而对于int[][]的描述符为[[I。接下来的attributes_count以及attribute_info分别表示属性表的数量以及属性表。<br/>
下面我们还是以上面的TestClass为例，来看看TestClass的字段表吧。首先我们来看一下字段的数量，TestClass的字段的数量如下图所示：<br/>
<img class="center" src="/images/2013/01/30/testclass-field-count.png"><br/>
从上图中可以看出TestClass有两个字段，查看TestClass的源代码可知，确实也只有两个字段，接下来我们看看第一个字段，我们知道第一个字段应该为private int staticVar,它在Class文件中的二进制表示如下图所示：<br/>
<img class="center" src="/images/2013/01/30/field-one.png"><br/>
其中0x001A表示访问标示，通过查看access_flags表可知，其为ACC_PRIVATE,ACC_STATIC,ACC_FINAL,接下来0x0006和0x0007分别表示常量池中第6和第7个常量，通过查看常量池可知，其值分别为：staticVar和I，其中staticVar为字段名称，而I为字段的描述符，通过上面对描述符的解释，I所描述的是int类型的变量，接下来0x0001表示staticVar这个字段表中的属性表的数量，从上图可以staticVar字段对应的属性表有1个，0x0008表示常量池中的第8个常量，查看常量池可以得知此属性为ConstantValue属性，而ConstantValue属性的格式如下图所示：<br/>
<img class="center" src="/images/2013/01/30/constantvalue-attribute.png"><br/>
其中<code>attribute_name_index</code>表述属性名的常量池索引，本例中为ConstantValue，而ConstantValue的<code>attribute_length</code>固定长度为2，而<code>constantValue_index</code>表示常量池中的引用，本例中，其中为0x0009，查看第9个常量可以知道，它表示一个类型为CONSTANT_Integer_info的常量，其值为0。<br/>
上面说完了<code>private static final int staticVar=0</code>，下面我们接着说一下TestClass的<code>private int instanceVar=0</code>,在本例中对instanceVar的二进制表示如下图所示：
<img class="center" src="/images/2013/01/30/field-two.png"><br/>
其中0x0002表示访问标示为ACC_PRIVATE,0x000A表示字段的名称，它指向常量池中的第10个常量，查看常量池可以知道字段名称为instanceVar，而0x0007表示字段的描述符，它指向常量池中的第7个常量，查看常量池可以知道第7个常量为I，表示类型为instanceVar的类型为I，最后0x0000表示属性表的数量为0.</p></li>
<li>methods_count 、method_info <br/>
methods_count表示方法的数量，而method_info表示的方法表，其中方法表的结构如下图所示：<br/>
<img class="center" src="/images/2013/01/30/method-info.png">  <br/>
从上图可以看出method_info和field_info的结构是很类似的，方法表的access_flag的所有标志位以及取值如下图所示：<br/>
<img class="center" src="/images/2013/01/30/access-flags.png">  <br/>
其中<code>name_index</code>和<code>descriptor_index</code>表示的是方法的名称和描述符，他们分别是指向常量池的索引。这里需要结解释一下方法的描述符，方法的描述符的结构为：<code>（参数列表）返回值</code>，比如<code>public int instanceMethod(int param)</code>的描述符为：<code>（I）I</code>，表示带有一个int类型参数且返回值也为int类型的方法，接下来就是属性数量以及属性表了，方法表和字段表虽然都有属性数量和属性表，但是他们里面所包含的属性是不同。接下来我们就以TestClass来看一下方法表的二进制表示。首先来看一下方法表数量，截图如下：
<img class="center" src="/images/2013/01/30/method-count.png"><br/>
从上图可以看出方法表的数量为0x0002表示有两个方法，接下来我们来分析第一个方法，我们首先来看一下TestClass的第一个方法的<code>access_flag</code>，<code>name_index</code>,<code>descriptor_index</code>，截图如下：<br/>
<img class="center" src="/images/2013/01/30/method-one-info.png"><br/>
从上图可以知道access_flags为0x0001，从上面对access_flags标志位的描述，可知方法的access_flags的取值为ACC_PUBLIC,name_index为0x000B，查看常量池中的第11个常量，知道方法的名称为<init>，0x000C表示descriptor_index表示常量池中的第12常量，其值为()V,表示<init>方法没有参数和返回值，其实这是编译器自动生成的实例构造器方法。接下来的0x0001表示<init>方法的方法表有1个属性，属性截图如下：
<img class="center" src="/images/2013/01/30/init-method-info.png"> <br/>
从上图可以看出0x000D对应的常量池中的常量为Code,表示的方法的Code属性，所以到这里大家应该明白方法的那些代码是存储在Class文件方法表中的属性表中的Code属性中。接下来我们在分析一下Code属性，Code属性的结构如下图所示：
<img class="center" src="/images/2013/01/30/code-attribute.png"><br/>
其中<code>attribute_name_index</code>指向常量池中值为Code的常量，<code>attribute_length</code>的长度表示Code属性表的长度（这里需要注意的时候长度不包括attribute_name_index和attribute_length的6个字节的长度）。<br/>
<code>max_stack</code>表示最大栈深度，虚拟机在运行时根据这个值来分配栈帧中操作数的深度.<br/>
<code>max_locals</code>代表了局部变量表的存储空间,它的单位为slot，slot是虚拟机为局部变量分配内存的最小单元，在运行时，对于不超过32位类型的数据类型，比如byte,char,int等占用1个slot，而double和Long这种64位的数据类型则需要分配2个slot，另外max_locals的值并不是所有局部变量所需要的内存数量之和，因为slot是可以重用的，当局部变量超过了它的作用域以后，局部变量所占用的slot就会被重用。 <br/>
<code>code_length</code>代表了字节码指令的数量，而code表示的时候字节码指令，从上图可以知道code的类型为u1,一个u1类型的取值为0x00-0xFF,对应的十进制为0-255，目前虚拟机规范已经定义了200多条指令。<br/>
<code>exception_table_length</code>以及<code>exception_table</code>分别代表方法对应的异常信息。<br/>
<code>attributes_count</code>和<code>attribute_info</code>分别表示了Code属性中的属性数量和属性表，从这里可以看出Class的文件结构中，属性表是很灵活的，它可以存在于Class文件，方法表，字段表以及Code属性中。
接下来我们继续以上面的例子来分析一下，从上面init方法的Code属性的截图中可以看出，属性表的长度为0x00000026,max_stack的值为0x0002,max_locals的取值为0x0001,code_length的长度为0x0000000A，那么00000149h-00000152h为字节码，接下来exception_table_length的长度为0x0000，而attribute_count的值为0x0001，00000157h-00000158h的值为0x000E,它表示常量池中属性的名称，查看常量池得知第14个常量的值为LineNumberTable，LineNumberTable用于描述java源代码的行号和字节码行号的对应关系，它不是运行时必需的属性,接下来我们再看一下LineNumberTable的结构如下图所示：</li>
</ol>


<blockquote><p>如果通过-g:none的编译器参数来取消生成LineNumberTable的话，最大的影响就是异常发生的时候，堆栈中不能显示出出错的行号，调试的时候也不能按照源代码来设置断点，</p></blockquote>

<p><img class="center" src="/images/2013/01/30/linenumbertable-attribute.png"><br/>
其中<code>attribute_name_index</code>上面已经提到过，表示常量池的索引，<code>attribute_length</code>表示属性长度，而<code>start_pc</code>和<code>line_number</code>分表表示字节码的行号和源代码的行号。本例中LineNumberTable属性的字节流如下图所示：
<img class="center" src="/images/2013/01/30/testclass-linenumbertable.png"><br/>
上面分析完了TestClass的第一个方法，通过同样的方式我们可以分析出TestClass的第二个方法，截图如下：<br/>
<img class="center" src="/images/2013/01/30/method-two.png">
其中<code>access_flags</code>为0x0001,<code>name_index</code>为0x000F,<code>descriptor_index</code>为0x0010，通过查看常量池可以知道此方法为<code>public int instanceMethod(int param)</code>方法。通过和上面类似的方法我们可以知道instanceMethod的Code属性为下图所示：<br/>
<img class="center" src="/images/2013/01/30/method-two-code-attribute.png"></p>

<p>最后我们来分析一下，Class文件的属性，从00000191h-00000199h为Class文件中的属性表，其中0x0011表示属性的名称，查看常量池可以知道属性名称为SourceFile，我们再来看看SourceFile的结构如下图所示：    <br/>
<img class="center" src="/images/2013/01/30/sourcefile-attribute.png"><br/>
其中<code>attribute_length</code>为属性的长度，<code>sourcefile_index</code>指向常量池中值为源代码文件名称的常量，在本例中SourceFile属性截图如下：
<img class="center" src="/images/2013/01/30/test-class-sourcefile.png"><br/>
其中<code>attribute_length</code>为0x00000002表示长度为2个字节，而<code>soucefile_index</code>的值为0x0012,查看常量池的第18个常量可以知道源代码文件的名称为TestClass.java</p>

<p>通过<a href="/blog/2013/01/30/java-class-file-format/"><code>实例分析Java Class文件的结构-理论篇</code></a>和<a href="/blog/2013/01/30/java-class-file-format-demo/"><code>实例分析Java Class文件的结构-实践篇</code></a>两篇文章，我们采用理论和实践结合方式来学习了Class 文件的格式。掌握它的格式以后，我们也可以试着写个Java Class类文件的反编译器了。</p>
]]></content>
  </entry>
  
</feed>
