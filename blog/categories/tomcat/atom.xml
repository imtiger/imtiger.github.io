<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tomcat | I'm Tiger,一个有理想爱折腾的程序员!]]></title>
  <link href="http://imtiger.github.io/blog/categories/tomcat/atom.xml" rel="self"/>
  <link href="http://imtiger.github.io/"/>
  <updated>2013-10-16T21:53:34+08:00</updated>
  <id>http://imtiger.github.io/</id>
  <author>
    <name><![CDATA[imtiger]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Tomcat总体结构（Tomcat源代码阅读系列之二）]]></title>
    <link href="http://imtiger.github.io/blog/2013/10/16/tomcat-architecture/"/>
    <updated>2013-10-16T14:33:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2013/10/16/tomcat-architecture</id>
    <content type="html"><![CDATA[<p>我们在<a href="/blog/2013/10/14/run-tomcat-in-idea-or-eclipse/">在IntelliJ IDEA 和 Eclipse运行tomcat 7源代码</a>一文中介绍了如何在intelliJ IDEA 和 Eclipse中运行Tomcat源代码，本文介绍一下Tomcat的总体结构。</p>

<blockquote><p>本文没有特别指明的地方，源代码都是针对tomcat7.0.42来说。</p></blockquote>

<h1>Tomcat的总体结构</h1>

<p>Tomcat即是一个Http服务器也是一个Servlet容器，它的总体结构我们可以用下图来描述：
<img class="center" src="/images/2013/10/16/TomcatArchitecture.png"></p>

<!-- more -->


<p>通过上图我们可以看出Tomcat中主要涉及Server,Service,Engine,Connector,Host,Context组件，之前用过Tomcat的童鞋是不是觉得这些组件的名称有点似曾相识的赶脚，没赶脚？！您再想想。好吧，不用你想了，我来告诉你吧。其实在Tomcat二进制分发包解压后,在conf目录中有一个server.xml文件，你打开它瞄两眼看看，是不是发现server.xml文件中已经包含了上述的几个名称。我拿我本地Tomcat7.0.42分发包中的server.xml来具体分析一下，它的内容如下：
```xml conf/server.xml(Tomcat 7.0.42)
&lt;?xml version=&lsquo;1.0&rsquo; encoding=&lsquo;utf-8&rsquo;?></p>

<!--
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->


<!-- Note:  A "Server" is not itself a "Container", so you may not
     define subcomponents such as "Valves" at this level.
     Documentation at /docs/config/server.html
 -->


<p><Server port="8005" shutdown="SHUTDOWN">
  <!-- Security listener. Documentation at /docs/config/listeners.html
  <Listener className="org.apache.catalina.security.SecurityListener" />
  &mdash;>
  <!--APR library loader. Documentation at /docs/apr.html -->
  <Listener className="org.apache.catalina.core.AprLifecycleListener" SSLEngine="on" />
  <!--Initialize Jasper prior to webapps are loaded. Documentation at /docs/jasper-howto.html -->
  <Listener className="org.apache.catalina.core.JasperListener" />
  <!-- Prevent memory leaks due to use of particular java/javax APIs-->
  <Listener className="org.apache.catalina.core.JreMemoryLeakPreventionListener" />
  <Listener className="org.apache.catalina.mbeans.GlobalResourcesLifecycleListener" />
  <Listener className="org.apache.catalina.core.ThreadLocalLeakPreventionListener" /></p>

<p>  &lt;!&mdash; Global JNDI resources</p>

<pre><code>   Documentation at /docs/jndi-resources-howto.html
</code></pre>

<p>  &mdash;>
  <GlobalNamingResources></p>

<pre><code>&lt;!-- Editable user database that can also be used by
     UserDatabaseRealm to authenticate users
--&gt;
&lt;Resource name="UserDatabase" auth="Container"
          type="org.apache.catalina.UserDatabase"
          description="User database that can be updated and saved"
          factory="org.apache.catalina.users.MemoryUserDatabaseFactory"
          pathname="conf/tomcat-users.xml" /&gt;
</code></pre>

<p>  </GlobalNamingResources></p>

<p>  &lt;!&mdash; A &ldquo;Service&rdquo; is a collection of one or more &ldquo;Connectors&rdquo; that share</p>

<pre><code>   a single "Container" Note:  A "Service" is not itself a "Container",
   so you may not define subcomponents such as "Valves" at this level.
   Documentation at /docs/config/service.html
</code></pre>

<p>   &mdash;>
  <Service name="Catalina"></p>

<pre><code>&lt;!--The connectors can use a shared executor, you can define one or more named thread pools--&gt;
&lt;!--
&lt;Executor name="tomcatThreadPool" namePrefix="catalina-exec-"
    maxThreads="150" minSpareThreads="4"/&gt;
--&gt;


&lt;!-- A "Connector" represents an endpoint by which requests are received
     and responses are returned. Documentation at :
     Java HTTP Connector: /docs/config/http.html (blocking &amp; non-blocking)
     Java AJP  Connector: /docs/config/ajp.html
     APR (HTTP/AJP) Connector: /docs/apr.html
     Define a non-SSL HTTP/1.1 Connector on port 8080
--&gt;
&lt;Connector port="8080" protocol="HTTP/1.1"
           connectionTimeout="20000"
           redirectPort="8443" /&gt;
&lt;!-- A "Connector" using the shared thread pool--&gt;
&lt;!--
&lt;Connector executor="tomcatThreadPool"
           port="8080" protocol="HTTP/1.1"
           connectionTimeout="20000"
           redirectPort="8443" /&gt;
--&gt;
&lt;!-- Define a SSL HTTP/1.1 Connector on port 8443
     This connector uses the JSSE configuration, when using APR, the
     connector should be using the OpenSSL style configuration
     described in the APR documentation --&gt;
&lt;!--
&lt;Connector port="8443" protocol="HTTP/1.1" SSLEnabled="true"
           maxThreads="150" scheme="https" secure="true"
           clientAuth="false" sslProtocol="TLS" /&gt;
--&gt;

&lt;!-- Define an AJP 1.3 Connector on port 8009 --&gt;
&lt;Connector port="8009" protocol="AJP/1.3" redirectPort="8443" /&gt;


&lt;!-- An Engine represents the entry point (within Catalina) that processes
     every request.  The Engine implementation for Tomcat stand alone
     analyzes the HTTP headers included with the request, and passes them
     on to the appropriate Host (virtual host).
     Documentation at /docs/config/engine.html --&gt;

&lt;!-- You should set jvmRoute to support load-balancing via AJP ie :
&lt;Engine name="Catalina" defaultHost="localhost" jvmRoute="jvm1"&gt;
--&gt;
&lt;Engine name="Catalina" defaultHost="localhost"&gt;

  &lt;!--For clustering, please take a look at documentation at:
      /docs/cluster-howto.html  (simple how to)
      /docs/config/cluster.html (reference documentation) --&gt;
  &lt;!--
  &lt;Cluster className="org.apache.catalina.ha.tcp.SimpleTcpCluster"/&gt;
  --&gt;

  &lt;!-- Use the LockOutRealm to prevent attempts to guess user passwords
       via a brute-force attack --&gt;
  &lt;Realm className="org.apache.catalina.realm.LockOutRealm"&gt;
    &lt;!-- This Realm uses the UserDatabase configured in the global JNDI
         resources under the key "UserDatabase".  Any edits
         that are performed against this UserDatabase are immediately
         available for use by the Realm.  --&gt;
    &lt;Realm className="org.apache.catalina.realm.UserDatabaseRealm"
           resourceName="UserDatabase"/&gt;
  &lt;/Realm&gt;

  &lt;Host name="localhost"  appBase="webapps"
        unpackWARs="true" autoDeploy="true"&gt;

    &lt;!-- SingleSignOn valve, share authentication between web applications
         Documentation at: /docs/config/valve.html --&gt;
    &lt;!--
    &lt;Valve className="org.apache.catalina.authenticator.SingleSignOn" /&gt;
    --&gt;

    &lt;!-- Access log processes all example.
         Documentation at: /docs/config/valve.html
         Note: The pattern used is equivalent to using pattern="common" --&gt;
    &lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"
           prefix="localhost_access_log." suffix=".txt"
           pattern="%h %l %u %t &amp;quot;%r&amp;quot; %s %b" /&gt;

  &lt;/Host&gt;
&lt;/Engine&gt;
</code></pre>

<p>  </Service>
</Server></p>

<p>```
接下来我们就根据上图以及conf/server.xml的内容来一步步描述一下上面所说的各种组件吧。</p>

<h2>Server</h2>

<p>首先闪联登场的是咋们的Server大哥（大家能给点掌声吗？），Server是Tomcat中最顶层的组件，它可以包含多个Service组件。在Tomcat源代码中Server组件对应源码中的<code>org.apache.catalina.core.StandardServer</code>类。StandardServer的继承关系图如下图所示：
<img class="center" src="/images/2013/10/16/StandardServer.jpg"></p>

<h2>Service</h2>

<p>接下来咋们来看看Service组件，Service组件相当于Connetor和Engine组件的包装器，它将一个或者多个Connector组件和一个Engine建立关联。缺省的的配置文件中，定义一个叫<code>Catalina</code>的服务，并将Http,AJP这两个Connector关联到了一个名为<code>Catalina</code>的Engine.Service组件对应Tomcat源代码中的<code>org.apache.catalina.core.StandardService</code>,StandardService的继承关系图如下图所示：
<img class="center" src="/images/2013/10/16/StandardService.png"></p>

<h2>Connector</h2>

<p>既然Tomcat需要提供http服务，而我们知道http应用层协议最终都是需要通过TCP层的协议进行包传递的，而Connector正是Tomcat中监听TCP网络连接的组件，一个Connector会监听一个独立的端口来处理来自客户端的连接。缺省的情况下Tomcat提供了如下两个Connector。我们分别描述一下：</p>

<ol>
<li>HTTP/1.1<br/>
<code>&lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt;</code>
上面定义了一个Connector，它缺省监听端口8080,这个端口我们可以根据具体情况进行改动。<code>connectionTimeout</code>定义了连接超时时间，单位是毫秒，<code>redirectPort</code>定义了ssl的重定向接口，根据缺省的配置，Connector会将ssl请求重定向到8443端口。</li>
<li>AJP/1.3<br/>
AJP表示<code>Apache Jserv Protocol</code>,此连接器将处理Tomcat和Aapache http服务器之间的交互，这个连机器是用来处理我们将Tomcat和Apache http服务器结合使用的情况。假如在同样的一台物理Server上面部署了一台Apache http服务器和多台Tomcat服务器，通过Apache服务器来处理静态资源以及负载均衡的时候，针对不同的Tomcat实例需要AJP监听不同的端口。</li>
</ol>


<p>Connector对应源代码中的<code>org.apache.catalina.connector.Connector</code>,它的继承关系图如下所示：
<img class="center" src="/images/2013/10/16/Connector.png"></p>

<h2>Engine</h2>

<p>Tomcat中有一个容器的概念，而Engine,Host,Context都属于Contanier，我们先来说说最顶层的容器Engine.<br/>
一个Engine可以包含一个或者多个Host,也就是说我们一个Tomcat的实例可以配置多个虚拟主机。<br/>
缺省的情况下<code>&lt;Engine name="Catalina" defaultHost="localhost"&gt;</code>定义了一个名称为Cataline的Engine.Engine对应源代码中的<code>org.apache.catalina.core.StandardEngine</code>，它的继承关系图如下图所示：
<img class="center" src="/images/2013/10/16/StandardEngine.png"></p>

<h2>Host</h2>

<p>Host定义了一个虚拟主机，一个虚拟主机可以有多个Context，缺省的配置如下：<br/>
<code>&lt;Host name="localhost"  appBase="webapps" unpackWARs="true" autoDeploy="true"&gt;….&lt;/Host&gt;</code> 其中<code>appBase</code>为webapps，也就是<code>&lt;CATALINA_HOME&gt;\webapps</code>目录，<code>unpackingWARS</code>属性指定在appBase指定的目录中的war包都自动的解压，缺省配置为true,<code>autoDeploy</code>属性指定是否对加入到appBase目录的war包进行自动的部署，缺省为true.<br/>
Host对应源代码中的<code>org.apache.catalina.core.StandardHost</code>,它的继承关系图如下所示：
<img class="center" src="/images/2013/10/16/StandardHost.png"></p>

<h2>Context</h2>

<p>在Tomcat中，每一个运行的webapp其实最终都是以Context的形成存在，每个Context都有一个根路径和请求URL路径，Context对应源代码中的<code>org.apache.catalina.core.StandardContext</code>,它的继承关系图如下图所示：
<img class="center" src="/images/2013/10/16/StandardContext.png">
在Tomcat中我们通常采用如下的两种方式创建一个Context.下面分别描述一下：</p>

<ol>
<li>在<code>&lt;CATALINA-HOME&gt;\webapps</code>目录中创建一个目录，这个时候将自动创建一个context，默认context的访问url为<code>http://host:port/dirname</code>,你也可以通过在<code>ContextRoot\META-INF</code>中创建一个context.xml的文件，其中包含如下的内容来指定应用的访问路径。
<code>&lt;Context path="/yourUrlPath" /&gt;</code></li>
<li>conf\server.xml文件中增加context元素。
第二种创建context的方法，我们可以选择在server.xml文件的<code>&lt;Host&gt;</code>元素，比如我们在server.xml文件中增加如下内容：
<code>xml server.xml
     ......
     ......
     &lt;Context path="/mypath" docBase="/Users/tiger/develop/xxx" reloadable="true"&gt;
     &lt;/Context&gt;
   &lt;/Host&gt;
 &lt;/Engine&gt;
&lt;/Service&gt;
&lt;/Server&gt;
</code>
这样的话，我们就可以通过<code>http://host:port/mypath</code>访问上面配置的context了。</li>
</ol>


<h2>Valve</h2>

<p>Valve中文意思是阀门，Valve是Tomcat中责任链模式的实现，通过链接多个Valve对请求进行处理。其中Valve可以定义在任何的Container中，上面说的Engine,Host,Context都属于容器。tomcat 默认定义了一个名为<code>org.apache.catalina.valves.AccessLogValve</code>的Valve,这个Valve负责拦截每个请求，然后记录一条访问日志。</p>

<p>通过上面的分析，我们发现Server,Service,Engine,Host,Context都实现了<code>org.apache.catalina.Lifecycle</code>接口，通过这个接口管理了这些核心组件的生命周期，关于这些组件的生命周期，我们在下一篇文章描述。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在IntelliJ IDEA 和 Eclipse运行tomcat 7源代码（Tomcat源代码阅读系列之一）]]></title>
    <link href="http://imtiger.github.io/blog/2013/10/14/run-tomcat-in-idea-or-eclipse/"/>
    <updated>2013-10-14T14:39:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2013/10/14/run-tomcat-in-idea-or-eclipse</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/10/14/apache_tomcat_bag.jpg">
在阅读Tomcat源代码之前，我们首先需要将Tomcat的源代码在IDE里面运行起来，这样方便我们阅读的过程中调试。本文总结一下在IDEA 或者 Eclipse中运行Tomcat源代码环境的搭建过程，同时我们通过Maven来负责项目的构建。</p>

<p>在进行搭建之前，我们首先来说一下总体的思路。我们知道Tomcat运行的时候，一部分是源代码编译以后的可运行的Jar,另外一部分则是运行时的环境（也就是我们从官方下载下来的二进制分发包中的一系列的配置文件以及目录结构，说的更直白点就是CATALINA_HOME环境变量指定的目录）,本文对于第一部分采用IntelliJ IDEA 运行tomcat-7.0.42 tag的源代码，而对于第二部分运行环境，我们则直接采用tomcat-7.0.42的二进制分发包。明白了上述的思路以后，咋们就来一步步的搭建吧。</p>

<!-- more -->


<p>首先咋们来看看搭建完成以后的总体的目录结构，然后再一步步的去分解搭建过程。笔者搭建完以后，最终的运行结构如下图所示：
<img class="center" src="/images/2013/10/14/project-structure.png"></p>

<p>下面分别解释一下上图工程结构中涉及到的文件和目录：</p>

<ol>
<li>.idea和tomcat-study.iml是IntelliJ IDEA的文件，如果你用Eclipse的话不会存在这两个东东 。</li>
<li>catalina-home是从官方下载的7.0.42的二进制分发包解压后的目录</li>
<li>target是Maven编译项目以后生成的文件夹，熟悉Maven的读者应该很熟悉此目录</li>
<li>tomcat-7.0.42-sourcecode是从Tomcat<a href="http://svn.apache.org/repos/asf/tomcat/tc7.0.x/tags/TOMCAT_7_0_42/">官方仓库</a>下载的tags的源代码</li>
<li>pom.xml是Maven的配置文件,此工程中有两个pom.xml，这里运用了Maven聚合的特性。</li>
</ol>


<p>了解了最终的结构以后，咋们就来一步步的搭建它吧。</p>

<h3>第一步 创建项目目录结构</h3>

<p>本文假设我们将项目放在<code>~/develop/java</code>目录中。
<code>bash create project structure
cd ~/develop/java
mkdir Tomcat
cd Tomcat
touch pom.xml
</code></p>

<h3>第二步 下载Tomcat 7.0.42二进制分发包</h3>

<p>我们通过apache-tomcat-7.0.42的<a href="http://mirrors.hust.edu.cn/apache/tomcat/tomcat-7/v7.0.42/bin/apache-tomcat-7.0.42.tar.gz">官方地址</a>下载它。具体的过程如下：
<code>bash download apache-tomcat-7.0.42 binary distribution
cd ~/develop/java/Tomcat
wget http://mirrors.hust.edu.cn/apache/tomcat/tomcat-7/v7.0.42/bin/apache-tomcat-7.0.42.tar.gz
tar -zxvf apache-tomcat-7.0.42.tar.gz
rm apache-tomcat-7.0.42.tar.gz
mv apache-tomcat-7.0.42 catalina-home
</code></p>

<h3>第三步 下载Tomcat 7.0.42 源代码</h3>

<p>接下来我们从Tomcat的<a href="http://svn.apache.org/repos/asf/tomcat/tc7.0.x/tags/TOMCAT_7_0_42/">官方SVN仓库</a>下载Tomcat 7.0.42源代码，具体的步骤如下：
<code>bash download Tomcat 7.0.42 source code
cd ~/develop/java/Tomcat
svn co http://svn.apache.org/repos/asf/tomcat/tc7.0.x/tags/TOMCAT_7_0_42/  tomcat-7.0.42-sourcecode
</code>
在这一步中，我们将7.0.42的源代码迁入到了tomcat-7.0.42-sourcecode目录中。</p>

<h3>第四步 创建聚合模块pom.xml</h3>

<p>因为我们通过maven来对项目进行构建，这就需要我们来创建一个pom.xml文件，具体过程如下：
<code>bash create aggregation child project pom.xml
cd ~/develop/java/Tomcat/tomcat-7.0.42-sourcecode
touch pom.xml
</code>
用你喜欢的编辑器打开pom.xml然后用下面的内容替换它的内容：</p>

<p>```xml pom.xml
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
&lt;project xmlns=&ldquo;<a href="http://maven.apache.org/POM/4.0.0">http://maven.apache.org/POM/4.0.0</a>&rdquo;</p>

<pre><code>     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;


&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
&lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;
&lt;artifactId&gt;Tomcat7.0&lt;/artifactId&gt;
&lt;name&gt;Tomcat7.0&lt;/name&gt;
&lt;version&gt;7.0&lt;/version&gt;

&lt;build&gt;
    &lt;finalName&gt;Tomcat7.0&lt;/finalName&gt;
    &lt;sourceDirectory&gt;java&lt;/sourceDirectory&gt;
    &lt;testSourceDirectory&gt;test&lt;/testSourceDirectory&gt;
    &lt;resources&gt;
        &lt;resource&gt;
            &lt;directory&gt;java&lt;/directory&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
    &lt;testResources&gt;
        &lt;testResource&gt;
            &lt;directory&gt;test&lt;/directory&gt;
        &lt;/testResource&gt;
    &lt;/testResources&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
            &lt;version&gt;2.3&lt;/version&gt;

            &lt;configuration&gt;
                &lt;encoding&gt;UTF-8&lt;/encoding&gt;
                &lt;source&gt;1.6&lt;/source&gt;
                &lt;target&gt;1.6&lt;/target&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.4&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;ant&lt;/groupId&gt;
        &lt;artifactId&gt;ant&lt;/artifactId&gt;
        &lt;version&gt;1.7.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;wsdl4j&lt;/groupId&gt;
        &lt;artifactId&gt;wsdl4j&lt;/artifactId&gt;
        &lt;version&gt;1.6.2&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.xml&lt;/groupId&gt;
        &lt;artifactId&gt;jaxrpc&lt;/artifactId&gt;
        &lt;version&gt;1.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.eclipse.jdt.core.compiler&lt;/groupId&gt;
        &lt;artifactId&gt;ecj&lt;/artifactId&gt;
        &lt;version&gt;4.2.2&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>

<p></project></p>

<p>```
对于pom.xml文件我们需要注意以下几点：</p>

<ol>
<li>因为下载代码不符合Maven默认的目录结构约定，因此需要修改<code>resources</code>和<code>testResources</code>为<code>java</code>和 <code>test</code>，而不是默认的<code>src/main/resource</code>和<code>src/test/resource</code>,修改<code>sourceDirectory</code>和<code>testSourceDirectory</code>为，<code>java</code>和<code>test</code>,而不是默认的<code>src/main/java</code>和<code>src/test/java</code>.</li>
<li>因为Tomcat源代码的编译需要wsdl4j，jaxrpc,ecj等jar包，因此需要增加相关的依赖。</li>
</ol>


<h3>第五步 创建项目的根pom.xml文件</h3>

<p>这一步我么在Tomcat目录中创建pom.xml文件，这里采用了Maven中聚合的概念.具体过程如下：
<code>bash create root pom.xml
cd ~/develop/java/Tomcat
touch pom.xml
</code>
用你喜欢的编辑器打开刚创建的空的pom.xml文件，修改它的内容如下：
```xml ~/develop/java/Tomcat/pom.xml
&lt;project xmlns=&ldquo;<a href="http://maven.apache.org/POM/4.0.0">http://maven.apache.org/POM/4.0.0</a>&rdquo; xmlns:xsi=&ldquo;<a href="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</a>&rdquo;</p>

<pre><code>     xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt;

&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
&lt;groupId&gt;net.imtiger&lt;/groupId&gt;
&lt;artifactId&gt;tomcat-study&lt;/artifactId&gt;
&lt;name&gt;Tomcat 7.0 Study&lt;/name&gt;
&lt;version&gt;1.0&lt;/version&gt;
&lt;packaging&gt;pom&lt;/packaging&gt;

&lt;modules&gt;
    &lt;module&gt;tomcat-7.0.42-sourcecode&lt;/module&gt;
&lt;/modules&gt;
</code></pre>

<p></project>
```</p>

<h3>第六步 用IntelliJ IDEA 打开项目根目录的pom.xml</h3>

<p>这一步需要注意，要用IDEA 打开项目根目录的pom.xml文件（也就是~/develop/java/Tomcat/pom.xml）</p>

<h3>第七步 运行Tomcat</h3>

<p>终于到激动人心的时刻了,我们知道任何Java程序都会有一个<code>public static void main(String… args)</code>的入口，Tomcat本身是用Java写的，因此它也不例外，对于Tomcat来说，入口类是<code>org.apache.catalina.startup.Bootstrap</code>,我们找到这个类，然后在IntelliJ IDEA中创建一个运行配置，其中最主要的就是VM options的配置了，在VM options里面填写如下的参数：</p>

<p><code>java VM options
-Dcatalina.home=catalina-home -Dcatalina.base=catalina-home
-Djava.endorsed.dirs=catalina-home/endorsed -Djava.io.tmpdir=catalina-home/temp
-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager
-Djava.util.logging.config.file=catalina-home/conf/logging.properties
</code>
配置好后，IntelliJ IDEA的配置界面如下：
<img class="center" src="/images/2013/10/14/vm-options.png"></p>

<p>点击运行，即可看到Tomcat已经启动了，日志已经打到了IntelliJ IDEA的控制台上了，这个时候可以启动浏览器输入<a href="http://127.0.0.1:8080">http://127.0.0.1:8080</a>看看是否启动成功。</p>

<p>接下来，咋们在Bootstrap的main方法中，增加一句<code>System.out.println("Have fun and Enjoy!");</code>,然后运行一下，看看加入的信息是否被打入到了控制台，在笔者的电脑上打印可以看到信息已经输出如下信息：
<code>java console log
Have fun and Enjoy!
//ignore other log info
2013-10-14 17:19:35 org.apache.catalina.startup.Catalina start
信息: Server startup in 908 ms
</code>
上面就是Tomcat7.0.42源代码在IntelliJ IDEA运行环境搭建的完整的过程。因为笔者日常开发采用的是IntelliJ IDEA,所以本文就只写了IntelliJ IDEA的搭建，但是本文采用了Maven来进行构建的，理论上来说其它IDE，比如Eclipse，只要支持Maven,则可以采用本文同样的方法进行，用Eclipse开发的童鞋，按照本文的步骤理论上也是可以运行起来的。</p>

<p>最后，列出几个笔者在搭建的过程中遇到的几个小问题。</p>

<ol>
<li><code>org.apache.catalina.connector.TestRequest</code>类的<code>prepareRequestBug54984</code>中有两个特殊字符<code>äö</code>,在SVN 迁出的时候变为了乱码，导致Maven在编译的时候编译不过，大家可以复制<code>äö</code>替换乱码的字符即可。</li>
<li><code>CompilationUnit</code>类中的<code>public boolean ignoreOptionalProblems()</code>方法被标记为了@Override，但是其实现的接口<code>ICompilationUnit</code>属于<code>org.eclipse.jdt.core.compiler:ecj</code>，而3.x版本的<code>ICompilationUnit</code>中没有<code>ignoreOptionalProblems</code>方法，4.x的版本中才有，因此为了编译通过，本文采用了4.2.2版本。</li>
</ol>


<p>另外本文最终搭建好的环境，我已经放在Github上了，不想搭建的童鞋可以直接clone一份使用。<a href="https://github.com/imtiger/Tomcat">Github仓库地址</a></p>
]]></content>
  </entry>
  
</feed>
