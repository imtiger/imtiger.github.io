<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | I'm Tiger,一个热爱生活和技术的创业者!]]></title>
  <link href="http://imtiger.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://imtiger.github.io/"/>
  <updated>2013-10-08T13:39:45+08:00</updated>
  <id>http://imtiger.github.io/</id>
  <author>
    <name><![CDATA[imtiger]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[实例分析Java Class文件的结构-实践篇]]></title>
    <link href="http://imtiger.github.io/blog/2013/01/30/java-class-file-format-demo/"/>
    <updated>2013-01-30T12:16:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2013/01/30/java-class-file-format-demo</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/01/30/java-logo.jpg" width="500" height="300"><br/>
在<a href="/blog/2013/01/30/java-class-file-format/"><code>实例分析Java Class文件的结构-理论篇</code></a>一文中，我们说了Java Class文件结构的理论知识，接下来我们来通过一个具体的例子来理论结合实践的学习一下。
首先我们有一个TestClass类，代码如下：
```java TestClass.java</p>

<pre><code> package com.ejushang.TestClass;
 public class TestClass implements Super{

         private static final int staticVar = 0;

         private int instanceVar=0;

         public int instanceMethod(int param){
             return param+1;
         }

 }

 interface Super{ }
</code></pre>

<p>```</p>

<p>通过jdk1.6.0_37的javac 编译后的TestClass.java对应的TestClass.class的二进制结构如下图所示：</p>

<!-- more -->


<p><img class="center" src="/images/2013/01/30/test-class-file.png"></p>

<ol>
<li><p>魔数<br/>
从Class的文件结构我们知道，刚开始的4个字节是魔数，上图中从地址00000000h-00000003h的内容就是魔数，从上图可知Class的文件的魔数是0xCAFEBABE。</p></li>
<li><p>主次版本号 <br/>
接下来的4个字节是主次版本号，由上图可知从00000004h-00000005h对应的是0x0000,因此Class的minor_version为0x0000,从00000006h-00000007h对应的内容为0x0032,因此Class文件的major_version版本为0x0032,这正好就是jdk1.6.0不带target参数编译后的Class对应的主次版本。</p></li>
<li><p>常量池的数量 <br/>
接下来的2个字节从00000008h-00000009h表示常量池的数量，由上图可以知道其值为0x0018，十进制为24个,但是对于常量池的数量需要明确一点，常量池的数量是constant_pool_count-1，为什么减一，是因为索引0表示class中的数据项不引用任何常量池中的常量。</p></li>
<li><p>常量池
我们上面说了常量池中有不同类型的常量，下面就来看看TestClass.class的第一个常量，我们知道每个常量都有一个u1类型的tag标识来表示常量的类型，上图中0000000ah处的内容为0x0A，转换成二级制是10，由上面的关于常量类型的描述可知tag为10的常量是Constant_Methodref_info,而Constant_Methodref_info的结够如下图所示：
<img class="center" src="/images/2013/01/30/constant-methodref-info.png"> <br/>
<code>class_index</code>指向常量池中类型为CONSTANT_Class_info的常量，从TestClass的二进制文件结构中可以看出class_index的值为0x0004（地址为0000000bh-0000000ch)，也就是说指向第四个常量。 <br/>
<code>name_and_type_index</code>指向常量池中类型为CONSTANT_NameAndType_info常量。从上图可以看出name_and_type_index的值为0x0013，表示指向常量池中的第19个常量.接下来又可以通过同样的方法来找到常量池中的所有常量。不过JDK提供了一个方便的工具可以让我们查看常量池中所包含的常量。通过javap -verbose TestClass 即可得到所有常量池中的常量，截图如下：<br/>
<img class="center" src="/images/2013/01/30/test-class-javap.png"> <br/>
从上图我们可以清楚的看到，TestClass中常量池有24个常量，不要忘记了第0个常量，因为第0个常量被用来表示 Class中的数据项不引用任何常量池中的常量。从上面的分析中我们得知TestClass的第一个常量表示方法，其中class_index指向的第四个常量为java/lang/Object，name_and_type_index指向的第19个常量值为<init>:()V,从这里可以看出第一个表示方法的常量表示的是java编译器生成的实例构造器方法。通过同样的方法可以分析常量池的其它常量。OK，分析完常量池，我们接下来再分析下access_flags。</p></li>
<li>u2 access_flags
表示类或者接口方面的访问信息，比如Class表示的是类还是接口，是否为public,static，final等。具体访问标示的含义之前已经说过了，下面我们就来看看TestClass的访问标示。Class的访问标示是从0000010dh-0000010e，其值为0x0021，根据前面说的各种访问标示的标志位，我们可以知道：0x0021=0x0001|0x0020 也即ACC_PUBLIC 和 ACC_SUPER为真，其中ACC_PUBLIC大家好理解，ACC_SUPER是jdk1.2之后编译的类都会带有的标志。</li>
<li><p>u2 this_class <br/>
表示类的索引值，用来表示类的全限定名称，类的索引值如下图所示：<br/>
<img class="center" src="/images/2013/01/30/class-index.png"><br/>
从上图可以清楚到看到，类索引值为0x0003，对应常量池的第三个常量，通过javap的结果，我们知道第三个常量为CONSTANT_Class_info类型的常量，通过它可以知道类的全限定名称为：com/ejushang/TestClass/TestClass</p></li>
<li><p>u2 super_class <br/>
表示当前类的父类的索引值，索引值指向常量池中类型为CONSTANT_Class_info的常量，父类的索引值如下图所示，其值为0x0004,查看常量池的第四个常量，可知TestClass的父类的全限定名称为：java/lang/Object.
<img class="center" src="/images/2013/01/30/super-class.png"></p></li>
<li><p>interfaces_count 、 interfaces[interfaces_count]<br/>
表示接口数量以及具体的每一个接口，TestClass的接口数量以及接口如下图所示，其中0x0001表示接口数量为1，而0x0005表示接口在常量池的索引值，找到常量池的第五个常量，其类型为CONSTANT_Class_info，其值为：com/ejushang/TestClass/Super
<img class="center" src="/images/2013/01/30/interface-count.png"></p></li>
<li><p>fields_count、field_info <br/>
fields_count表示类中field_info表的数量，而field_info表示类的实例变量和类变量，这里需要注意的是field_info不包含从父类继承过来的字段，field_info的结构如下图所示：<br/>
<img class="center" src="/images/2013/01/30/field-info.png"><br/>
<code>access_flags</code>表示字段的访问标识，比如public,private,protected，static,final等，access_flags的取值如下图所示：<br/>
<img class="center" src="/images/2013/01/30/access-flags.png"><br/>
<code>name_index</code> 和 <code>descriptor_index</code>都是常量池的索引值，分别表示字段的名称和字段的描述符，字段的名称容易理解，但是字段的描述符如何理解呢？其实在JVM 规范中，对于字段的描述符规定如下图所示：<br/>
<img class="center" src="/images/2013/01/30/field-descriptor.png"><br/>
其中大家需要关注一下上图最后一行，它表示的是对一维数组的描述符，对于String[][]的描述符将是[[ Ljava/lang/String,而对于int[][]的描述符为[[I。接下来的attributes_count以及attribute_info分别表示属性表的数量以及属性表。<br/>
下面我们还是以上面的TestClass为例，来看看TestClass的字段表吧。首先我们来看一下字段的数量，TestClass的字段的数量如下图所示：<br/>
<img class="center" src="/images/2013/01/30/testclass-field-count.png"><br/>
从上图中可以看出TestClass有两个字段，查看TestClass的源代码可知，确实也只有两个字段，接下来我们看看第一个字段，我们知道第一个字段应该为private int staticVar,它在Class文件中的二进制表示如下图所示：<br/>
<img class="center" src="/images/2013/01/30/field-one.png"><br/>
其中0x001A表示访问标示，通过查看access_flags表可知，其为ACC_PRIVATE,ACC_STATIC,ACC_FINAL,接下来0x0006和0x0007分别表示常量池中第6和第7个常量，通过查看常量池可知，其值分别为：staticVar和I，其中staticVar为字段名称，而I为字段的描述符，通过上面对描述符的解释，I所描述的是int类型的变量，接下来0x0001表示staticVar这个字段表中的属性表的数量，从上图可以staticVar字段对应的属性表有1个，0x0008表示常量池中的第8个常量，查看常量池可以得知此属性为ConstantValue属性，而ConstantValue属性的格式如下图所示：<br/>
<img class="center" src="/images/2013/01/30/constantvalue-attribute.png"><br/>
其中<code>attribute_name_index</code>表述属性名的常量池索引，本例中为ConstantValue，而ConstantValue的<code>attribute_length</code>固定长度为2，而<code>constantValue_index</code>表示常量池中的引用，本例中，其中为0x0009，查看第9个常量可以知道，它表示一个类型为CONSTANT_Integer_info的常量，其值为0。<br/>
上面说完了<code>private static final int staticVar=0</code>，下面我们接着说一下TestClass的<code>private int instanceVar=0</code>,在本例中对instanceVar的二进制表示如下图所示：
<img class="center" src="/images/2013/01/30/field-two.png"><br/>
其中0x0002表示访问标示为ACC_PRIVATE,0x000A表示字段的名称，它指向常量池中的第10个常量，查看常量池可以知道字段名称为instanceVar，而0x0007表示字段的描述符，它指向常量池中的第7个常量，查看常量池可以知道第7个常量为I，表示类型为instanceVar的类型为I，最后0x0000表示属性表的数量为0.</p></li>
<li>methods_count 、method_info <br/>
methods_count表示方法的数量，而method_info表示的方法表，其中方法表的结构如下图所示：<br/>
<img class="center" src="/images/2013/01/30/method-info.png">  <br/>
从上图可以看出method_info和field_info的结构是很类似的，方法表的access_flag的所有标志位以及取值如下图所示：<br/>
<img class="center" src="/images/2013/01/30/access-flags.png">  <br/>
其中<code>name_index</code>和<code>descriptor_index</code>表示的是方法的名称和描述符，他们分别是指向常量池的索引。这里需要结解释一下方法的描述符，方法的描述符的结构为：<code>（参数列表）返回值</code>，比如<code>public int instanceMethod(int param)</code>的描述符为：<code>（I）I</code>，表示带有一个int类型参数且返回值也为int类型的方法，接下来就是属性数量以及属性表了，方法表和字段表虽然都有属性数量和属性表，但是他们里面所包含的属性是不同。接下来我们就以TestClass来看一下方法表的二进制表示。首先来看一下方法表数量，截图如下：
<img class="center" src="/images/2013/01/30/method-count.png"><br/>
从上图可以看出方法表的数量为0x0002表示有两个方法，接下来我们来分析第一个方法，我们首先来看一下TestClass的第一个方法的<code>access_flag</code>，<code>name_index</code>,<code>descriptor_index</code>，截图如下：<br/>
<img class="center" src="/images/2013/01/30/method-one-info.png"><br/>
从上图可以知道access_flags为0x0001，从上面对access_flags标志位的描述，可知方法的access_flags的取值为ACC_PUBLIC,name_index为0x000B，查看常量池中的第11个常量，知道方法的名称为<init>，0x000C表示descriptor_index表示常量池中的第12常量，其值为()V,表示<init>方法没有参数和返回值，其实这是编译器自动生成的实例构造器方法。接下来的0x0001表示<init>方法的方法表有1个属性，属性截图如下：
<img class="center" src="/images/2013/01/30/init-method-info.png"> <br/>
从上图可以看出0x000D对应的常量池中的常量为Code,表示的方法的Code属性，所以到这里大家应该明白方法的那些代码是存储在Class文件方法表中的属性表中的Code属性中。接下来我们在分析一下Code属性，Code属性的结构如下图所示：
<img class="center" src="/images/2013/01/30/code-attribute.png"><br/>
其中<code>attribute_name_index</code>指向常量池中值为Code的常量，<code>attribute_length</code>的长度表示Code属性表的长度（这里需要注意的时候长度不包括attribute_name_index和attribute_length的6个字节的长度）。<br/>
<code>max_stack</code>表示最大栈深度，虚拟机在运行时根据这个值来分配栈帧中操作数的深度.<br/>
<code>max_locals</code>代表了局部变量表的存储空间,它的单位为slot，slot是虚拟机为局部变量分配内存的最小单元，在运行时，对于不超过32位类型的数据类型，比如byte,char,int等占用1个slot，而double和Long这种64位的数据类型则需要分配2个slot，另外max_locals的值并不是所有局部变量所需要的内存数量之和，因为slot是可以重用的，当局部变量超过了它的作用域以后，局部变量所占用的slot就会被重用。 <br/>
<code>code_length</code>代表了字节码指令的数量，而code表示的时候字节码指令，从上图可以知道code的类型为u1,一个u1类型的取值为0x00-0xFF,对应的十进制为0-255，目前虚拟机规范已经定义了200多条指令。<br/>
<code>exception_table_length</code>以及<code>exception_table</code>分别代表方法对应的异常信息。<br/>
<code>attributes_count</code>和<code>attribute_info</code>分别表示了Code属性中的属性数量和属性表，从这里可以看出Class的文件结构中，属性表是很灵活的，它可以存在于Class文件，方法表，字段表以及Code属性中。
接下来我们继续以上面的例子来分析一下，从上面init方法的Code属性的截图中可以看出，属性表的长度为0x00000026,max_stack的值为0x0002,max_locals的取值为0x0001,code_length的长度为0x0000000A，那么00000149h-00000152h为字节码，接下来exception_table_length的长度为0x0000，而attribute_count的值为0x0001，00000157h-00000158h的值为0x000E,它表示常量池中属性的名称，查看常量池得知第14个常量的值为LineNumberTable，LineNumberTable用于描述java源代码的行号和字节码行号的对应关系，它不是运行时必需的属性,接下来我们再看一下LineNumberTable的结构如下图所示：</li>
</ol>


<blockquote><p>如果通过-g:none的编译器参数来取消生成LineNumberTable的话，最大的影响就是异常发生的时候，堆栈中不能显示出出错的行号，调试的时候也不能按照源代码来设置断点，</p></blockquote>

<p><img class="center" src="/images/2013/01/30/linenumbertable-attribute.png"><br/>
其中<code>attribute_name_index</code>上面已经提到过，表示常量池的索引，<code>attribute_length</code>表示属性长度，而<code>start_pc</code>和<code>line_number</code>分表表示字节码的行号和源代码的行号。本例中LineNumberTable属性的字节流如下图所示：
<img class="center" src="/images/2013/01/30/testclass-linenumbertable.png"><br/>
上面分析完了TestClass的第一个方法，通过同样的方式我们可以分析出TestClass的第二个方法，截图如下：<br/>
<img class="center" src="/images/2013/01/30/method-two.png">
其中<code>access_flags</code>为0x0001,<code>name_index</code>为0x000F,<code>descriptor_index</code>为0x0010，通过查看常量池可以知道此方法为<code>public int instanceMethod(int param)</code>方法。通过和上面类似的方法我们可以知道instanceMethod的Code属性为下图所示：<br/>
<img class="center" src="/images/2013/01/30/method-two-code-attribute.png"></p>

<p>最后我们来分析一下，Class文件的属性，从00000191h-00000199h为Class文件中的属性表，其中0x0011表示属性的名称，查看常量池可以知道属性名称为SourceFile，我们再来看看SourceFile的结构如下图所示：    <br/>
<img class="center" src="/images/2013/01/30/sourcefile-attribute.png"><br/>
其中<code>attribute_length</code>为属性的长度，<code>sourcefile_index</code>指向常量池中值为源代码文件名称的常量，在本例中SourceFile属性截图如下：
<img class="center" src="/images/2013/01/30/test-class-sourcefile.png"><br/>
其中<code>attribute_length</code>为0x00000002表示长度为2个字节，而<code>soucefile_index</code>的值为0x0012,查看常量池的第18个常量可以知道源代码文件的名称为TestClass.java</p>

<p>通过<a href="/blog/2013/01/30/java-class-file-format/"><code>实例分析Java Class文件的结构-理论篇</code></a>和<a href="/blog/2013/01/30/java-class-file-format-demo/"><code>实例分析Java Class文件的结构-实践篇</code></a>两篇文章，我们采用理论和实践结合方式来学习了Class 文件的格式。掌握它的格式以后，我们也可以试着写个Java Class类文件的反编译器了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实例分析Java Class文件的结构-理论篇]]></title>
    <link href="http://imtiger.github.io/blog/2013/01/30/java-class-file-format/"/>
    <updated>2013-01-30T10:33:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2013/01/30/java-class-file-format</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/01/30/java-logo.jpg" width="500" height="300">  <br/>
今天把之前在Evernote中的笔记重新整理了一下，发上来供对java class 文件结构的有兴趣的同学参考一下。</p>

<p>学习Java的朋友应该都知道Java从刚开始的时候就打着平台无关性的旗号，说“一次编写，到处运行”，其实说到无关性，Java平台还有另外一个无关性那就是语言无关性，要实现语言无关性，那么Java体系中的class的文件结构或者说是字节码就显得相当重要了，其实Java从刚开始的时候就有两套规范，一个是Java语言规范，另外一个是Java虚拟机规范，Java语言规范只是规定了Java语言相关的约束以及规则，而虚拟机规范则才是真正从跨平台的角度去设计的。今天我们就以一个实际的例子来看看，到底Java中一个Class文件对应的字节码应该是什么样子。 这篇文章将首先总体上阐述一下Class到底由哪些内容构成，然后再用一个实际的Java类入手去分析class的文件结构。</p>

<!-- more -->


<p></p>

<p>在继续之前，我们首先需要明确如下几点：<br/>
1. Class文件是有8位为基础的字节流构成的，这些字节流之间都严格按照规定的顺序排列，并且字节之间不存在任何空隙，对于超过8位的数据，将按照Big-Endian的顺序存储的，也就是说高位字节存储在低的地址上面，而低位字节存储到高地址上面，其实这也是class文件要跨平台的关键，因为PowerPC架构的处理采用Big-Endian的存储顺序，而x86系列的处理器则采用Little-Endian的存储顺序，因此为了Class文件在各中处理器架构下保持统一的存储顺序，虚拟机规范必须对起进行统一。    <br/>
2. Class文件结构采用类似C语言的结构体来存储数据的，主要有两类数据项，无符号数和表，无符号数用来表述数字，索引引用以及字符串等，比如u1,u2,u4,u8分别代表1个字节，2个字节，4个字节，8个字节的无符号数，而表是有多个无符号数以及其它的表组成的复合结构。可能大家看到这里对无符号数和表到底是上面也不是很清楚，不过不要紧，等下面实例的时候，我会再以实例来解释。</p>

<p>明确了上面的两点以后，我们接下来后来看看Class文件中按照严格的顺序排列的字节流都具体包含些什么数据：<br/>
<img class="center" src="/images/2013/01/30/java-class-file-format.png"></p>

<p>  <center>（上图来自The Java Virtual Machine Specification Java SE 7 Edition) </center></p>

<p>在看上图的时候，有一点我们需要注意，比如cp_info，cp_info表示常量池，上图中用constant_pool[constant_pool_count-1]的方式来表示常量池有constant_pool_count-1个常量，它这里是采用数组的表现形式，但是大家不要误以为所有的常量池的常量长度都是一样的，其实这个地方只是为了方便描述采用了数组的方式，但是这里并不像编程语言那里，一个int型的数组，每个int长度都一样.明确了这一点以后，我们再回过头来看看上图中每一项都具体代表了什么含义。</p>

<ol>
<li>u4 magic 表示魔数，并且魔数占用了4个字节，魔数到底是做什么的呢？它其实就是表示一下这个文件的类型是一个Class文件，而不是一张JPG图片，或者AVI的电影。而Class文件对应的魔数是0xCAFEBABE.</li>
<li>u2 minor_version 表示Class文件的次版本号，并且此版本号是u2类型的无符号数表示。</li>
<li>u2 major_version 表示Class文件的主版本号，并且主版本号是u2类型的无符号数表示。major_version和minor_version主要用来表示当前的虚拟机是否接受当前这种版本的Class文件。不同版本的Java编译器编译的Class文件对应的版本是不一样的。高版本的虚拟机支持低版本的编译器编译的Class文件结构。比如Java SE 6.0对应的虚拟机支持Java SE 5.0的编译器编译的Class文件结构，反之则不行。</li>
<li>u2 constant_pool_count 表示常量池的数量。这里我们需要重点来说一下常量池是什么东西，请大家不要与Jvm内存模型中的运行时常量池混淆了，Class文件中常量池主要存储了字面量以及符号引用，其中字面量主要包括字符串，final常量的值或者某个属性的初始值等等，而符号引用主要存储类和接口的全限定名称，字段的名称以及描述符，方法的名称以及描述符，这里名称可能大家都容易理解，至于描述符的概念，放到下面说字段表以及方法表的时候再说。另外大家都知道Jvm的内存模型中有堆，栈，方法区，程序计数器构成，而方法区中又存在一块区域叫运行时常量池，运行时常量池中存放的东西其实也就是编译器产生的各种字面量以及符号引用，只不过运行时常量池具有动态性，它可以在运行的时候向其中增加其它的常量进去，最具代表性的就是String的intern方法。</li>
<li>cp_info 表示常量池，这里面就存储了上面说的各种各样的字面量和符号引用。放到常量池的中数据项在<code>The Java Virtual Machine Specification Java SE 7 Edition</code> 中一共有14个常量，每一种常量都是一个表，并且每种常量都用一个公共的部分tag来表示是哪种类型的常量。下面分别简单描述一下,具体细节等到后面的实例中我们再细化。 <br/>
CONSTANT_Utf8_info      tag标志位为1,   UTF-8编码的字符串  <br/>
CONSTANT_Integer_info  tag标志位为3， 整形字面量       <br/>
CONSTANT_Float_info     tag标志位为4， 浮点型字面量    <br/>
CONSTANT_Long_info     tag标志位为5， 长整形字面量 <br/>
CONSTANT_Double_info  tag标志位为6， 双精度字面量 <br/>
CONSTANT_Class_info    tag标志位为7， 类或接口的符号引用<br/>
CONSTANT_String_info    tag标志位为8，字符串类型的字面量<br/>
CONSTANT_Fieldref_info  tag标志位为9,  字段的符号引用 <br/>
CONSTANT_Methodref_info  tag标志位为10，类中方法的符号引用<br/>
CONSTANT_InterfaceMethodref_info tag标志位为11, 接口中方法的符号引用<br/>
CONSTANT_NameAndType_info tag 标志位为12，字段和方法的名称以及类型的符号引用</li>
<li>u2 access_flags 表示类或者接口的访问信息，具体如下图所示：
<img class="center" src="/images/2013/01/30/class-access-and-property-modifiers.png"></li>
<li>u2 this_class 表示类的常量池索引，指向常量池中CONSTANT_Class_info的常量</li>
<li>u2 super_class 表示超类的索引，指向常量池中CONSTANT_Class_info的常量</li>
<li>u2 interface_counts 表示接口的数量</li>
<li>u2 interface[interface_counts]表示接口表，它里面每一项都指向常量池中CONSTANT_Class_info常量</li>
<li>u2 fields_count 表示类的实例变量和类变量的数量</li>
<li>field_info fields[fields_count]表示字段表的信息，其中字段表的结构如下图所示：<br/>
<img class="center" src="/images/2013/01/30/field-info.png"><br/>
上图中access_flags表示字段的访问标示，比如字段是public,private，protect 等，name_index表示字段名 称，指向常量池中类型是CONSTANT_UTF8_info的常量，descriptor_index表示字段的描述符，它也指向常量池中类型为CONSTANT_UTF8_info的常量，attributes_count表示字段表中的属性表的数量，而属性表是则是一种用与描述字段，方法以及类的属性的可扩展的结构，不同版本的Java虚拟机所支持的属性表的数量是不同的。</li>
<li>u2 methods_count表示方法表的数量</li>
<li>method_info 表示方法表，方法表的具体结构如下图所示：
<img class="center" src="/images/2013/01/30/method-info.png"><br/>
其中access_flags表示方法的访问标示，name_index表示名称的索引，descriptor_index表示方法的描述符，attributes_count以及attribute_info类似字段表中的属性表，只不过字段表和方法表中属性表中的属性是不同的，比如方法表中就Code属性，表示方法的代码，而字段表中就没有Code属性。其中具体Class中到底有多少种属性，等到Class文件结构中的属性表的时候再说说。</li>
<li>attribute_count表示属性表的数量，说到属性表，我们需要明确以下几点：<br/>
1.属性表存在于Class文件结构的最后，字段表，方法表以及Code属性中，也就是说属性表中也可以存在属性表。<br/>
2.属性表的长度是不固定的，不同的属性，属性表的长度是不同的。</li>
</ol>


<p>本篇文章描述了Java Class文件方面的理论知识，下面一篇文章将通过一个实际的例子来详细解释一下Class文件内部到底长什么样。具体请参考本系列的第二篇文章：<br/>
<a href="/blog/2013/01/30/java-class-file-format-demo/">实例分析Java Class文件的结构-实践篇</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分布式应用中客户端的设计]]></title>
    <link href="http://imtiger.github.io/blog/2011/03/25/client-design-of-distributed-system/"/>
    <updated>2011-03-25T18:16:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2011/03/25/client-design-of-distributed-system</id>
    <content type="html"><![CDATA[<p>一个分布式的系统一般都会有很多的节点，节点和节点之间的通讯采用远程调用的方式，而当在实现业务逻辑的时候，我们可以通过客户端的实现方式实现，目前实现客户端的方式有两种方式，瘦客户端和富客户端。</p>

<h1>瘦客户端</h1>

<p>所谓瘦客户端类似于之前EJB那种方式，瘦客户端本身不具有业务逻辑，瘦客户端通过业务接口调用服务端逻辑，这个时候逻辑运算还是跑那个被多个系统共用的服务器，这样当存在大量的请求的情况下，负责逻辑运算的服务器就会成为瓶颈，这个时候通过水平伸缩负责逻辑运算的服务器，这个时候涉及到客户端请求的负载均衡，每次将远程调用采用负载均衡算法将其分配到逻辑端服务器，采用这种方式以后，可能就需要远程调用框架内部支持一些比如流量控制，负载均衡等的机制，这样使得调用方本身不需要关心服务器端的物理部署。</p>

<p>当然了，我们也可以通过富客户端的方式来实现，下面我们就来介绍一下富客户端的设计。</p>

<!-- more -->


<h1>富客户端</h1>

<p>富客户端是将运算逻辑以客户端包的形式提供给调用方来使用，这样可以分摊逻辑运算服务器的压力，将压力分担到调用方服务器。这种方式非常适合调用方服务器本身负责的逻辑很简单，运算量很小的情况下，采用富客户端以后可以合理利用调用方服务器的资源来分摊掉被调用方服务器的压力。另外一方面，富客户端也适用于当需要将一些非核心的业务从核心业务中剥离出来，然后让非核心的业务跑到调用方的服务器中，同时富客户端还可以做其它的一些事情，比如缓存调用结果，实现调用方的local cache等。</p>

<p>当然了采用富客户端也会带来一个明显的问题，那就是客户端的升级，假如逻辑有变化需要让调用方升级客户端包，当然这也有解决办法，就是将业务逻辑进行抽象，每一步都采用动态脚本的方式比如Groovy脚本去执行，每次客户端服务器启动的时候，中心服务器推送最新的Groovy脚本到web客户端服务器，这样客户端服务器就可以获取到最新的执行逻辑,当然这对客户端的设计要求严格，客户端可能要设计的具有插件式的灵活功能。</p>

<p>采用富客户端另外一个问题就是富客户端的状态和服务器端的如何进行同步，假如服务器端的一些数据变化了，而客户端需要感知这些变化怎么办？这也有解决办法，一种方式是<code>拉模式</code>，另外一种模式<code>推模式</code>。</p>

<ol>
<li><p>拉模式 <br/>
拉模式就是每次服务端有变化的时候，给富客户端发条指令，然后富客户端会主动向服务器端来拉数据，这种方式对于客户端服务器量比较大的情况下比较方便，比如富客户端被前端数百台机器使用，这个时候可以显著减少服务端的工作量。</p></li>
<li><p>推模式<br/>
推模式就是当服务器端发生变化的时候，主动推送给每个客户端，这种情况适合客户端服务器数量不多的情况，当然无论是采用拉还是推模式都需客户端和服务端保持一定的联系，这可能需要客户端在启动的时候主动的向服务端去注册一下，客户端注册以后，中心服务器端可以监控客户端的一些运行状况等信息。</p></li>
</ol>


<p>以上两种是在分布式系统中常见的两种客户端的设计策略，具体需要哪种，需要根据系统场景进行取舍。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jvm内存模型以及垃圾收集策略解析系列（二）]]></title>
    <link href="http://imtiger.github.io/blog/2010/02/21/jvm-memory-and-gc-2/"/>
    <updated>2010-02-21T13:40:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2010/02/21/jvm-memory-and-gc-2</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2010/02/21/jvm-original-logo.jpg"></p>

<p>本文是<code>Jvm内存模型以及垃圾收集策略解析系列</code>第二篇，第一篇为<a href="/blog/2010/02/21/jvm-memory-and-gc/">Jvm内存模型以及垃圾收集策略解析系列(一)</a>。<br/>
本文之前发布在本人Iteye的<a href="http://xmuzyq.iteye.com">博客</a>上，换了新博客后，重新整理一下，发布在此，希望对Jvm 内存以及垃圾收集策略感兴趣的朋友有点帮助。</p>

<p><a href="/blog/2010/02/21/jvm-memory-and-gc/">Jvm内存模型以及垃圾收集策略解析系列(一)</a>介绍了下面的前3部分，本篇文章将介绍第4和第5部分</p>

<ol>
<li>Java虚拟机规范规定的Jvm 内存概念模型</li>
<li>HotSpot Jvm 内存的模型</li>
<li>常见的垃圾收集策略</li>
<li><code>HotSpot Jvm 垃圾收集策略</code></li>
<li><code>HotSpot Jvm 垃圾收集器的配置策略</code></li>
</ol>


<!-- more -->


<h1>4.HotSpot Jvm 垃圾收集策略</h1>

<p>GC的执行时要耗费一定的CPU资源和时间的，因此在JDK1.2以后，JVM引入了分代收集的策略，其中对新生代采用"Mark-Compact"策略，而对老生代采用了“Mark-Sweep"的策略。其中新生代的垃圾收集器命名为“minor gc”，老生代的GC命名为"Full Gc 或者Major GC".其中用System.gc()强制执行的是Full Gc.
HotSpot Jvm的垃圾收集器按照并发性可以分为如下三种类型：</p>

<h2>4.1 串行收集器（Serial Collector）</h2>

<p>Serial Collector是指任何时刻都只有一个线程进行垃圾收集，这种策略有一个名字“stop the whole world",它需要停止整个应用的执行。这种类型的收集器适合于单CPU的机器。
Serial Collector 有如下两个：</p>

<ol>
<li><p>Serial Copying Collector:<br/>
此种GC用-XX:UseSerialGC选项配置，它只用于<code>新生代</code>对象的收集。1.5.0以后.<br/>
<code>-XX:MaxTenuringThreshold</code>来设置对象复制的次数。当eden空间不够的时候，GC会将eden的活跃对象和一个名叫From survivor空间中尚不够资格放入Old代的对象复制到另外一个名字叫To Survivor的空间。而此参数就是用来说明到底From survivor中的哪些对象不够资格，假如这个参数设置为31，那么也就是说只有对象复制31次以后才算是有资格的对象。</p>

<blockquote><p>这里需要注意几个个问题：<br/>
From Survivor和To survivor的角色是不断的变化的，同一时间只有一块空间处于使用状态，这个空间就叫做From Survivor区，当复制一次后角色就发生了变化。<br/>
如果复制的过程中发现To survivor空间已经满了，那么就直接复制到old generation.<br/>
比较大的对象也会直接复制到Old generation,在开发中，我们应该尽量避免这种情况的发生。</p></blockquote></li>
<li><p>Serial  Mark-Compact Collector： <br/>
串行的标记-整理收集器是JDK5 update6之前默认的<code>老生代</code>的垃圾收集器，此收集使得内存碎片最少化，但是它需要暂停的时间比较长</p></li>
</ol>


<h2>4.2 并行收集器（Parallel Collector）</h2>

<p>Parallel Collector主要是为了应对多CPU，大数据量的环境。<br/>
Parallel Collector又可以分为以下三种：</p>

<ol>
<li>Parallel Copying Collector<br/>
此种GC用-XX:UseParNewGC参数配置,它主要用于<code>新生代</code>的收集,此GC可以配合CMS一起使用，适用于1.4.1以后。</li>
<li>Parallel Mark-Compact Collector<br/>
此种GC用-XX:UseParallelOldGC参数配置，此GC主要用于<code>老生代</code>对象的收集。适用于1.6.0以后。</li>
<li>Parallel scavenging Collector<br/>
此种GC用-XX:UseParallelGC参数配置，它是对<code>新生代</code>对象的垃圾收集器，但是它不能和CMS配合使用，它适合于比较大新生代的情况，此收集器起始于jdk 1.4.0。它比较适合于对吞吐量高于暂停时间的场合。</li>
</ol>


<p>串行收集器和并行收集器可以通过如下的图来表示：</p>

<p><img class="center" src="/images/2010/02/21/serial-and-parallel-gc.jpg"></p>

<h2>4.3 并发收集器 (Concurrent Collector)</h2>

<p>Concurrent Collector通过并行的方式进行垃圾收集，这样就减少了垃圾收集器收集一次的时间，在HotSpot Jvm中，我们称之为CMS GC,这种GC在实时性要求高于吞吐量的时候比较有用。此种GC可以用参数-XX:UseConcMarkSweepGC配置，此GC主要用于老生代和Perm代的收集。
并发收集器可以通过下图形象的描述：
<img class="center" src="/images/2010/02/21/concurrent-gc.jpg"></p>

<p>CMS GC有可能出现并发模型失败：</p>

<blockquote><p>并发模型失败：我们CMS GC在运行的时候，用户线程也在运行，当gc的速度比新增对象的速度慢的时候，或者说当正在GC的时候，老年代的空间不能满足用户线程内存分配的需求的时候，就会出现并发模型失败，出现并发模型失败的时候，JVM会触发一次stop-the-world的Full GC这将导致暂停时间过长。不过CMS GC提供了一个参数<code>-XX:CMSInitiatingOccupancyFraction</code>来指定当老年代的空间超过某个值的时候即触发GC。因此如果此参数设置的过高，可能会导致更多的并发模型失败。</p></blockquote>

<p>并发和并行收集器区别：</p>

<blockquote><p>对于并发和并行收集器，我们需要注意一点：并发收集器是指垃圾收集器线程和应用线程可以并发的执行，也就是清除的时候不需要stop the world，但是并行收集器指的的是可以多个线程并行的进行垃圾收集，并行收集器还是要暂停应用的（即所谓的stop the world）</p></blockquote>

<h1>5.HotSpot Jvm 垃圾收集器的配置策略</h1>

<p>通过上面的描述，我们知道HotSpot Jvm中都有哪些垃圾收集器供我们使用，接下来我们总结一下如何配置垃圾收集器。在继续之前我们需要明白，上面所讲的垃圾收集器有些用于新生代，有些用于老年代，并且不是任何两个都可以配对使用的，下面我们通过下图来形象的描述一下哪些收集器可以配对使用：
<img class="center" src="/images/2010/02/21/hotspot-gc-collectors.png"></p>

<p>Ok,知道新生代和老年代垃圾收集器都有哪些收集器以后，咋们接下来看看具体如何来选择垃圾收集器。这需要根据我们的应用特点来进行选择。下面我们分两种情况来分别描述一下不同情况下的垃圾收集配置策略。</p>

<h2>5.1 吞吐量优先</h2>

<p>吞吐量是指GC的时间与运行总时间的比值，比如系统运行了100分钟，而GC占用了一分钟，那么吞吐量就是99%，吞吐量优先一般运用于对响应性要求不高的场合，比如web应用，因为网络传输本来就有延迟的问题，GC造成的短暂的暂停使得用户以为是网络阻塞所致。<br/>
吞吐量优先可以通过-XX:GCTimeRatio来指定。当通过-XX:GCTimeRatio不能满足系统的要求以后，我们可以更加细致的来对JVM进行调优。<br/>
首先因为要求高吞吐量，这样就需要一个较大的Young generation，此时就需要引入“<code>Parallel scavenging Collector</code>”,可以通过参数：<code>-XX:UseParallelGC</code>来配置。<br/>
<code>java Jvm config
java -server -Xms3072m -Xmx3072m -XX:NewSize=2560m -XX:MaxNewSize=2560 XX:SurvivorRatio=2 - XX:+UseParallelGC
</code>
当年轻代使用了"<code>Parallel scavenge collector</code>&ldquo;后，老生代就不能使用"CMS"GC了，在JDK1.6之前，此时老生代只能采用串行收集，而JDK1.6引入了并行版本的老生代收集器，可以用参数<code>-XX:UseParallelOldGC</code>来配置。</p>

<p>1.控制并行的线程数  <br/>
缺省情况下，Parallel scavenging Collector 会开启与cpu数量相同的线程进行并行的收集，但是也可以调节并行的线程数。假如你想用4个并行的线程去收集Young generation的话，那么就可以配置-XX:ParallelGCThreads=4,此时JVM的配置参数如下：
<code>java Jvm config
java -server -Xms3072m -Xmx3072m -XX:NewSize=2560m -XX:MaxNewSize=2560 XX:SurvivorRatio=2 -XX:+UseParallelGC -XX:ParallelGCThreads=4
</code>
2.自动调节新生代    <br/>
在采用了"Parallel scavenge collector"后，此GC会根据运行时的情况自动调节survivor ratio来使得性能最优，因此"Parallel scavenge collector"应该总是开启此参数。此时JVM的参数配置如下：
<code>java Jvm config
java -server -Xms3072m -Xmx3072m -XX:+UseParallelGC -XX:ParallelGCThreads=4 -XX:+UseAdaptiveSizePolicy
</code></p>

<h2>5.2 响应时间优先</h2>

<p>响应时间优先是指GC每次运行的时间不能太久，这种情况一般使用与对及时性要求很高的系统，比如股票系统等。</p>

<p>响应时间优先可以通过参数-XX:MaxGCPauseMillis来配置，配置以后JVM将会自动调节年轻代，老生代的内存分配来满足参数设置。</p>

<p>在一般情况下，JVM的默认配置就可以满足要求，只有默认配置不能满足系统的要求时候，才会根据具体的情况来对JVM进行性能调优。如果采用默认的配置不能满足系统的要求，那么此时就可以自己动手来调节。此时"Young generation"可以采用"Parallel copying collector"，而"Old generation"则可以采用"Concurrent Collector".<br/>
举个例子来说，以下参数设置了新生代用Parallel Copying Collector，老生代采用CMS收集器。<br/>
<code>java
java -server -Xms512m -Xmx512m  -XX:NewSize=64m -XX:MaxNewSize=64m -XX:SurvivorRatio=2  -XX:+UseConcMarkSweepGC -XX:+UseParNewGC
</code></p>

<blockquote><p>此时需要注意两个问题：<br/>
1.如果没有指定-XX:+UseParNewGC，则采用默认的非并行版本的copy collector.<br/>
2.如果在一个单CPU的系统上设置了-XX:+UseParNewGC ,则默认还是采用缺省的copy collector.</p></blockquote>

<p>1.控制并行的线程数<br/>
默认情况下，Parallel copy collector启动和CPU数量一样的线程，也可以通过参数-XX:ParallelGCThreads来指定，比如你想用3个线程去进行并发的复制收集，那么可以改变上述参数如下：
<code>java
java -server -Xms512m -Xmx512m -XX:NewSize=64m  -XX:MaxNewSize=64m -XX:SurvivorRatio=2        -XX:ParallelGCThreads=4 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC
</code></p>

<p>2.控制并发收集的临界值 <br/>
默认情况下，CMS gc在"old generation"空间占用率高于68%的时候，就会进行垃圾收集，而如果想控制收集的临界值，可以通过参数：-XX:CMSInitiatingOccupancyFraction来控制，比如改变上述的JVM配置如下：
<code>java
java -server -Xms512m -Xmx512m -XX:NewSize=64m -XX:MaxNewSize=64m -XX:SurvivorRatio=2  -XX:ParallelGCThreads=4 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:CMSInitiatingOccupancyFraction=35
</code></p>

<p>最后附上一些JVM 垃圾收集方面的文章供大家参考：<br/>
<a href="http://www.ibm.com/developerworks/library/j-jtp10283/index.html?S_TACT=105AGX52&amp;S_CMP=cn-a-j">Java theory and practice: A brief history of garbage collection</a> <br/>
<a href="http://www.ibm.com/developerworks/library/j-jtp11253/index.html?S_TACT=105AGX52&amp;S_CMP=cn-a-j">Java theory and practice: Garbage collection in the HotSpot JVM</a><br/>
<a href="https://blogs.oracle.com/poonam/entry/understanding_cms_gc_logs"> Understanding CMS GC Logs </a> <br/>
<a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">Java HotSpot VM Options</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jvm内存模型以及垃圾收集策略解析系列（一）]]></title>
    <link href="http://imtiger.github.io/blog/2010/02/21/jvm-memory-and-gc/"/>
    <updated>2010-02-21T09:33:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2010/02/21/jvm-memory-and-gc</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2010/02/21/jvm-original-logo.jpg">
本文之前发布在本人Iteye的<a href="http://xmuzyq.iteye.com">博客</a>上，换了新博客后，重新整理一下，发布在此，希望对Jvm 内存以及垃圾收集策略感兴趣的朋友有点帮助。</p>

<p>本文主要内容分为如下几部分：</p>

<ol>
<li><code>Java虚拟机规范规定的Jvm 内存概念模型</code></li>
<li><code>HotSpot Jvm 内存的模型</code></li>
<li><code>常见的垃圾收集策略</code></li>
<li>HotSpot Jvm 垃圾收集策略</li>
<li>HotSpot Jvm 垃圾收集器的配置策略<br/>
本篇文章只涉及1，2，3部分，第4和5部分<a href="/blog/2010/02/21/jvm-memory-and-gc-2/">Jvm内存模型以及垃圾收集策略解析系列(二)</a>文章我们再来说。</li>
</ol>


<!-- more -->


<h1>1.Java虚拟机内存概念模型</h1>

<p>在本文开始之前，首先我们这里要明确一点，Jvm的内存模型分为<code>Java 虚拟机规范规定的概念模型</code>以及具体厂商的<code>实现模型</code>。不同的厂商的Jvm在实现方式上可能会存在差别，本文中如果没有特别指出，Jvm 默认都指HotSpot Jvm。</p>

<p>OK，明确了上面一点以后，咋们首先来看一下<code>Java 虚拟机规范</code>对Jvm 内存模型的要求，咋们具体可以参考下图：<br/>
<img class="center" src="/images/2010/02/21/jvm-memory-mode.png"></p>

<p>由上图可以看出Jvm 运行时的内存主要分为两部分：</p>

<ol>
<li><p>所有线程共享的区域<br/>
 线程共享的区域分为又分为下面两部分：</p>

<ol>
<li>方法区<br/>
方法区主要存放虚拟机中已经加载的类的信息，静态变量，常量等。方法区中有一块非常重要的区域<code>运行时常量池</code>,我们知道Java Class的文件结构中有一个叫<code>常量池</code>的结构，它主要存放了编译器生成的各种字面常量和符号引用，这部分的内容也将放到运行时常量池。</li>
<li>堆<br/>
堆中存放了Java 对象，现代虚拟机，对于堆又进行了进一步的划分，具体细节到下面的HotSpot jvm 的实现中再来说说。</li>
</ol>
</li>
<li><p>线程独享的区域</p>

<ol>
<li>Java虚拟机栈<br/>
Java 方法在运行的时候，虚拟机会分配给每次方法调用一个<code>栈帧</code>,栈帧中包含了局部变量表，操作数栈，方法出口等信息。</li>
<li>本地方法栈<br/>
本地方法栈是为Java 中执行Native 方法服务的，作用和Java 虚拟机栈是一样的。</li>
<li>程序计数器 <br/>
每个线程都会有自己的程序计数器方面在执行Java 方法的时候，能顺利的找到下面要执行的指令。</li>
</ol>
</li>
</ol>


<h1>2.HotSpot jvm内存实现模型</h1>

<p>Ok,上面说了Java 虚拟机规范规定的虚拟机概念模型中的内存布局，接下来我们以Sun公司的HopSpot jvm为例（现以及被Oracle 收购），来具体的看看JVM的内存模型和垃圾收集方面的知识。</p>

<p>Java HotSopt jvm 将JVM的堆内存分为了几个区域，我们可以通过下图来形象的描述：
<img class="center" src="/images/2010/02/21/hotsopt-jvm-memory.jpg"></p>

<p>从上图我们可以清晰的看到HotSpot jvm 将堆分为如下三部分：</p>

<ol>
<li><p>新生代（Young）<br/>
新生代被划分为三部分，Eden区和两个大小严格相同的Survivor区，其中Survivor区间，某一时刻只有其中一个是被使用的，另外一个留做垃圾收集时复制对象用，在Young区间变满的时候，minor GC就会将存活的对象移到空闲的Survivor区间中，根据JVM的策略，在经过几次垃圾收集后，仍然存活于Survivor的对象将被移动到Tenured区间。</p></li>
<li><p>老年代（Tenured）<br/>
Tenured区主要保存生命周期长的对象，一般是一些老的对象，当一些对象在Young复制转移一定的次数以后，对象就会被转移到Tenured区，一般如果系统中用了application级别的缓存，缓存中的对象往往会被转移到这一区间。</p></li>
<li><p>持久代（Perm）<br/>
Perm代主要保存class,method,filed对象，这部分的空间一般不会溢出，除非一次性加载了很多的类，不过在涉及到热部署的应用服务器的时候，有时候会遇到java.lang.OutOfMemoryError : PermGen space 的错误，造成这个错误的很大原因就有可能是每次都重新部署，但是重新部署后，类的class没有被卸载掉，这样就造成了大量的class对象保存在了perm中，这种情况下，一般重新启动应用服务器可以解决问题。</p>

<blockquote><p>说到持久代，我们有必要来说一下虚拟机概念模型和实现模型方面的差异，在HotSpot虚拟机的实现中利用持久代实现了概念模型的方法区。</p></blockquote></li>
</ol>


<p>OK,接下来我们再来看看 HotSpot jvm都给我们提供了哪些参数来对内存进行配置：</p>

<ul>
<li>配置总内存<br/>
<code>-Xms</code> ：指定了JVM初始启动以后初始化内存<br/>
<code>-Xmx</code>：指定JVM堆得最大内存，在JVM启动以后，会分配-Xmx参数指定大小的内存给JVM，但是不一定全部使用，JVM会根据-Xms参数来调节真正用于JVM的内存<br/>
-Xmx-Xms之差就是三个Virtual空间的大小</li>
<li>配置新生代 <br/>
<code>-Xmn</code>: 参数设置了年轻代的大小 <br/>
<code>-XX:SurvivorRatio</code>: 表示eden和一个surivivor的比例，缺省值为8.假如<code>-XX:SurvivorRatio=32</code>意味着eden和一个survivor的比值是32：1，这样一个Survivor就占Young区的1/34.</li>
<li>配置老年代  <br/>
<code>-XX:NewRatio</code>: 表示年老年代和新生代内存的比例，缺省值为2.假如<code>-XX:NewRatio=8</code>意味着tenured 和 young的比值8：1</li>
<li>配置持久代<br/>
<code>-XX:MaxPermSize</code>：表示持久代的最大值</li>
</ul>


<p>有了上面虚拟机的内存模型的相关介绍做为铺垫，我们接着来看一下有关垃圾收集方面的知识。</p>

<h1>3.常见的垃圾收集策略</h1>

<p>垃圾收集提供了内存管理的机制，使得应用程序不需要在关注内存如何释放，内存用完后，垃圾收集会进行收集，这样就减轻了因为人为的管理内存而造成的错误，比如在C++语言里，出现内存泄露时很常见的。Java语言是目前使用最多的依赖于垃圾收集器的语言，但是垃圾收集器策略从20世纪60年代就已经流行起来了，比如Smalltalk,Eiffel等编程语言也集成了垃圾收集器的机制。</p>

<p>所有的垃圾收集算法都面临同一个问题，那就是找出应用程序不可到达的内存块，将其释放，这里面得不可到达主要是指应用程序已经没有内存块的引用了，而在JAVA中，某个对象对应用程序是可到达的是指：这个对象被根（根主要是指类的静态变量，常量或者活跃在所有线程栈的对象的引用）引用或者对象被另一个可到达的对象引用，可以通过下图来形象的描述：
<img class="center" src="/images/2010/02/21/root-avaliable.jpg"></p>

<p>下面我们介绍一下几种常见的垃圾收集策略：</p>

<h2>1. Reference Counting(引用计数）</h2>

<p>引用计数是最简单直接的一种方式，这种方式在每一个对象中增加一个引用的计数，这个计数代表当前程序有多少个引用引用了此对象，如果此对象的引用计数变为0，那么此对象就可以作为垃圾收集器的目标对象来收集。<br/>
优点：<br/>
简单，直接，不需要暂停整个应用<br/>
缺点：<br/>
需要编译器的配合，编译器要生成特殊的指令来进行引用计数的操作，比如每次将对象赋值给新的引用，或者者对象的引用超出了作用域等。<br/>
不能处理循环引用的问题</p>

<h2>2. 跟踪收集器</h2>

<p>跟踪收集器首先要暂停整个应用程序，然后开始从根对象扫描整个堆，判断扫描的对象是否有对象引用。
如果每次扫描整个堆，那么势必让GC的时间变长，从而影响了应用本身的执行。因此在JVM里面采用了分代收集，在新生代收集的时候minor gc只需要扫描新生代，而不需要扫描老生代。<br/>
JVM采用了分代收集以后，minor gc只扫描新生代，但是minor gc怎么判断是否有老生代的对象引用了新生代的对象，JVM采用了卡片标记的策略，卡片标记将老生代分成了一块一块的，划分以后的每一个块就叫做一个卡片，JVM采用卡表维护了每一个块的状态，当JAVA程序运行的时候，如果发现老生代对象引用或者释放了新生代对象的引用，那么就JVM就将卡表的状态设置为脏状态，这样每次minor gc的时候就会只扫描被标记为脏状态的卡片，而不需要扫描整个堆。具体如下图：<br/>
<img class="center" src="/images/2010/02/21/jvm-memory-table-card.jpg">
上面说了Jvm 需要判断对象是否有引用存在，而Java 中的引用又分为了如下几种，不同种类的引用对垃圾收集有不同的影响，下面我们分开描述一下：<br/>
<code>1.Strong Reference(强引用)</code><br/>
强引用是JAVA中默认采用的一种方式，我们平时创建的引用都属于强引用。如果一个对象没有强引用，那么对象就会被回收。<br/>
<code>2.Soft Reference(软引用)</code>
软引用的对象在GC的时候不会被回收，只有当内存不够用的时候才会真正的回收，因此软引用适合缓存的场合，这样使得缓存中的对象可以尽量的再内存中待长久一点。 <br/>
<code>3.Weak Reference(弱引用)</code><br/>
弱引用有利于对象更快的被回收，假如一个对象没有强引用只有弱引用，那么在GC后，这个对象肯定会被回收。<br/>
<code>4.Phantom reference(幽灵引用)</code> <br/>
幽灵引用说是引用，但是你不能通过幽灵引用来获取对象实例，它主要目的是为了当设置了幽灵引用的对象在被回收的时候可以收到通知。 <br/>
跟踪收集器常见的有如下几种：</p>

<h3>2.1 Mark-Sweep Collector(标记-清除收集器）</h3>

<p>标记清除收集器最早由Lisp的发明人于1960年提出，标记清除收集器停止所有的工作，从根扫描每个活跃的对象，然后标记扫描过的对象，标记完成以后，清除那些没有被标记的对象。<br/>
优点：<br/>
解决循环引用的问题<br/>
不需要编译器的配合，从而就不执行额外的指令<br/>
缺点：  <br/>
每个活跃的对象都要进行扫描，收集暂停的时间比较长。</p>

<h3>2.2 Copying Collector(复制收集器）</h3>

<p>复制收集器将内存分为两块一样大小空间，某一个时刻，只有一个空间处于活跃的状态，当活跃的空间满的时候，GC就会将活跃的对象复制到未使用的空间中去，原来不活跃的空间就变为了活跃的空间。复制收集器具体过程可以参考下图：
<img class="center" src="/images/2010/02/21/copy-gc.jpg">
优点： <br/>
只扫描可以到达的对象，不需要扫描所有的对象，从而减少了应用暂停的时间<br/>
缺点：<br/>
需要额外的空间消耗，某一个时刻，总是有一块内存处于未使用状态<br/>
复制对象需要一定的开销</p>

<h3>2.3 Mark-Compact Collector(标记-整理收集器）</h3>

<p>标记整理收集器汲取了标记清除和复制收集器的优点，它分两个阶段执行，在第一个阶段，首先扫描所有活跃的对象，并标记所有活跃的对象，第二个阶段首先清除未标记的对象，然后将活跃的的对象复制到堆得底部。标记整理收集器的过程示意图请参考下图：
<img class="center" src="/images/2010/02/21/mark-compact-collector.jpg">
Mark-compact策略极大的减少了内存碎片，并且不需要像Copy Collector一样需要两倍的空间。</p>

<p>本篇文章介绍了Jvm内存的概念模型，HotSpot jvm内存实现模型，以及常见的垃圾收集策略，本系列的下篇文章将介绍，HotSpot jvm中的内存模型以及HotSpot Jvm 垃圾收集器的配置策略。下篇请参加如下文章：<br/>
<a href="/blog/2010/02/21/jvm-memory-and-gc-2/">Jvm内存模型以及垃圾收集策略解析系列（二)</a></p>

<p>最后附上一些JVM 垃圾收集方面的文章供大家参考：<br/>
<a href="http://www.ibm.com/developerworks/library/j-jtp10283/index.html?S_TACT=105AGX52&amp;S_CMP=cn-a-j">Java theory and practice: A brief history of garbage collection</a> <br/>
<a href="http://www.ibm.com/developerworks/library/j-jtp11253/index.html?S_TACT=105AGX52&amp;S_CMP=cn-a-j">Java theory and practice: Garbage collection in the HotSpot JVM</a><br/>
<a href="https://blogs.oracle.com/poonam/entry/understanding_cms_gc_logs"> Understanding CMS GC Logs </a> <br/>
<a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">Java HotSpot VM Options</a></p>
]]></content>
  </entry>
  
</feed>
