<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[I'm Tiger,一个有理想爱折腾的程序员!]]></title>
  <link href="http://imtiger.github.io/atom.xml" rel="self"/>
  <link href="http://imtiger.github.io/"/>
  <updated>2013-10-15T22:24:44+08:00</updated>
  <id>http://imtiger.github.io/</id>
  <author>
    <name><![CDATA[imtiger]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[在IntelliJ IDEA 和 Eclipse运行tomcat 7源代码]]></title>
    <link href="http://imtiger.github.io/blog/2013/10/14/run-tomcat-in-idea-or-eclipse/"/>
    <updated>2013-10-14T14:39:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2013/10/14/run-tomcat-in-idea-or-eclipse</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://imtiger.github.io/images/2013/10/14/apache_tomcat_bag.jpg">
在阅读Tomcat源代码之前，我们首先需要将Tomcat的源代码在IDE里面运行起来，这样方便我们阅读的过程中调试。本文总结一下在IDEA 或者 Eclipse中运行Tomcat源代码环境的搭建过程，同时我们通过Maven来负责项目的构建。</p>

<p>在进行搭建之前，我们首先来说一下总体的思路。我们知道Tomcat运行的时候，一部分是源代码编译以后的可运行的Jar,另外一部分则是运行时的环境（也就是我们从官方下载下来的二进制分发包中的一系列的配置文件以及目录结构，说的更直白点就是CATALINA_HOME环境变量指定的目录）,本文对于第一部分采用IntelliJ IDEA 运行tomcat-7.0.42 tag的源代码，而对于第二部分运行环境，我们则直接采用tomcat-7.0.42的二进制分发包。明白了上述的思路以后，咋们就来一步步的搭建吧。</p>

<!-- more -->


<p>首先咋们来看看搭建完成以后的总体的目录结构，然后再一步步的去分解搭建过程。笔者搭建完以后，最终的运行结构如下图所示：
<img class="center" src="http://imtiger.github.io/images/2013/10/14/project-structure.png"></p>

<p>下面分别解释一下上图工程结构中涉及到的文件和目录：</p>

<ol>
<li>.idea和tomcat-study.iml是IntelliJ IDEA的文件，如果你用Eclipse的话不会存在这两个东东 。</li>
<li>catalina-home是从官方下载的7.0.42的二进制分发包解压后的目录</li>
<li>target是Maven编译项目以后生成的文件夹，熟悉Maven的读者应该很熟悉此目录</li>
<li>tomcat-7.0.42-sourcecode是从Tomcat<a href="http://svn.apache.org/repos/asf/tomcat/tc7.0.x/tags/TOMCAT_7_0_42/">官方仓库</a>下载的tags的源代码</li>
<li>pom.xml是Maven的配置文件,此工程中有两个pom.xml，这里运用了Maven聚合的特性。</li>
</ol>


<p>了解了最终的结构以后，咋们就来一步步的搭建它吧。</p>

<h3>第一步 创建项目目录结构</h3>

<p>本文假设我们将项目放在<code>~/develop/java</code>目录中。</p>

<figure class='code'><figcaption><span>create project structure</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">cd</span> ~/develop/java
</span><span class='line'>mkdir Tomcat
</span><span class='line'><span class="nb">cd </span>Tomcat
</span><span class='line'>touch pom.xml
</span></code></pre></td></tr></table></div></figure>


<h3>第二步 下载Tomcat 7.0.42二进制分发包</h3>

<p>我们通过apache-tomcat-7.0.42的<a href="http://mirrors.hust.edu.cn/apache/tomcat/tomcat-7/v7.0.42/bin/apache-tomcat-7.0.42.tar.gz">官方地址</a>下载它。具体的过程如下：</p>

<figure class='code'><figcaption><span>download apache-tomcat-7.0.42 binary distribution</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">cd</span> ~/develop/java/Tomcat
</span><span class='line'>wget http://mirrors.hust.edu.cn/apache/tomcat/tomcat-7/v7.0.42/bin/apache-tomcat-7.0.42.tar.gz
</span><span class='line'>tar -zxvf apache-tomcat-7.0.42.tar.gz
</span><span class='line'>rm apache-tomcat-7.0.42.tar.gz
</span><span class='line'>mv apache-tomcat-7.0.42 catalina-home
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h3>第三步 下载Tomcat 7.0.42 源代码</h3>

<p>接下来我们从Tomcat的<a href="http://svn.apache.org/repos/asf/tomcat/tc7.0.x/tags/TOMCAT_7_0_42/">官方SVN仓库</a>下载Tomcat 7.0.42源代码，具体的步骤如下：</p>

<figure class='code'><figcaption><span>download Tomcat 7.0.42 source code</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">cd</span> ~/develop/java/Tomcat
</span><span class='line'>svn co http://svn.apache.org/repos/asf/tomcat/tc7.0.x/tags/TOMCAT_7_0_42/  tomcat-7.0.42-sourcecode
</span></code></pre></td></tr></table></div></figure>


<p>在这一步中，我们将7.0.42的源代码迁入到了tomcat-7.0.42-sourcecode目录中。</p>

<h3>第四步 创建聚合模块pom.xml</h3>

<p>因为我们通过maven来对项目进行构建，这就需要我们来创建一个pom.xml文件，具体过程如下：</p>

<figure class='code'><figcaption><span>create aggregation child project pom.xml</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">cd</span> ~/develop/java/Tomcat/tomcat-7.0.42-sourcecode
</span><span class='line'>touch pom.xml
</span></code></pre></td></tr></table></div></figure>


<p>用你喜欢的编辑器打开pom.xml然后用下面的内容替换它的内容：</p>

<figure class='code'><figcaption><span>pom.xml</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
</span><span class='line'><span class="nt">&lt;project</span> <span class="na">xmlns=</span><span class="s">&quot;http://maven.apache.org/POM/4.0.0&quot;</span>
</span><span class='line'>         <span class="na">xmlns:xsi=</span><span class="s">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>
</span><span class='line'>         <span class="na">xsi:schemaLocation=</span><span class="s">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="nt">&lt;modelVersion&gt;</span>4.0.0<span class="nt">&lt;/modelVersion&gt;</span>
</span><span class='line'>    <span class="nt">&lt;groupId&gt;</span>org.apache.tomcat<span class="nt">&lt;/groupId&gt;</span>
</span><span class='line'>    <span class="nt">&lt;artifactId&gt;</span>Tomcat7.0<span class="nt">&lt;/artifactId&gt;</span>
</span><span class='line'>    <span class="nt">&lt;name&gt;</span>Tomcat7.0<span class="nt">&lt;/name&gt;</span>
</span><span class='line'>    <span class="nt">&lt;version&gt;</span>7.0<span class="nt">&lt;/version&gt;</span>
</span><span class='line'>
</span><span class='line'>    <span class="nt">&lt;build&gt;</span>
</span><span class='line'>        <span class="nt">&lt;finalName&gt;</span>Tomcat7.0<span class="nt">&lt;/finalName&gt;</span>
</span><span class='line'>        <span class="nt">&lt;sourceDirectory&gt;</span>java<span class="nt">&lt;/sourceDirectory&gt;</span>
</span><span class='line'>        <span class="nt">&lt;testSourceDirectory&gt;</span>test<span class="nt">&lt;/testSourceDirectory&gt;</span>
</span><span class='line'>        <span class="nt">&lt;resources&gt;</span>
</span><span class='line'>            <span class="nt">&lt;resource&gt;</span>
</span><span class='line'>                <span class="nt">&lt;directory&gt;</span>java<span class="nt">&lt;/directory&gt;</span>
</span><span class='line'>            <span class="nt">&lt;/resource&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/resources&gt;</span>
</span><span class='line'>        <span class="nt">&lt;testResources&gt;</span>
</span><span class='line'>            <span class="nt">&lt;testResource&gt;</span>
</span><span class='line'>                <span class="nt">&lt;directory&gt;</span>test<span class="nt">&lt;/directory&gt;</span>
</span><span class='line'>            <span class="nt">&lt;/testResource&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/testResources&gt;</span>
</span><span class='line'>        <span class="nt">&lt;plugins&gt;</span>
</span><span class='line'>            <span class="nt">&lt;plugin&gt;</span>
</span><span class='line'>                <span class="nt">&lt;groupId&gt;</span>org.apache.maven.plugins<span class="nt">&lt;/groupId&gt;</span>
</span><span class='line'>                <span class="nt">&lt;artifactId&gt;</span>maven-compiler-plugin<span class="nt">&lt;/artifactId&gt;</span>
</span><span class='line'>                <span class="nt">&lt;version&gt;</span>2.3<span class="nt">&lt;/version&gt;</span>
</span><span class='line'>
</span><span class='line'>                <span class="nt">&lt;configuration&gt;</span>
</span><span class='line'>                    <span class="nt">&lt;encoding&gt;</span>UTF-8<span class="nt">&lt;/encoding&gt;</span>
</span><span class='line'>                    <span class="nt">&lt;source&gt;</span>1.6<span class="nt">&lt;/source&gt;</span>
</span><span class='line'>                    <span class="nt">&lt;target&gt;</span>1.6<span class="nt">&lt;/target&gt;</span>
</span><span class='line'>                <span class="nt">&lt;/configuration&gt;</span>
</span><span class='line'>            <span class="nt">&lt;/plugin&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/plugins&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/build&gt;</span>
</span><span class='line'>
</span><span class='line'>    <span class="nt">&lt;dependencies&gt;</span>
</span><span class='line'>        <span class="nt">&lt;dependency&gt;</span>
</span><span class='line'>            <span class="nt">&lt;groupId&gt;</span>junit<span class="nt">&lt;/groupId&gt;</span>
</span><span class='line'>            <span class="nt">&lt;artifactId&gt;</span>junit<span class="nt">&lt;/artifactId&gt;</span>
</span><span class='line'>            <span class="nt">&lt;version&gt;</span>4.4<span class="nt">&lt;/version&gt;</span>
</span><span class='line'>            <span class="nt">&lt;scope&gt;</span>test<span class="nt">&lt;/scope&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/dependency&gt;</span>
</span><span class='line'>        <span class="nt">&lt;dependency&gt;</span>
</span><span class='line'>            <span class="nt">&lt;groupId&gt;</span>ant<span class="nt">&lt;/groupId&gt;</span>
</span><span class='line'>            <span class="nt">&lt;artifactId&gt;</span>ant<span class="nt">&lt;/artifactId&gt;</span>
</span><span class='line'>            <span class="nt">&lt;version&gt;</span>1.7.0<span class="nt">&lt;/version&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/dependency&gt;</span>
</span><span class='line'>        <span class="nt">&lt;dependency&gt;</span>
</span><span class='line'>            <span class="nt">&lt;groupId&gt;</span>wsdl4j<span class="nt">&lt;/groupId&gt;</span>
</span><span class='line'>            <span class="nt">&lt;artifactId&gt;</span>wsdl4j<span class="nt">&lt;/artifactId&gt;</span>
</span><span class='line'>            <span class="nt">&lt;version&gt;</span>1.6.2<span class="nt">&lt;/version&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/dependency&gt;</span>
</span><span class='line'>        <span class="nt">&lt;dependency&gt;</span>
</span><span class='line'>            <span class="nt">&lt;groupId&gt;</span>javax.xml<span class="nt">&lt;/groupId&gt;</span>
</span><span class='line'>            <span class="nt">&lt;artifactId&gt;</span>jaxrpc<span class="nt">&lt;/artifactId&gt;</span>
</span><span class='line'>            <span class="nt">&lt;version&gt;</span>1.1<span class="nt">&lt;/version&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/dependency&gt;</span>
</span><span class='line'>        <span class="nt">&lt;dependency&gt;</span>
</span><span class='line'>            <span class="nt">&lt;groupId&gt;</span>org.eclipse.jdt.core.compiler<span class="nt">&lt;/groupId&gt;</span>
</span><span class='line'>            <span class="nt">&lt;artifactId&gt;</span>ecj<span class="nt">&lt;/artifactId&gt;</span>
</span><span class='line'>            <span class="nt">&lt;version&gt;</span>4.2.2<span class="nt">&lt;/version&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/dependency&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/dependencies&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;/project&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>对于pom.xml文件我们需要注意以下几点：</p>

<ol>
<li>因为下载代码不符合Maven默认的目录结构约定，因此需要修改<code>resources</code>和<code>testResources</code>为<code>java</code>和 <code>test</code>，而不是默认的<code>src/main/resource</code>和<code>src/test/resource</code>,修改<code>sourceDirectory</code>和<code>testSourceDirectory</code>为，<code>java</code>和<code>test</code>,而不是默认的<code>src/main/java</code>和<code>src/test/java</code>.</li>
<li>因为Tomcat源代码的编译需要wsdl4j，jaxrpc,ecj等jar包，因此需要增加相关的依赖。</li>
</ol>


<h3>第五步 创建项目的根pom.xml文件</h3>

<p>这一步我么在Tomcat目录中创建pom.xml文件，这里采用了Maven中聚合的概念.具体过程如下：</p>

<figure class='code'><figcaption><span>create root pom.xml</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">cd</span> ~/develop/java/Tomcat
</span><span class='line'>touch pom.xml
</span></code></pre></td></tr></table></div></figure>


<p>用你喜欢的编辑器打开刚创建的空的pom.xml文件，修改它的内容如下：</p>

<figure class='code'><figcaption><span>~/develop/java/Tomcat/pom.xml</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;project</span> <span class="na">xmlns=</span><span class="s">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="na">xmlns:xsi=</span><span class="s">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>
</span><span class='line'>         <span class="na">xsi:schemaLocation=</span><span class="s">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>
</span><span class='line'>    <span class="nt">&lt;modelVersion&gt;</span>4.0.0<span class="nt">&lt;/modelVersion&gt;</span>
</span><span class='line'>    <span class="nt">&lt;groupId&gt;</span>net.imtiger<span class="nt">&lt;/groupId&gt;</span>
</span><span class='line'>    <span class="nt">&lt;artifactId&gt;</span>tomcat-study<span class="nt">&lt;/artifactId&gt;</span>
</span><span class='line'>    <span class="nt">&lt;name&gt;</span>Tomcat 7.0 Study<span class="nt">&lt;/name&gt;</span>
</span><span class='line'>    <span class="nt">&lt;version&gt;</span>1.0<span class="nt">&lt;/version&gt;</span>
</span><span class='line'>    <span class="nt">&lt;packaging&gt;</span>pom<span class="nt">&lt;/packaging&gt;</span>
</span><span class='line'>
</span><span class='line'>    <span class="nt">&lt;modules&gt;</span>
</span><span class='line'>        <span class="nt">&lt;module&gt;</span>tomcat-7.0.42-sourcecode<span class="nt">&lt;/module&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/modules&gt;</span>
</span><span class='line'><span class="nt">&lt;/project&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>第六步 用IntelliJ IDEA 打开项目根目录的pom.xml</h3>

<p>这一步需要注意，要用IDEA 打开项目根目录的pom.xml文件（也就是~/develop/java/Tomcat/pom.xml）</p>

<h3>第七步 运行Tomcat</h3>

<p>终于到激动人心的时刻了,我们知道任何Java程序都会有一个<code>public static void main(String… args)</code>的入口，Tomcat本身是用Java写的，因此它也不例外，对于Tomcat来说，入口类是<code>org.apache.catalina.startup.Bootstrap</code>,我们找到这个类，然后在IntelliJ IDEA中创建一个运行配置，其中最主要的就是VM options的配置了，在VM options里面填写如下的参数：</p>

<figure class='code'><figcaption><span>VM options</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="o">-</span><span class="n">Dcatalina</span><span class="o">.</span><span class="na">home</span><span class="o">=</span><span class="n">catalina</span><span class="o">-</span><span class="n">home</span> <span class="o">-</span><span class="n">Dcatalina</span><span class="o">.</span><span class="na">base</span><span class="o">=</span><span class="n">catalina</span><span class="o">-</span><span class="n">home</span>
</span><span class='line'><span class="o">-</span><span class="n">Djava</span><span class="o">.</span><span class="na">endorsed</span><span class="o">.</span><span class="na">dirs</span><span class="o">=</span><span class="n">catalina</span><span class="o">-</span><span class="n">home</span><span class="o">/</span><span class="n">endorsed</span> <span class="o">-</span><span class="n">Djava</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">tmpdir</span><span class="o">=</span><span class="n">catalina</span><span class="o">-</span><span class="n">home</span><span class="o">/</span><span class="n">temp</span>
</span><span class='line'><span class="o">-</span><span class="n">Djava</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">logging</span><span class="o">.</span><span class="na">manager</span><span class="o">=</span><span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">juli</span><span class="o">.</span><span class="na">ClassLoaderLogManager</span>
</span><span class='line'><span class="o">-</span><span class="n">Djava</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">logging</span><span class="o">.</span><span class="na">config</span><span class="o">.</span><span class="na">file</span><span class="o">=</span><span class="n">catalina</span><span class="o">-</span><span class="n">home</span><span class="o">/</span><span class="n">conf</span><span class="o">/</span><span class="n">logging</span><span class="o">.</span><span class="na">properties</span>
</span></code></pre></td></tr></table></div></figure>


<p>配置好后，IntelliJ IDEA的配置界面如下：
<img class="center" src="http://imtiger.github.io/images/2013/10/14/vm-options.png"></p>

<p>点击运行，即可看到Tomcat已经启动了，日志已经打到了IntelliJ IDEA的控制台上了，这个时候可以启动浏览器输入<a href="http://127.0.0.1:8080">http://127.0.0.1:8080</a>看看是否启动成功。</p>

<p>接下来，咋们在Bootstrap的main方法中，增加一句<code>System.out.println("Have fun and Enjoy!");</code>,然后运行一下，看看加入的信息是否被打入到了控制台，在笔者的电脑上打印可以看到信息已经输出如下信息：</p>

<figure class='code'><figcaption><span>console log</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Have</span> <span class="n">fun</span> <span class="n">and</span> <span class="n">Enjoy</span><span class="o">!</span>
</span><span class='line'><span class="c1">//ignore other log info</span>
</span><span class='line'><span class="mi">2013</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mi">14</span> <span class="mi">17</span><span class="o">:</span><span class="mi">19</span><span class="o">:</span><span class="mi">35</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">startup</span><span class="o">.</span><span class="na">Catalina</span> <span class="n">start</span>
</span><span class='line'><span class="err">信息</span><span class="o">:</span> <span class="n">Server</span> <span class="n">startup</span> <span class="n">in</span> <span class="mi">908</span> <span class="n">ms</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面就是Tomcat7.0.42源代码在IntelliJ IDEA运行环境搭建的完整的过程。因为笔者日常开发采用的是IntelliJ IDEA,所以本文就只写了IntelliJ IDEA的搭建，但是本文采用了Maven来进行构建的，理论上来说其它IDE，比如Eclipse，只要支持Maven,则可以采用本文同样的方法进行，用Eclipse开发的童鞋，按照本文的步骤理论上也是可以运行起来的。</p>

<p>最后，列出几个笔者在搭建的过程中遇到的几个小问题。</p>

<ol>
<li><code>org.apache.catalina.connector.TestRequest</code>类的<code>prepareRequestBug54984</code>中有两个特殊字符<code>äö</code>,在SVN 迁出的时候变为了乱码，导致Maven在编译的时候编译不过，大家可以复制<code>äö</code>替换乱码的字符即可。</li>
<li><code>CompilationUnit</code>类中的<code>public boolean ignoreOptionalProblems()</code>方法被标记为了@Override，但是其实现的接口<code>ICompilationUnit</code>属于<code>org.eclipse.jdt.core.compiler:ecj</code>，而3.x版本的<code>ICompilationUnit</code>中没有<code>ignoreOptionalProblems</code>方法，4.x的版本中才有，因此为了编译通过，本文采用了4.2.2版本。</li>
</ol>


<p>另外本文最终搭建好的环境，我已经放在Github上了，不想搭建的童鞋可以直接clone一份使用。<a href="https://github.com/imtiger/Tomcat">Github仓库地址</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[电子商务网站的类目设计]]></title>
    <link href="http://imtiger.github.io/blog/2013/10/11/category-design-of-e-commerce-website/"/>
    <updated>2013-10-11T11:07:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2013/10/11/category-design-of-e-commerce-website</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://imtiger.github.io/images/2013/10/11/ejushang.png"></p>

<p>电子商务网站中都会涉及到类目，而类目的设计也是一个电商网站设计的核心之一。本文总结一下总体的设计思路。</p>

<p>首先我们从一个简单的例子说起，假如你要打算买一双<code>耐克40码黑色运动鞋</code>，我们来看看这里面涉及到了哪些关键的信息，其中<code>耐克</code>,<code>40码</code>,<code>黑色</code>,<code>运动鞋</code>是关键的信息，我们再来进一步的分析，耐克是鞋的品牌，40码是鞋的尺寸，黑色是鞋子的颜色，运动鞋是鞋子的分类，对于分类我想大家应该都比较好理解，但是对于品牌（耐克），尺寸（40码），颜色（黑色）我们应该怎么来理解呢？接下来我们就来分析一下如何通过这个具体的例子来抽象出一个公共的模型出来。</p>

<p>在上面的例子中，品牌，尺寸，颜色我们可以抽象出来<code>类目属性</code>的模型，而耐克，40码，黑色我们可以抽象出<code>类目属性值</code>的模型，这样以来我们就知道运动鞋这个类目，它有品牌，尺寸，以及颜色这几个类目属性，而品牌这个类目属性有耐克，阿迪达斯等属性值，尺寸类目属性有38码，39码，40码等类目属性值，而颜色类目属性有黑色，黄色等类目属性值。</p>

<!-- more -->


<p>明白了上面的类目属性和类目属性值的概念以后，咋们再来进一步的分析，我们再来举一个例子，张三买了一双<code>耐克40码黑色的运动鞋</code>，李四买了一双<code>耐克39码蓝色的运动鞋</code>,张三和李四购买的鞋子是同样一款耐克的鞋，只是尺码和颜色不同，从这里我们又可以引入另外两个概念<code>销售属性</code>,<code>关键属性</code>，上面的例子中，尺寸，颜色这些属于销售属性，而品牌就属于关键属性，可能说到这里大家又糊涂了，到底什么样子的属性才算销售属性，什么样子的属性是关键属性呢？要给出这个问题的答案，咋们还得进一步的进行分析，上面说的<code>耐克39码蓝色的运动鞋</code>,<code>耐克40码黑色的运动鞋</code>到底应该怎么抽象，这里需要引入一个线下标准的概念叫<code>SKU（StockKeepintUint）</code>,从字面上面来看sku表示最小存放的单元，怎么理解？当确定了这款运动鞋以后，张三和李四还需要进行进一步的选择，比如要选择尺寸，颜色，才可以确定到底要买哪一款，这里面通过不同的类目属性和类目属性值的组合就可以确定一个SKU，因此构成SKU的属性（比如上例中的尺寸，颜色），我们就将其称之为<code>销售属性</code>,而不影响SKU的属性（比如上例中的品牌），我们可以称之为关键属性（至于关键属性有什么用，我们下面再来讨论。）</p>

<p>接下来，我们来总结一下上面的分析结果，通过上面的分析，我们得到了如下几个模型，每个模型我都会通过简单的代码来标示出最核心的一些属性。</p>

<h3>1. 商品</h3>

<p>商品表示某个可以销售的物品，比如上面所说的耐克的运动鞋就是一个商品。</p>

<figure class='code'><figcaption><span>Product.java</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Product</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 所在的行业标准类目</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">categoryId</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//其它省略</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>2. 类目</h3>

<p>类目也好理解，它是商品的一个分类。</p>

<figure class='code'><figcaption><span>ProductCategory.java</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProductCategory</span><span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//父亲类目</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">ProductCategory</span> <span class="n">parent</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//子类目</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">ProductCategory</span><span class="o">&gt;</span> <span class="n">children</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">ProductCategory</span><span class="o">&gt;();</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="n">String</span> <span class="n">description</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//其它省略</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>3. 属性</h3>

<p>属性模型可以被多个类目共用，比如品牌，尺寸，颜色，很多类目都要用到这个属性，我们抽象出来以后，类目属性仅仅是引用属性即可。</p>

<figure class='code'><figcaption><span>Property.java</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Property</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
</span><span class='line'>    <span class="c1">//属性名称，比如品牌，尺寸，颜色等等</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>4. 属性值</h3>

<p>属性值顾名思义就是上面品牌，尺寸等属性的属性值，例如耐克，38码，黑色，蓝色等等。</p>

<figure class='code'><figcaption><span>Value.java</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Value</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//属性值名称，比如耐克，38码，39码，黑色，蓝色等等 </span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">String</span> <span class="n">valueName</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>5. 类目属性</h3>

<p>类目属性反应了某个类目公共的特征，比如对于鞋子来说就有品牌，尺寸，颜色，对于一个杯子来说可能有容量，颜色等属性。</p>

<figure class='code'><figcaption><span>CategoryProperty.java</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CategoryProperty</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//类目id </span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">categoryId</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//属性id,引用Property类的id.</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">propertyId</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//表示属性类型，分为销售属性和关键属性</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">PropertyType</span> <span class="n">propertyType</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">enum</span> <span class="n">PropertyType</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/* 销售属性 */</span>
</span><span class='line'>    <span class="n">SELL_PROPERTY</span> <span class="o">{</span>
</span><span class='line'>        <span class="nd">@Override</span>
</span><span class='line'>        <span class="kd">public</span> <span class="n">String</span> <span class="nf">getDescription</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="s">&quot;销售属性&quot;</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">},</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/* 关键属性 */</span>
</span><span class='line'>    <span class="n">KEY_PROPERTY</span> <span class="o">{</span>
</span><span class='line'>        <span class="nd">@Override</span>
</span><span class='line'>        <span class="kd">public</span> <span class="n">String</span> <span class="nf">getDescription</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="s">&quot;关键属性&quot;</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">};</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">abstract</span> <span class="n">String</span> <span class="nf">getDescription</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>6. 类目属性值</h3>

<p>类目属性值就是类目属性对应的不同的值，比如尺寸这个鞋子的类目属性就具有38码，39码等，颜色有黄色，黑色等。</p>

<figure class='code'><figcaption><span>CategoryPropertyValue.java</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CategoryPropertyValue</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//没有业务意义，只是数据库主键</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//类目id</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">categoryId</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//属性id,引用Property类的id.</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">propertyId</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//属性值id,引用Value类的id.</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">valueId</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>7. SKU</h3>

<p>SKU是可以确定一个商品的最小的单元，只有确定了SKU，我们才能最终确定某个商品。</p>

<figure class='code'><figcaption><span>StockKeepingUnit.java</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">StockKeepingUnit</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * SKU  ID</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 商品ID，一个商品可以有多个sku</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">productId</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 库存数量，查询sku的时候如果提供仓库则可读出库存数量</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">stockQuantity</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * 价格</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">long</span> <span class="n">price</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * SKU 属性列表</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">SkuProperty</span><span class="o">&gt;</span> <span class="n">skuProperties</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * sku 属性</span>
</span><span class='line'><span class="cm"> * 比如颜色红色或者尺存38码等</span>
</span><span class='line'><span class="cm"> * @author Tiger</span>
</span><span class='line'><span class="cm"> * @version 1.0.0 </span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SkuProperty</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">long</span> <span class="n">skuId</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">propertyId</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">valueId</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过上面的描述，我们清楚了电子商务网站关于商品和类目设计中涉及的主要的模型。接下来我们来看看，这样的设计如何与电子商务网站的搜索相结合。一般电子商务网站都会类似下图所示的搜索界面：<br/>
<img class="center" src="http://imtiger.github.io/images/2013/10/11/e-commerce-category.png"></p>

<p>在上图中所列的其实就是我们上面所说的类目属性以及类目属性值，那么当我们点击其中一个类目属性和类目属性值的时候，怎么去通过搜索检索商品呢？根据上面的描述，我们知道一个商品有多个SKU，而每个SKU又有可能会有多个属性和属性值组合而成，这样的话，我们就可以根据属性和值的Id来对商品进行索引，查询的时候传递属性的id以及属性值的id即可搜索了。我们还是通过上图的例子来简要描述一下。假如我们要买<code>品牌为戴德适用人数为1-2人价格为500-999的汤锅</code>假设品牌的这个属性的id为100，戴德这个属性值的id为200，那么<code>品牌:戴德</code> 这一组属性和属性值就可以表示为<code>100:200</code>,适用人数这个属性的Id为101，而1-2人这个属性值的id为201，那么<code>适用人数:1-2人</code>我们就可以表示为<code>101:201</code>，价格这个属性的id为102，而500-999这个属性值的id为202，那么<code>价格:500-990</code>我们就可以表示为<code>102:202</code>,那么我们的搜索引擎就可以通过100:200,101:201,102:202这3个字符串来建立索引，查询的时候就可以根据同样的字符串来进行查询。</p>

<p>上面我们所说的类目都是指相对稳定的行业标准类目，这种类目结构线下也已经运营了好多年，基本上稳定，不会经常发生变化，标准类目也是面对行业的类目管理人员来说，但是对于电子商务网站的普通用户或者消费者来说，行业的类目可能太过于专业不能理解，这个时候就要引入一个导航类目的概念，导航类目主要目的就是站在消费者的角度来对类目进行划分，那么划分了以后，电商系统中就会存在两套类目：<code>导航类目</code>和<code>行业标准类目</code>，这样做其实也算是体现了软件设计中很重要的一个原则<code>开闭原则</code>，我们通过行业标准类目将商品进行规范话的管理，然后再用导航类目来适应消费者不断变化的需求。说到这里大家可能会想导航类目和行业标准类目又是如何进行关联的呢？接下来我们就来具体分析一下。</p>

<p>假如锅这个类目下面有个炒锅一个子类目，如果随着运营的不断深化，我们发现消费者非常关注炒锅是铁的还是不锈钢的，从行业标准类目的角度来说，铁，不锈钢是炒锅类目材质这个类目属性的两个不同的类目属性值，但是消费者认为铁炒锅是一个类，不锈钢炒锅是另外一个类，那么我们其实就可以做一个导航类目叫<code>铁质炒锅</code>，另外一个导航类目叫<code>不锈钢炒锅</code>，这样用户就可以直接通过类目导航到最终的搜索结果，而不用首先选择炒锅，然后在列表页面选择铁或者不锈钢再来检索了。这个时候不锈钢炒锅对于我们的系统来说，其实是<code>炒锅+材质:不锈钢</code>这个搜索条件的组合，假如炒锅类目id为100，材质属性id为200，不锈钢属性值id为300，那么上面的查询请求，我们就可以转化为<code>100+200:300</code>查询条件，说到这里大家可能已经猜到了我们导航类目应该如何和行业标准类目关联了，其实最简单的方式就是在导航类目中用一个属性保存它关联的后台标准类目id，用另外一个属性保存对应的属性和属性值组合就可以了，当然了你也可以指定一个数据结构来对<code>[类目]* + [属性:属性值]*</code>这中结构进行抽象，然后在导航类目中用一个属性来保存以上的数据结构即可。说到这里我们会发现<code>导航类目</code>其实就是一种对<code>行业标准类目</code>，<code>类目属性</code>和<code>类目属性值</code>的组合。</p>

<p>本文通过一个简单的例子来总结了一下电子商务网站类目设计中相关的一些问题，也欢迎有这方面经验的朋友一起讨论一下。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[月薪15k-20k招聘高级Java软件工程师]]></title>
    <link href="http://imtiger.github.io/blog/2013/09/27/java-engineer-recruitment/"/>
    <updated>2013-09-27T15:29:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2013/09/27/java-engineer-recruitment</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://imtiger.github.io/images/2013/09/27/2013-09-27-01.jpg" width="700" height="350"><br/>
创业一年多，感触颇多，也走过一些弯路，不过总体上还好。随着公司业务的不断扩大，现在需要招聘高级Java软件攻城狮数名，下面简单介绍下：</p>

<p>公司名称: 深圳易居尚网络科技有限公司<br/>
工作地点: 深圳宝安区大宝路41号德丰盛大厦 <br/>
职位名称: 高级Java软件攻城狮<br/>
月薪:    15k-20k</p>

<p>公司介绍: <br/>
我们公司<a href="http://www.ejushang.com">易居尚</a>秉承着<code>让品质走进生活的理念</code>，致力于打造一个品质、高效、便捷的居家用品网络销售平台.咋们公司不打卡，弹性工作制，每天下午有公司大厨做的下午茶，攻城狮童鞋每周可以自由支配20%的工作时间做自己想做的事情，我们技术团队内部有很强互助和知识分享意识（包括技术骚们喜欢的爱情动作片，嘘&hellip;，其他人我不告诉他）当然了还有很多美女和帅哥，想置身互联网和电子商务有理想的的技术骚们，请你加入我们 一起high，<strong>我们不求改变世界，但求超越自我</strong>。也请各位朋友帮忙推荐，推荐成功有神秘礼物相送哦，有意者请联系:<a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#116;&#105;&#x67;&#x65;&#114;&#x2e;&#122;&#104;&#x6f;&#117;&#x40;&#107;&#97;&#114;&#105;&#x71;&#117;&#46;&#99;&#x6f;&#109;">&#x74;&#x69;&#103;&#101;&#x72;&#46;&#x7a;&#104;&#x6f;&#x75;&#64;&#x6b;&#97;&#114;&#x69;&#x71;&#117;&#x2e;&#99;&#111;&#109;</a> 或者留言给我，另外也可以通过<a href="http://weibo.com/xmuzyq">@krq_tiger</a>新浪微博与我取的联系.</p>

<!-- more -->


<p>最后附上招聘要求：<br/>
<strong>岗位职责</strong>：<br/>
1. 业务需求分析；<br/>
2. 模块设计；<br/>
3. 代码编写，测试；<br/>
4. 技术文档编写；<br/>
5. 协调其他成员完成项目;</p>

<p><strong>岗位要求</strong>:<br/>
1. JAVA基础扎实，理解io、多线程、集合等基础框架，对JVM原理有一定的了解；<br/>
2. 3年及以上使用JAVA开发的经验，对于你用过的开源框架，能了解到它的原理和机制；对Spring,ibatis,struts等开源框架熟悉；<br/>
3. 熟悉常见的设计模式以及设计原则；<br/>
4. 熟悉Linux 操作系统以及mysql数据库，对sql优化有一定的经验；<br/>
5. 喜欢去看及尝试最新的技术，追求编写优雅的代码，从技术趋势和思路上能影响技术团队；<br/>
6. 学习能力强，适应能力好，具备耐心/细心的品质；<br/>
7. 四年及以上工作经验。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unix like系统中，查找某个目录下包含特定关键字的文件]]></title>
    <link href="http://imtiger.github.io/blog/2013/09/26/find-files-with-a-keyword-in-a-dir/"/>
    <updated>2013-09-26T22:39:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2013/09/26/find-files-with-a-keyword-in-a-dir</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://imtiger.github.io/images/2013/09/27/2013-09-27-02.jpg"></p>

<p>作为一枚程序猿，咋们经常在工作当中会遇到一种场景：   <br/>
<strong>查找某个目录中包含某个关键字的文件</strong>，那么我们如何来实现这个需求呢？我个人的习惯是如果某个任务经常要执行，那么我会习惯性的写一个脚本，建立一个alias，然后每次需要的时候，直接调用脚本来完成任务，这才是咋们程序猿应该有的工作态度嘛。</p>

<p>好了，废话不多了，咋们直接show code啦。</p>

<!-- more -->




<figure class='code'><figcaption><span>find files in a specific dir with a keyword  </span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'> <span class="c">#!/bin/bash </span>
</span><span class='line'> <span class="c">#find files in a specific dir with a keyword  </span>
</span><span class='line'> <span class="c">#write by tiger </span>
</span><span class='line'> <span class="c">#2013.09.26</span>
</span><span class='line'>
</span><span class='line'><span class="nb">echo</span> -e <span class="s2">&quot;\nThis script finds files in a specific dir with a keyword.\nOK,Please input a keyword:&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="nb">read </span>keyword
</span><span class='line'><span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;$keyword&quot;</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="o">]</span>; <span class="k">then </span>
</span><span class='line'><span class="k">    </span><span class="nb">echo</span>  <span class="s2">&quot;keyword can not be null!\n&quot;</span>
</span><span class='line'>    <span class="nb">exit </span>0
</span><span class='line'><span class="k">fi </span>
</span><span class='line'><span class="k">      </span>
</span><span class='line'><span class="nb">echo</span> <span class="s2">&quot;\nPlease input the dir path:&quot;</span>
</span><span class='line'><span class="nb">read </span>dirPath
</span><span class='line'><span class="k">while</span> <span class="o">[</span> <span class="s2">&quot;$dirPath&quot;</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="o">]</span>
</span><span class='line'><span class="k">do</span>
</span><span class='line'><span class="k">  </span><span class="nb">echo</span>  <span class="s2">&quot;The dir can&#39;t be null,pls input it again&quot;</span>
</span><span class='line'>  <span class="nb">read  </span>dirPath
</span><span class='line'><span class="k">done</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="o">[</span> ! -d <span class="s2">&quot;$dirPath&quot;</span> <span class="o">]</span>; <span class="k">then</span>
</span><span class='line'><span class="k">  </span><span class="nb">echo</span> <span class="s2">&quot;The $dirPath is not exist!\n\n&quot;</span>
</span><span class='line'>  <span class="nb">exit </span>0
</span><span class='line'><span class="k">fi</span>
</span><span class='line'><span class="k">      </span>
</span><span class='line'><span class="nb">echo</span>  <span class="s2">&quot;\n--------------- Find these files ---------------\n&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">fileCount</span><span class="o">=</span>0
</span><span class='line'><span class="nv">files</span><span class="o">=</span><span class="sb">`</span>ls -R <span class="nv">$dirPath</span> 2&gt; /dev/null | grep -v <span class="s1">&#39;^$&#39;</span><span class="sb">`</span>
</span><span class='line'><span class="k">for </span>fileName in <span class="nv">$files</span>
</span><span class='line'><span class="k">do  </span>
</span><span class='line'><span class="k">    </span><span class="nv">temp</span><span class="o">=</span><span class="sb">`</span><span class="nb">echo</span> <span class="nv">$fileName</span> | sed <span class="s1">&#39;s/:.*$//g&#39;</span><span class="sb">`</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;$fileName&quot;</span> !<span class="o">=</span> <span class="s2">&quot;$temp&quot;</span> <span class="o">]</span>; <span class="k">then </span>
</span><span class='line'><span class="k">        </span><span class="nv">currentDir</span><span class="o">=</span><span class="nv">$temp</span>
</span><span class='line'>    <span class="k">else </span>
</span><span class='line'><span class="k">        </span><span class="nv">fileType</span><span class="o">=</span><span class="sb">`</span>file <span class="nv">$currentDir</span>/<span class="nv">$fileName</span> | grep <span class="s2">&quot;text&quot;</span><span class="sb">`</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;$fileType&quot;</span> !<span class="o">=</span> <span class="s2">&quot;&quot;</span> <span class="o">]</span>; <span class="k">then </span>
</span><span class='line'><span class="k">            </span><span class="nv">temp</span><span class="o">=</span><span class="sb">`</span>grep <span class="nv">$keyword</span> <span class="nv">$currentDir</span>/<span class="nv">$fileName</span> 2&gt; /dev/null<span class="sb">`</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;$temp&quot;</span> !<span class="o">=</span> <span class="s2">&quot;&quot;</span> <span class="o">]</span>; <span class="k">then </span>
</span><span class='line'><span class="k">                </span><span class="nb">echo</span> <span class="nv">$currentDir</span>/<span class="nv">$fileName</span>
</span><span class='line'>                <span class="nb">let </span>fileCount++
</span><span class='line'>            <span class="k">fi </span>
</span><span class='line'><span class="k">        fi </span>
</span><span class='line'><span class="k">    fi </span>
</span><span class='line'><span class="k">done </span>
</span><span class='line'><span class="k">if</span> <span class="o">[</span> <span class="nv">$fileCount</span> -gt 0 <span class="o">]</span>;<span class="k">then</span>
</span><span class='line'><span class="k">  </span><span class="nb">echo</span> <span class="s2">&quot;\n\nFiles Total: $fileCount&quot;</span>
</span><span class='line'>  <span class="nb">echo</span> <span class="s2">&quot;\nFind Finished!\n&quot;</span>
</span><span class='line'><span class="k">else</span>
</span><span class='line'><span class="k">  </span><span class="nb">echo</span> <span class="s2">&quot;No files found!&quot;</span>
</span><span class='line'><span class="k">fi</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA['美剧英语每日一句' iOS app（已开源）]]></title>
    <link href="http://imtiger.github.io/blog/2013/09/03/happyenglish-ios-app/"/>
    <updated>2013-09-03T15:28:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2013/09/03/happyenglish-ios-app</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://imtiger.github.io/images/2013/09/03/happyenglish.png"><br/>
学习ios开发，自己做了个学习英语的iOS app，app里面的英文资料全部来自微信公共账号&#8221;美剧英语每日一句(id:<code>followmeapp</code>)&ldquo;，微信公共账号每天由托福雅思名师<a href="http://weibo.com/myajia"><code>@吴彧Allen</code></a>更新一句常用地道的美剧英语，作为一枚软件攻城狮，学习英语是必须的嘛,只要每天坚持学一句，积累下来，还愁英语口语水平不提高吗？<br/>
<a href="https://itunes.apple.com/us/app/happyenglish/id669934718?ls=1&amp;amp;mt=8"><code>点我下载app</code></a></p>

<!-- more -->


<p>这个app刚开始只是方便自己学习英语用的，做完了以后，经过公共账号维护者<a href="http://weibo.com/myajia"><code>@吴彧Allen</code></a>的许可，分享出来给大家伙一起用用，欢迎各位使用，有什么意见也可以提提额。</p>

<p>另外本app已经在github上面开源，地址：<a href="https://github.com/imtiger/HappyEnglish">HappyEnglish</a>. 对本app感兴趣的同学可以一起参与一起完善它。</p>

<p>如果大家想关注微信公共账号，可以扫描如下二维码：<br/>
<img src="http://imtiger.github.io/images/2013/09/03/weixin.jpg"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实例分析Java Class文件的结构-实践篇]]></title>
    <link href="http://imtiger.github.io/blog/2013/01/30/java-class-file-format-demo/"/>
    <updated>2013-01-30T12:16:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2013/01/30/java-class-file-format-demo</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://imtiger.github.io/images/2013/01/30/java-logo.jpg" width="500" height="300"><br/>
在<a href="http://imtiger.github.io/blog/2013/01/30/java-class-file-format/"><code>实例分析Java Class文件的结构-理论篇</code></a>一文中，我们说了Java Class文件结构的理论知识，接下来我们来通过一个具体的例子来理论结合实践的学习一下。
首先我们有一个TestClass类，代码如下：</p>

<figure class='code'><figcaption><span>TestClass.java </span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'> <span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">ejushang</span><span class="o">.</span><span class="na">TestClass</span><span class="o">;</span>
</span><span class='line'> <span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestClass</span> <span class="kd">implements</span> <span class="n">Super</span><span class="o">{</span>
</span><span class='line'>
</span><span class='line'>         <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">staticVar</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>         <span class="kd">private</span> <span class="kt">int</span> <span class="n">instanceVar</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>         <span class="kd">public</span> <span class="kt">int</span> <span class="nf">instanceMethod</span><span class="o">(</span><span class="kt">int</span> <span class="n">param</span><span class="o">){</span>
</span><span class='line'>             <span class="k">return</span> <span class="n">param</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
</span><span class='line'>         <span class="o">}</span>
</span><span class='line'>
</span><span class='line'> <span class="o">}</span>
</span><span class='line'>
</span><span class='line'> <span class="kd">interface</span> <span class="nc">Super</span><span class="o">{</span> <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过jdk1.6.0_37的javac 编译后的TestClass.java对应的TestClass.class的二进制结构如下图所示：</p>

<!-- more -->


<p><img class="center" src="http://imtiger.github.io/images/2013/01/30/test-class-file.png"></p>

<ol>
<li><p>魔数<br/>
从Class的文件结构我们知道，刚开始的4个字节是魔数，上图中从地址00000000h-00000003h的内容就是魔数，从上图可知Class的文件的魔数是0xCAFEBABE。</p></li>
<li><p>主次版本号 <br/>
接下来的4个字节是主次版本号，由上图可知从00000004h-00000005h对应的是0x0000,因此Class的minor_version为0x0000,从00000006h-00000007h对应的内容为0x0032,因此Class文件的major_version版本为0x0032,这正好就是jdk1.6.0不带target参数编译后的Class对应的主次版本。</p></li>
<li><p>常量池的数量 <br/>
接下来的2个字节从00000008h-00000009h表示常量池的数量，由上图可以知道其值为0x0018，十进制为24个,但是对于常量池的数量需要明确一点，常量池的数量是constant_pool_count-1，为什么减一，是因为索引0表示class中的数据项不引用任何常量池中的常量。</p></li>
<li><p>常量池
我们上面说了常量池中有不同类型的常量，下面就来看看TestClass.class的第一个常量，我们知道每个常量都有一个u1类型的tag标识来表示常量的类型，上图中0000000ah处的内容为0x0A，转换成二级制是10，由上面的关于常量类型的描述可知tag为10的常量是Constant_Methodref_info,而Constant_Methodref_info的结够如下图所示：
<img class="center" src="http://imtiger.github.io/images/2013/01/30/constant-methodref-info.png"> <br/>
<code>class_index</code>指向常量池中类型为CONSTANT_Class_info的常量，从TestClass的二进制文件结构中可以看出class_index的值为0x0004（地址为0000000bh-0000000ch)，也就是说指向第四个常量。 <br/>
<code>name_and_type_index</code>指向常量池中类型为CONSTANT_NameAndType_info常量。从上图可以看出name_and_type_index的值为0x0013，表示指向常量池中的第19个常量.接下来又可以通过同样的方法来找到常量池中的所有常量。不过JDK提供了一个方便的工具可以让我们查看常量池中所包含的常量。通过javap -verbose TestClass 即可得到所有常量池中的常量，截图如下：<br/>
<img class="center" src="http://imtiger.github.io/images/2013/01/30/test-class-javap.png"> <br/>
从上图我们可以清楚的看到，TestClass中常量池有24个常量，不要忘记了第0个常量，因为第0个常量被用来表示 Class中的数据项不引用任何常量池中的常量。从上面的分析中我们得知TestClass的第一个常量表示方法，其中class_index指向的第四个常量为java/lang/Object，name_and_type_index指向的第19个常量值为<init>:()V,从这里可以看出第一个表示方法的常量表示的是java编译器生成的实例构造器方法。通过同样的方法可以分析常量池的其它常量。OK，分析完常量池，我们接下来再分析下access_flags。</p></li>
<li>u2 access_flags
表示类或者接口方面的访问信息，比如Class表示的是类还是接口，是否为public,static，final等。具体访问标示的含义之前已经说过了，下面我们就来看看TestClass的访问标示。Class的访问标示是从0000010dh-0000010e，其值为0x0021，根据前面说的各种访问标示的标志位，我们可以知道：0x0021=0x0001|0x0020 也即ACC_PUBLIC 和 ACC_SUPER为真，其中ACC_PUBLIC大家好理解，ACC_SUPER是jdk1.2之后编译的类都会带有的标志。</li>
<li><p>u2 this_class <br/>
表示类的索引值，用来表示类的全限定名称，类的索引值如下图所示：<br/>
<img class="center" src="http://imtiger.github.io/images/2013/01/30/class-index.png"><br/>
从上图可以清楚到看到，类索引值为0x0003，对应常量池的第三个常量，通过javap的结果，我们知道第三个常量为CONSTANT_Class_info类型的常量，通过它可以知道类的全限定名称为：com/ejushang/TestClass/TestClass</p></li>
<li><p>u2 super_class <br/>
表示当前类的父类的索引值，索引值指向常量池中类型为CONSTANT_Class_info的常量，父类的索引值如下图所示，其值为0x0004,查看常量池的第四个常量，可知TestClass的父类的全限定名称为：java/lang/Object.
<img class="center" src="http://imtiger.github.io/images/2013/01/30/super-class.png"></p></li>
<li><p>interfaces_count 、 interfaces[interfaces_count]<br/>
表示接口数量以及具体的每一个接口，TestClass的接口数量以及接口如下图所示，其中0x0001表示接口数量为1，而0x0005表示接口在常量池的索引值，找到常量池的第五个常量，其类型为CONSTANT_Class_info，其值为：com/ejushang/TestClass/Super
<img class="center" src="http://imtiger.github.io/images/2013/01/30/interface-count.png"></p></li>
<li><p>fields_count、field_info <br/>
fields_count表示类中field_info表的数量，而field_info表示类的实例变量和类变量，这里需要注意的是field_info不包含从父类继承过来的字段，field_info的结构如下图所示：<br/>
<img class="center" src="http://imtiger.github.io/images/2013/01/30/field-info.png"><br/>
<code>access_flags</code>表示字段的访问标识，比如public,private,protected，static,final等，access_flags的取值如下图所示：<br/>
<img class="center" src="http://imtiger.github.io/images/2013/01/30/access-flags.png"><br/>
<code>name_index</code> 和 <code>descriptor_index</code>都是常量池的索引值，分别表示字段的名称和字段的描述符，字段的名称容易理解，但是字段的描述符如何理解呢？其实在JVM 规范中，对于字段的描述符规定如下图所示：<br/>
<img class="center" src="http://imtiger.github.io/images/2013/01/30/field-descriptor.png"><br/>
其中大家需要关注一下上图最后一行，它表示的是对一维数组的描述符，对于String[][]的描述符将是[[ Ljava/lang/String,而对于int[][]的描述符为[[I。接下来的attributes_count以及attribute_info分别表示属性表的数量以及属性表。<br/>
下面我们还是以上面的TestClass为例，来看看TestClass的字段表吧。首先我们来看一下字段的数量，TestClass的字段的数量如下图所示：<br/>
<img class="center" src="http://imtiger.github.io/images/2013/01/30/testclass-field-count.png"><br/>
从上图中可以看出TestClass有两个字段，查看TestClass的源代码可知，确实也只有两个字段，接下来我们看看第一个字段，我们知道第一个字段应该为private int staticVar,它在Class文件中的二进制表示如下图所示：<br/>
<img class="center" src="http://imtiger.github.io/images/2013/01/30/field-one.png"><br/>
其中0x001A表示访问标示，通过查看access_flags表可知，其为ACC_PRIVATE,ACC_STATIC,ACC_FINAL,接下来0x0006和0x0007分别表示常量池中第6和第7个常量，通过查看常量池可知，其值分别为：staticVar和I，其中staticVar为字段名称，而I为字段的描述符，通过上面对描述符的解释，I所描述的是int类型的变量，接下来0x0001表示staticVar这个字段表中的属性表的数量，从上图可以staticVar字段对应的属性表有1个，0x0008表示常量池中的第8个常量，查看常量池可以得知此属性为ConstantValue属性，而ConstantValue属性的格式如下图所示：<br/>
<img class="center" src="http://imtiger.github.io/images/2013/01/30/constantvalue-attribute.png"><br/>
其中<code>attribute_name_index</code>表述属性名的常量池索引，本例中为ConstantValue，而ConstantValue的<code>attribute_length</code>固定长度为2，而<code>constantValue_index</code>表示常量池中的引用，本例中，其中为0x0009，查看第9个常量可以知道，它表示一个类型为CONSTANT_Integer_info的常量，其值为0。<br/>
上面说完了<code>private static final int staticVar=0</code>，下面我们接着说一下TestClass的<code>private int instanceVar=0</code>,在本例中对instanceVar的二进制表示如下图所示：
<img class="center" src="http://imtiger.github.io/images/2013/01/30/field-two.png"><br/>
其中0x0002表示访问标示为ACC_PRIVATE,0x000A表示字段的名称，它指向常量池中的第10个常量，查看常量池可以知道字段名称为instanceVar，而0x0007表示字段的描述符，它指向常量池中的第7个常量，查看常量池可以知道第7个常量为I，表示类型为instanceVar的类型为I，最后0x0000表示属性表的数量为0.</p></li>
<li>methods_count 、method_info <br/>
methods_count表示方法的数量，而method_info表示的方法表，其中方法表的结构如下图所示：<br/>
<img class="center" src="http://imtiger.github.io/images/2013/01/30/method-info.png">  <br/>
从上图可以看出method_info和field_info的结构是很类似的，方法表的access_flag的所有标志位以及取值如下图所示：<br/>
<img class="center" src="http://imtiger.github.io/images/2013/01/30/access-flags.png">  <br/>
其中<code>name_index</code>和<code>descriptor_index</code>表示的是方法的名称和描述符，他们分别是指向常量池的索引。这里需要结解释一下方法的描述符，方法的描述符的结构为：<code>（参数列表）返回值</code>，比如<code>public int instanceMethod(int param)</code>的描述符为：<code>（I）I</code>，表示带有一个int类型参数且返回值也为int类型的方法，接下来就是属性数量以及属性表了，方法表和字段表虽然都有属性数量和属性表，但是他们里面所包含的属性是不同。接下来我们就以TestClass来看一下方法表的二进制表示。首先来看一下方法表数量，截图如下：
<img class="center" src="http://imtiger.github.io/images/2013/01/30/method-count.png"><br/>
从上图可以看出方法表的数量为0x0002表示有两个方法，接下来我们来分析第一个方法，我们首先来看一下TestClass的第一个方法的<code>access_flag</code>，<code>name_index</code>,<code>descriptor_index</code>，截图如下：<br/>
<img class="center" src="http://imtiger.github.io/images/2013/01/30/method-one-info.png"><br/>
从上图可以知道access_flags为0x0001，从上面对access_flags标志位的描述，可知方法的access_flags的取值为ACC_PUBLIC,name_index为0x000B，查看常量池中的第11个常量，知道方法的名称为<init>，0x000C表示descriptor_index表示常量池中的第12常量，其值为()V,表示<init>方法没有参数和返回值，其实这是编译器自动生成的实例构造器方法。接下来的0x0001表示<init>方法的方法表有1个属性，属性截图如下：
<img class="center" src="http://imtiger.github.io/images/2013/01/30/init-method-info.png"> <br/>
从上图可以看出0x000D对应的常量池中的常量为Code,表示的方法的Code属性，所以到这里大家应该明白方法的那些代码是存储在Class文件方法表中的属性表中的Code属性中。接下来我们在分析一下Code属性，Code属性的结构如下图所示：
<img class="center" src="http://imtiger.github.io/images/2013/01/30/code-attribute.png"><br/>
其中<code>attribute_name_index</code>指向常量池中值为Code的常量，<code>attribute_length</code>的长度表示Code属性表的长度（这里需要注意的时候长度不包括attribute_name_index和attribute_length的6个字节的长度）。<br/>
<code>max_stack</code>表示最大栈深度，虚拟机在运行时根据这个值来分配栈帧中操作数的深度.<br/>
<code>max_locals</code>代表了局部变量表的存储空间,它的单位为slot，slot是虚拟机为局部变量分配内存的最小单元，在运行时，对于不超过32位类型的数据类型，比如byte,char,int等占用1个slot，而double和Long这种64位的数据类型则需要分配2个slot，另外max_locals的值并不是所有局部变量所需要的内存数量之和，因为slot是可以重用的，当局部变量超过了它的作用域以后，局部变量所占用的slot就会被重用。 <br/>
<code>code_length</code>代表了字节码指令的数量，而code表示的时候字节码指令，从上图可以知道code的类型为u1,一个u1类型的取值为0x00-0xFF,对应的十进制为0-255，目前虚拟机规范已经定义了200多条指令。<br/>
<code>exception_table_length</code>以及<code>exception_table</code>分别代表方法对应的异常信息。<br/>
<code>attributes_count</code>和<code>attribute_info</code>分别表示了Code属性中的属性数量和属性表，从这里可以看出Class的文件结构中，属性表是很灵活的，它可以存在于Class文件，方法表，字段表以及Code属性中。
接下来我们继续以上面的例子来分析一下，从上面init方法的Code属性的截图中可以看出，属性表的长度为0x00000026,max_stack的值为0x0002,max_locals的取值为0x0001,code_length的长度为0x0000000A，那么00000149h-00000152h为字节码，接下来exception_table_length的长度为0x0000，而attribute_count的值为0x0001，00000157h-00000158h的值为0x000E,它表示常量池中属性的名称，查看常量池得知第14个常量的值为LineNumberTable，LineNumberTable用于描述java源代码的行号和字节码行号的对应关系，它不是运行时必需的属性,接下来我们再看一下LineNumberTable的结构如下图所示：</li>
</ol>


<blockquote><p>如果通过-g:none的编译器参数来取消生成LineNumberTable的话，最大的影响就是异常发生的时候，堆栈中不能显示出出错的行号，调试的时候也不能按照源代码来设置断点，</p></blockquote>

<p><img class="center" src="http://imtiger.github.io/images/2013/01/30/linenumbertable-attribute.png"><br/>
其中<code>attribute_name_index</code>上面已经提到过，表示常量池的索引，<code>attribute_length</code>表示属性长度，而<code>start_pc</code>和<code>line_number</code>分表表示字节码的行号和源代码的行号。本例中LineNumberTable属性的字节流如下图所示：
<img class="center" src="http://imtiger.github.io/images/2013/01/30/testclass-linenumbertable.png"><br/>
上面分析完了TestClass的第一个方法，通过同样的方式我们可以分析出TestClass的第二个方法，截图如下：<br/>
<img class="center" src="http://imtiger.github.io/images/2013/01/30/method-two.png">
其中<code>access_flags</code>为0x0001,<code>name_index</code>为0x000F,<code>descriptor_index</code>为0x0010，通过查看常量池可以知道此方法为<code>public int instanceMethod(int param)</code>方法。通过和上面类似的方法我们可以知道instanceMethod的Code属性为下图所示：<br/>
<img class="center" src="http://imtiger.github.io/images/2013/01/30/method-two-code-attribute.png"></p>

<p>最后我们来分析一下，Class文件的属性，从00000191h-00000199h为Class文件中的属性表，其中0x0011表示属性的名称，查看常量池可以知道属性名称为SourceFile，我们再来看看SourceFile的结构如下图所示：    <br/>
<img class="center" src="http://imtiger.github.io/images/2013/01/30/sourcefile-attribute.png"><br/>
其中<code>attribute_length</code>为属性的长度，<code>sourcefile_index</code>指向常量池中值为源代码文件名称的常量，在本例中SourceFile属性截图如下：
<img class="center" src="http://imtiger.github.io/images/2013/01/30/test-class-sourcefile.png"><br/>
其中<code>attribute_length</code>为0x00000002表示长度为2个字节，而<code>soucefile_index</code>的值为0x0012,查看常量池的第18个常量可以知道源代码文件的名称为TestClass.java</p>

<p>通过<a href="http://imtiger.github.io/blog/2013/01/30/java-class-file-format/"><code>实例分析Java Class文件的结构-理论篇</code></a>和<a href="http://imtiger.github.io/blog/2013/01/30/java-class-file-format-demo/"><code>实例分析Java Class文件的结构-实践篇</code></a>两篇文章，我们采用理论和实践结合方式来学习了Class 文件的格式。掌握它的格式以后，我们也可以试着写个Java Class类文件的反编译器了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实例分析Java Class文件的结构-理论篇]]></title>
    <link href="http://imtiger.github.io/blog/2013/01/30/java-class-file-format/"/>
    <updated>2013-01-30T10:33:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2013/01/30/java-class-file-format</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://imtiger.github.io/images/2013/01/30/java-logo.jpg" width="500" height="300">  <br/>
今天把之前在Evernote中的笔记重新整理了一下，发上来供对java class 文件结构的有兴趣的同学参考一下。</p>

<p>学习Java的朋友应该都知道Java从刚开始的时候就打着平台无关性的旗号，说“一次编写，到处运行”，其实说到无关性，Java平台还有另外一个无关性那就是语言无关性，要实现语言无关性，那么Java体系中的class的文件结构或者说是字节码就显得相当重要了，其实Java从刚开始的时候就有两套规范，一个是Java语言规范，另外一个是Java虚拟机规范，Java语言规范只是规定了Java语言相关的约束以及规则，而虚拟机规范则才是真正从跨平台的角度去设计的。今天我们就以一个实际的例子来看看，到底Java中一个Class文件对应的字节码应该是什么样子。 这篇文章将首先总体上阐述一下Class到底由哪些内容构成，然后再用一个实际的Java类入手去分析class的文件结构。</p>

<!-- more -->


<p></p>

<p>在继续之前，我们首先需要明确如下几点：<br/>
1. Class文件是有8位为基础的字节流构成的，这些字节流之间都严格按照规定的顺序排列，并且字节之间不存在任何空隙，对于超过8位的数据，将按照Big-Endian的顺序存储的，也就是说高位字节存储在低的地址上面，而低位字节存储到高地址上面，其实这也是class文件要跨平台的关键，因为PowerPC架构的处理采用Big-Endian的存储顺序，而x86系列的处理器则采用Little-Endian的存储顺序，因此为了Class文件在各中处理器架构下保持统一的存储顺序，虚拟机规范必须对起进行统一。    <br/>
2. Class文件结构采用类似C语言的结构体来存储数据的，主要有两类数据项，无符号数和表，无符号数用来表述数字，索引引用以及字符串等，比如u1,u2,u4,u8分别代表1个字节，2个字节，4个字节，8个字节的无符号数，而表是有多个无符号数以及其它的表组成的复合结构。可能大家看到这里对无符号数和表到底是上面也不是很清楚，不过不要紧，等下面实例的时候，我会再以实例来解释。</p>

<p>明确了上面的两点以后，我们接下来后来看看Class文件中按照严格的顺序排列的字节流都具体包含些什么数据：<br/>
<img class="center" src="http://imtiger.github.io/images/2013/01/30/java-class-file-format.png"></p>

<p>  <center>（上图来自The Java Virtual Machine Specification Java SE 7 Edition) </center></p>

<p>在看上图的时候，有一点我们需要注意，比如cp_info，cp_info表示常量池，上图中用constant_pool[constant_pool_count-1]的方式来表示常量池有constant_pool_count-1个常量，它这里是采用数组的表现形式，但是大家不要误以为所有的常量池的常量长度都是一样的，其实这个地方只是为了方便描述采用了数组的方式，但是这里并不像编程语言那里，一个int型的数组，每个int长度都一样.明确了这一点以后，我们再回过头来看看上图中每一项都具体代表了什么含义。</p>

<ol>
<li>u4 magic 表示魔数，并且魔数占用了4个字节，魔数到底是做什么的呢？它其实就是表示一下这个文件的类型是一个Class文件，而不是一张JPG图片，或者AVI的电影。而Class文件对应的魔数是0xCAFEBABE.</li>
<li>u2 minor_version 表示Class文件的次版本号，并且此版本号是u2类型的无符号数表示。</li>
<li>u2 major_version 表示Class文件的主版本号，并且主版本号是u2类型的无符号数表示。major_version和minor_version主要用来表示当前的虚拟机是否接受当前这种版本的Class文件。不同版本的Java编译器编译的Class文件对应的版本是不一样的。高版本的虚拟机支持低版本的编译器编译的Class文件结构。比如Java SE 6.0对应的虚拟机支持Java SE 5.0的编译器编译的Class文件结构，反之则不行。</li>
<li>u2 constant_pool_count 表示常量池的数量。这里我们需要重点来说一下常量池是什么东西，请大家不要与Jvm内存模型中的运行时常量池混淆了，Class文件中常量池主要存储了字面量以及符号引用，其中字面量主要包括字符串，final常量的值或者某个属性的初始值等等，而符号引用主要存储类和接口的全限定名称，字段的名称以及描述符，方法的名称以及描述符，这里名称可能大家都容易理解，至于描述符的概念，放到下面说字段表以及方法表的时候再说。另外大家都知道Jvm的内存模型中有堆，栈，方法区，程序计数器构成，而方法区中又存在一块区域叫运行时常量池，运行时常量池中存放的东西其实也就是编译器产生的各种字面量以及符号引用，只不过运行时常量池具有动态性，它可以在运行的时候向其中增加其它的常量进去，最具代表性的就是String的intern方法。</li>
<li>cp_info 表示常量池，这里面就存储了上面说的各种各样的字面量和符号引用。放到常量池的中数据项在<code>The Java Virtual Machine Specification Java SE 7 Edition</code> 中一共有14个常量，每一种常量都是一个表，并且每种常量都用一个公共的部分tag来表示是哪种类型的常量。下面分别简单描述一下,具体细节等到后面的实例中我们再细化。 <br/>
CONSTANT_Utf8_info      tag标志位为1,   UTF-8编码的字符串  <br/>
CONSTANT_Integer_info  tag标志位为3， 整形字面量       <br/>
CONSTANT_Float_info     tag标志位为4， 浮点型字面量    <br/>
CONSTANT_Long_info     tag标志位为5， 长整形字面量 <br/>
CONSTANT_Double_info  tag标志位为6， 双精度字面量 <br/>
CONSTANT_Class_info    tag标志位为7， 类或接口的符号引用<br/>
CONSTANT_String_info    tag标志位为8，字符串类型的字面量<br/>
CONSTANT_Fieldref_info  tag标志位为9,  字段的符号引用 <br/>
CONSTANT_Methodref_info  tag标志位为10，类中方法的符号引用<br/>
CONSTANT_InterfaceMethodref_info tag标志位为11, 接口中方法的符号引用<br/>
CONSTANT_NameAndType_info tag 标志位为12，字段和方法的名称以及类型的符号引用</li>
<li>u2 access_flags 表示类或者接口的访问信息，具体如下图所示：
<img class="center" src="http://imtiger.github.io/images/2013/01/30/class-access-and-property-modifiers.png"></li>
<li>u2 this_class 表示类的常量池索引，指向常量池中CONSTANT_Class_info的常量</li>
<li>u2 super_class 表示超类的索引，指向常量池中CONSTANT_Class_info的常量</li>
<li>u2 interface_counts 表示接口的数量</li>
<li>u2 interface[interface_counts]表示接口表，它里面每一项都指向常量池中CONSTANT_Class_info常量</li>
<li>u2 fields_count 表示类的实例变量和类变量的数量</li>
<li>field_info fields[fields_count]表示字段表的信息，其中字段表的结构如下图所示：<br/>
<img class="center" src="http://imtiger.github.io/images/2013/01/30/field-info.png"><br/>
上图中access_flags表示字段的访问标示，比如字段是public,private，protect 等，name_index表示字段名 称，指向常量池中类型是CONSTANT_UTF8_info的常量，descriptor_index表示字段的描述符，它也指向常量池中类型为CONSTANT_UTF8_info的常量，attributes_count表示字段表中的属性表的数量，而属性表是则是一种用与描述字段，方法以及类的属性的可扩展的结构，不同版本的Java虚拟机所支持的属性表的数量是不同的。</li>
<li>u2 methods_count表示方法表的数量</li>
<li>method_info 表示方法表，方法表的具体结构如下图所示：
<img class="center" src="http://imtiger.github.io/images/2013/01/30/method-info.png"><br/>
其中access_flags表示方法的访问标示，name_index表示名称的索引，descriptor_index表示方法的描述符，attributes_count以及attribute_info类似字段表中的属性表，只不过字段表和方法表中属性表中的属性是不同的，比如方法表中就Code属性，表示方法的代码，而字段表中就没有Code属性。其中具体Class中到底有多少种属性，等到Class文件结构中的属性表的时候再说说。</li>
<li>attribute_count表示属性表的数量，说到属性表，我们需要明确以下几点：<br/>
1.属性表存在于Class文件结构的最后，字段表，方法表以及Code属性中，也就是说属性表中也可以存在属性表。<br/>
2.属性表的长度是不固定的，不同的属性，属性表的长度是不同的。</li>
</ol>


<p>本篇文章描述了Java Class文件方面的理论知识，下面一篇文章将通过一个实际的例子来详细解释一下Class文件内部到底长什么样。具体请参考本系列的第二篇文章：<br/>
<a href="http://imtiger.github.io/blog/2013/01/30/java-class-file-format-demo/">实例分析Java Class文件的结构-实践篇</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2012年创业回顾与总结]]></title>
    <link href="http://imtiger.github.io/blog/2013/01/22/2012-summary/"/>
    <updated>2013-01-22T11:44:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2013/01/22/2012-summary</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://imtiger.github.io/images/2013/01/22/2012-summary.jpg" width="450" height="350">
自从用了Evernote以后，发现自己写博客的频率变低了好多，很多时候都是自己直接在Evernote里面直接写笔记，很少来写博客了。不过今天还是把自己前几天在Evernote写的2012年度总结贴出来和大家分享以下，一起交流和进步。</p>

<p>从2012年3月底辞职创业到现在已经10个月了，在过去的10个月里面，我们取得了一些成果，另外一方面我们也犯过一些错误。下面我主要从公司以及个人两个方面对过去的10个月做一下回顾和总结。</p>

<!-- more -->


<p></p>

<h1>1.公司方面：</h1>

<p>公司方面我从业务团队和技术团队的去回顾一下我们前期所遇到的一些问题。</p>

<h2>1.1 业务团队：</h2>

<p>首先我来总结一下今年公司运营团队遇到的问题，主要列举如下：</p>

<ol>
<li>做事目标性不够强
做事之前没有明确的目标，每次遇到事情就是开始搞，也没有指定明确的目标，或者说目标指定的不合理，导致最终指定的目标和现实不符合，总体来说运营活动进展的有些盲目。</li>
<li>做事的结果没有沉淀
做完事情了最终的结果却没有去经常性的总结，有时候事情的结果好，也没有去分析结果为什么好，有时候事情结果不好也没有去想为什么结果不好，总之就是思考的还不够多。</li>
</ol>


<h2>1.2 技术团队：</h2>

<p>今年技术团队主要完成了自己<a href="http://www.ejushang.com">B2C网站</a>的开发,朋友可以去围观下哈，多提提提意见,在开发的过程中我们主要遇到了如下问题：</p>

<ol>
<li><p>网站视觉改版频繁<br/>
这是今年技术团队最严重的一个问题，先后改了3次页面视觉，导致这个主要有两个原因，第一个是因为视觉设计师的经验相对欠缺，另外一个就是我们思维还是不够精益，老是觉得自己要一个有品质，便捷，功能完善的网站，这样不仅延长了项目周期，更重要的发现有时候某些事情是矛盾的，不可能同时都实现的，不过基本上现在我们都改变了思路，采用精益创业的方式进行。</p>

<blockquote><p>这里强烈推荐创业者都看下<a href="http://book.douban.com/subject/11516567/">&lt;&lt;四步创业法>></a>和<a href="http://book.douban.com/subject/10945606/">&lt;&lt;精益创业>></a></p></blockquote></li>
<li><p>缺少总体设计
技术团队今年遇到的另外一个问题就是缺少了总体的设计，在写代码之前没有进行总体设计，都是讨论完了业务以后，我们就直接开始编码了，另外由于前期自己没想清楚业务需求经常改变，所以导致最终代码结构混乱，写完以后虽然功能是做完了，但是不得不花大量的力气去重构代码。</p></li>
<li><p>把问题想的过于复杂</p></li>
</ol>


<p>今年这个是技术团队遇到的另外一个问题，比如关于退换货的问题，前期考虑了订单的各种状态以及退单的各种状态，并且所有的状态都有系统自动审核和判断，并且设计到物流的一系列问题，最终发现自己想的太复杂了，最后还是采用某些状态让客服介入处理的折中处理方案，这样虽然增加了人力成本，但是总体上来说更加符合我们目前创业的现状。</p>

<p>其实做为一个创业公司，出现问题并不可怕，可怕的明明有问题自个却不知道，因此我宁愿清醒的痛着，也不愿意麻木的睡着，知道了公司的问题，2013年我们按照正确的方式去改变就好。</p>

<p>不过虽然我们遇到了很多问题，但是总体上我们还是取得了值得自己肯定的成绩，这主要体现在以下几个方面：</p>

<ol>
<li><p>我们的商品拍摄团队越来越专业
在经过了几个月的反复修改和讨论后，摄影团队对我们的主营类目的拍摄越来越到点子上了，思路也感觉越来越清晰了。</p></li>
<li><p>我们的设计师团队越来越来专业
2012年3月底的时候，我们设计师团队没有形成一个标准，也都是在摸索和尝试，经过几个月的努力，我们已经对我们主营的类目有了标准的详情页面的模板，这样无论是天猫旗舰店，京东旗舰店以及我们自己的网站都形成统一的设计风格，给我们的用户一个统一的体验，也更有利于E居尚渠道品牌的推广。</p></li>
<li><p>我们的开发团队做事情越来越规范
经过这几个月的努力，我们的网站终于在2012年11月19日完成了第一版的对外发布，在这个过程中开发团队做事情也越来越规范了，团队分工也越来越明确了并且越来越默契了哈哈，同时更让我开心的是开发团队的成员个人能力都觉得有了进一步的提升。（其实说到这里，我不得不吐槽下，一个不懂技术的管理者可能觉得付薪水给技术人员，就要让你每天8小时，每周5天都要非常饱和的做工作相关的事情，如果哪天发现你自己没事做，非要没事也要找点事情做，但是我做为一个技术人员，我觉得这样的思路是有问题的，一个技术人员如果每天都做着同样的事情，即使你每天工作24小时又能怎么样，同样的代码写个几百遍有能怎么样，所以在我们技术团队，我一般容许工程师每周话10%-20%的时间去学习也行，参加开源项目也行，让大家去总结去学习，我一直相信团队一方面要看执行力更重要的还是要看团队的成长。）</p></li>
</ol>


<h1>2 个人方面：</h1>

<p>个人方面我主要从我自己对创业的理解，以及对产品，技术，管理几个方面的一些体会，下面就分别对期进行一下总结。</p>

<h2>2.1.创业是什么？</h2>

<p>在说创业是什么的时候，我从以下两个方面来说说创业是什么？</p>

<ol>
<li><p>为什么创业？<br/>
说起为什么创业，这要从淘宝说起，我记得两年前第一次在淘宝百淘培训，我对所有培训的同事说我来淘宝的目的就是为了认识更多的人以后出去自己创业，我也非常庆幸，正是那个时候我认识我的创业搭档，他是一个有11年线下零售行业运营经验经验的人，之前在百安居，顺电等线下零售行业做过好多年，正好我们的能力可以互补。从那以后，我记得2010年7月份的某天凌晨3点，我的创业搭档给我打电话说兄弟你过来我家一下，我们讨论下创业的事情，也就是从那个时候，我和我的创业搭档确定了我们要创业的路，那个时候我们的梦想或者说理想是什么呢？我们认为我们要提升中国这一代人的生活品质，要给他们提供高品质的居家用品，那个时候我觉得创业就是实现理想。时间一晃2年多过去了，我们真正辞职创业都8个月了，随着公司的高速发展，我也越来越发现了公司存在的问题，同时我也越来越睡不着觉，越来越难受，我在重新思考着创业到底是为什么？创业真的是为了实现所谓的梦想和理想那么简单吗？</p></li>
<li><p>我现在理解的创业是什么？    <br/>
我是一个来自中国西北的80后纯爷们，在思考到底创业是什么的过程中，我想了挺多的，我想到了我家人，我亲身的奶奶去世了，那时候因为离家远，我没有回家看她最后一眼，我外婆外公去世了，我也没有回去看他们最后一眼，我妈妈去年做心脏手术，我也没有回去，那个手术是挺危险的一个手术，要心脏停跳建立血液体外循环，然后把心脏里面的瘤子切除，然后再恢复心跳，很多人就是恢复心跳的时候恢复不过来了，然后前段时间，我嫂子去世了，我也没有回家，想了这些事情以后我顿时觉得我他妈的就是特大的一混蛋，为了自己所谓的梦想，理想，忽视了很多应该对亲人负责的关怀，所以我问自己创业真的仅仅是为了实现理想和梦想吗？这是我抛出的来的问题，也希望创业者思考一下。 <br/>
接下来，我来说说，我现在所理解的创业是什么？我觉得实现理想仅仅是一种结果，但是创业是一种过程，一种负责的态度，创业就是一种负责任的生活态度，是一种对用户，员工，投资方，乃至家人，所有关心你信任你的人负责任的态度。我们80后已经到了应该对这个社会担负责任的时候了，我们扪心自问一下，我们每天在做的事情是否对得起我们的客户和用户，是否对得起我们远在故乡的亲人，是否对得起我们的投资方，是否对得起和我们共事的每位伙伴，是否对得起每一个关心你信任你的人，是否对得起2年或者3年以后的自己，更甚者是否对得起这个社会。黑客与画家上面说的好，创业是创造财富而不是掠夺财富，投资方信任创业者投钱给创业者，如果创业者不能创造出价值，那么创业者是不是就是在掠夺财富呢？所以兄弟们，在创业路上的朋友们，别把理想当做创业，理想那仅仅是一个虚无飘渺的，遥远的“幻觉”，创业要成功，还得靠团队抱着积极负责的态度去做好每个人应该做的本职工作，只有每个人都真正负责任了，创业才能成功。</p></li>
</ol>


<p>我之前记得看到李开复老师的一个微博，微博大意就是说结婚了以后的创业者比没有结婚的创业者更容易成功，我当时看到的时候确实没什么感觉，但是我现在真正是感觉产生了共鸣，其实这里面主要就是责任心，因此是否有有责任心是创业成功的必须条件。</p>

<h2>2.2 产品</h2>

<p>产品方面今年主要读了&lt;&lt;人人都是产品经理这本书>>以及阅读了网上一些产品方面的文章，因为之前在淘宝工作过，所以看人人都是产品经理感觉亲身经历一样，说到产品大家都会要以用户为中心，这句话谁都会说，但是要真正的做到却很难，因为我们自己本身也不能代表真实的用户，因此我觉得创业公司，对于产品方面一定要抱着试错的态度，以精益创业的思路来开发产品，通过快速的迭代去验证自己提出的对产品的假设，而不是花了很多的精力做出来的东西缺发现并不是用户真正所需要的。</p>

<h2>2.3 管理</h2>

<p>管理方面主要阅读了&lt;&lt;软件人才管理艺术>>这本书，这本书里面讲的一些思想其实和自己的很多想法是一致的，这可能与自己也是一个工程师有关系吧。工程师可能更容易理解工程师内心需要什么。在技术管理方面我觉得最主要的就是要让团队的每个人都能在技术方面有所成长，其次就是沟通，很多问题都是因为沟通不好引起的，不能因为太忙了就缺少沟通，因此我一般每半个月都会和团队成员沟通一下，看看他们对团队，公司的一些看法，并且从沟通当中我也了解了许多伙伴们的看到的但是自己可能没注意到的地方，因此沟通非常重要。</p>

<p>我也很认可&lt;&lt;软件人才管理艺术>>一书中的一个观点，就是作为技术管理者一定要融入团队和团队打成一片，不要以为和团队成员关系走的太近，会不会自己说话，团队成员执行力不够，通过我这接近一年的实践，我更加真实的感受到，做为一个技术管理者，一定要融入到技术团队的重要性了，只有管理者真正抱着服务的态度融入团队了才能管理好团队，我要特别强调下服务，技术管理者不是整天吆喝着让谁谁去做什么事情，更重要的是你要帮团队成员解决困难。（当然了这也只是我个人不成熟的总结，毕竟我也没管理过什么大团队，只不过分享下自己创业过程中的管理心得）</p>

<p>有时候伙伴事情没有做好，因素可能有很多，排除其它客观的因素，有两个主观的因素很重要：态度和能力，有时候事情结果不好，很多时候管理者都认为别人事情没做好是态度有问题，其实有时候还真的是能力有问题，人家确实也尽力了但是结果就是没有达到预期，因此我觉得要清楚的了解每个伙伴的能力，对他们的能力有比较全面的认识，这样才能更好的优化大家平时的工作，提高工作效率，获得满意的结果。</p>

<p>另外我在说一下关于流程的一些看法，对于一个创业公司，流程是用来遇到了问题解决问题的，而不是为了未来不发生某些事情而指定流程来预防问题的。因此总结下来，我把管理总结为以下几个词：沟通，融入，服务和成长。</p>

<h2>2.4 技术</h2>

<p>技术方面之前可能仅仅关注了自己擅长的一个面，而今年自己创业，从开发，数据库，运维，网络安全，服务器采购各个方面都要去学习，就连开设网站需要的各种备案证书也要亲自去考，比如icp备案，公安局备案等等，毕竟创业不像之前大公司工作，开发只负责开发，数据库有DBA负责，运维，SCM,网络安全等都有人负责，创业了以后各个方面都需要你自己亲自己去做，当然了这里亲自去做的的时候，不要什么东西都要自己从零开始，比如存储，监控，数据统计这些服务完全可以采用国内已经做的比较好的服务，对于存储方面，我推荐又拍云存储，也可以体验下阿里云的服务，对于监控我推荐监控宝，另外对于网站数据的统计功能，我推荐使用百度统计和cnzz，另外百度指数，Google Analytics，Google webmasters，Google trend等也都不错的服务。</p>

<p>技术方面，做为技术人员我想说创业的时候不要为了技术而技术，还要考虑一下性价比，其实做系统就是成本，时间以及质量的折中，比如大家都知道系统具有水平伸缩性比较好，但是现在服务器硬件的提升速度很快，创业初期完全利用垂直伸缩也没什么，不要为了水平伸缩做了太多技术性的活，还是要关注于业务和产品多一点比较好，这样下来也是在一个可控的时间和成本的前提的，做出了符合预期质量的系统，如果真有一天业务量上来了，再考虑对系统进行重构也是可以的。</p>

<p>最后，希望创业者朋友们，一起交流，一起进步.另外大家也可以去我们的<a href="http://www.ejushang.com">B2C网站</a>网站看看，多提提宝贵意见，我们的成长，离不开大家的指导和建议。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Shell 脚本简化Java web开发中繁琐的打包、部署等重复劳动]]></title>
    <link href="http://imtiger.github.io/blog/2012/10/28/mutil-appservers-manage/"/>
    <updated>2012-10-28T18:20:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2012/10/28/mutil-appservers-manage</id>
    <content type="html"><![CDATA[<p>在平时的开发工作当中，经常会遇到如下一种场景：</p>

<p>本地需要启动多个tomcat实例，多个tomcat实例通过统一的一个apache web server来管理，并且项目是maven管理的，每次修改了文件要部署的时候，一般会重复做如下事情：</p>

<ol>
<li>maven 打包工程</li>
<li>删除日志文件</li>
<li>启动tomcat实例</li>
</ol>


<p>这样的工作做多了，真的既不高效，也不符合优秀的程序猿的习惯，所以我一般会将其写一个脚本，每次运行下脚本，让脚本帮我们来完成这件事情，岂不快哉！</p>

<p>Ok,I will show the code !</p>

<!-- more -->


<figure class='code'><figcaption><span>tomcatctl.sh </span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>
</span><span class='line'><span class="c">#!/bin/bash</span>
</span><span class='line'><span class="nv">PROJECTS_NAME</span><span class="o">=</span><span class="s2">&quot;eboss,boss,buyersystem,open&quot;</span>
</span><span class='line'><span class="nv">DEV_PROJECT_HOME</span><span class="o">=</span><span class="s2">&quot;/Users/tiger/develop/project/kariqu&quot;</span>
</span><span class='line'><span class="nv">APPSERVER_HOME</span><span class="o">=</span><span class="s2">&quot;/Users/tiger/develop/appserver&quot;</span>
</span><span class='line'><span class="nv">APP_LOG_HOME</span><span class="o">=</span><span class="s2">&quot;/Users/tiger/develop/appserver/apache/logs&quot;</span>
</span><span class='line'><span class="c">##1.kill tomcat pid </span>
</span><span class='line'><span class="nv">appName</span><span class="o">=</span><span class="nv">$1</span>
</span><span class='line'><span class="c">#input var is null</span>
</span><span class='line'><span class="k">if</span> <span class="o">[</span> -n <span class="s2">&quot;$appName&quot;</span> <span class="o">]</span>; <span class="k">then</span>
</span><span class='line'><span class="k">   </span><span class="nb">echo</span> <span class="s2">&quot;stop appServer $appName&quot;</span>
</span><span class='line'>   <span class="c">#get app pid</span>
</span><span class='line'>   <span class="nv">pid</span><span class="o">=</span><span class="sb">`</span>ps aux  |grep <span class="k">${</span><span class="nv">appName</span><span class="k">}</span> |awk <span class="s1">&#39;{print $2 &quot; &quot; $11}&#39;</span> |grep java |awk <span class="s1">&#39;{print $1}&#39;</span><span class="sb">`</span>
</span><span class='line'>   <span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;$pid&quot;</span> !<span class="o">=</span> <span class="s2">&quot;&quot;</span> <span class="o">]</span>; <span class="k">then</span>
</span><span class='line'><span class="k">      </span><span class="nb">kill</span> -9 <span class="nv">$pid</span>
</span><span class='line'>   <span class="k">else</span>
</span><span class='line'><span class="k">      </span><span class="nb">echo</span> -e <span class="s2">&quot;appServer $appName is not yet start !&quot;</span>
</span><span class='line'>   <span class="k">fi</span>
</span><span class='line'><span class="k">else</span>
</span><span class='line'><span class="k">  </span><span class="nb">echo</span> <span class="s2">&quot;please input appServer name !&quot;</span>
</span><span class='line'>  <span class="nb">exit</span>
</span><span class='line'><span class="k">fi</span>
</span><span class='line'>
</span><span class='line'><span class="c">###2.complie and package war</span>
</span><span class='line'><span class="nb">echo</span> <span class="s2">&quot;comple project and packaging war ...&quot;</span>
</span><span class='line'><span class="nv">current_project_home</span><span class="o">=</span><span class="nv">$DEV_PROJECT_HOME</span>/<span class="sb">`</span><span class="nb">echo</span> <span class="nv">$PROJECTS_NAME</span> |awk -F<span class="s2">&quot;,&quot;</span> <span class="s1">&#39;{for(i=1;i&lt;=NF;i++) print  $i}&#39;</span> |grep <span class="nv">$appName</span><span class="sb">`</span>
</span><span class='line'><span class="k">if</span> <span class="o">[</span> ! -d <span class="nv">$current_project_home</span> <span class="o">]</span>; <span class="k">then</span>
</span><span class='line'><span class="k">  </span><span class="nb">echo</span> <span class="s2">&quot;error,$current_project_home don&#39;t exist&quot;</span>
</span><span class='line'>  <span class="nb">exit</span>
</span><span class='line'><span class="k">fi</span>
</span><span class='line'>
</span><span class='line'><span class="nb">echo</span> <span class="s2">&quot;current project home : $current_project_home&quot;</span>
</span><span class='line'><span class="nb">cd</span> <span class="nv">$current_project_home</span>
</span><span class='line'>mvn clean package -Pdev -DskipTests
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="c">###3.clean logs</span>
</span><span class='line'><span class="nb">echo</span> <span class="s2">&quot;cleaning logs ...&quot;</span>
</span><span class='line'><span class="nb">cd</span> <span class="nv">$APP_LOG_HOME</span>/<span class="nv">$appName</span>
</span><span class='line'>rm -rf  *
</span><span class='line'><span class="nb">cd</span> <span class="nv">$APPSERVER_HOME</span>/<span class="k">${</span><span class="nv">appName</span><span class="k">}</span>-tomcat-7.0.26/logs
</span><span class='line'>rm -rf *.log *.txt *.out
</span><span class='line'><span class="nb">echo</span> <span class="s2">&quot;clean $logPath success !&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="c">###4.start tomcat</span>
</span><span class='line'><span class="nb">echo</span> <span class="s2">&quot;starting tomcat ...&quot;</span>
</span><span class='line'><span class="nv">$APPSERVER_HOME</span>/<span class="k">${</span><span class="nv">appName</span><span class="k">}</span>-tomcat-7.0.26/bin/startup.sh
</span><span class='line'>sleep 3
</span><span class='line'>
</span><span class='line'><span class="c">###5. check tomcat service </span>
</span><span class='line'><span class="nv">newpid</span><span class="o">=</span><span class="sb">`</span>ps aux |grep <span class="k">${</span><span class="nv">appName</span><span class="k">}</span> |grep -v <span class="s2">&quot;grep&quot;</span> | awk <span class="s1">&#39;{print $2}&#39;</span><span class="sb">`</span>
</span><span class='line'><span class="k">if</span> <span class="o">[</span> -n <span class="s2">&quot;$newpid&quot;</span> <span class="o">]</span>; <span class="k">then</span>
</span><span class='line'><span class="k">    </span><span class="nb">echo</span> -e <span class="s2">&quot;${appName} tomcat service  success !&quot;</span>
</span><span class='line'><span class="k">else</span>
</span><span class='line'><span class="k">    </span><span class="nb">echo</span> <span class="s2">&quot;start ${appName} tomcat service failed !&quot;</span>
</span><span class='line'><span class="k">fi</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过如上的脚本后，启动某个系统的命令如下:<code>  
./tomcatctl.sh systemname</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何构建Java web应用的session框架]]></title>
    <link href="http://imtiger.github.io/blog/2012/05/10/how-to-build-a-session-framework-for-java-web-application/"/>
    <updated>2012-05-10T09:31:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2012/05/10/how-to-build-a-session-framework-for-java-web-application</id>
    <content type="html"><![CDATA[<p>之前写过一个Java web的session框架，并且已经用于生产环境，运行良好。今天将我之前Evernote的笔记重新整理一下发布到博客上供有兴趣的同学参考下，也欢迎各位一起讨论。</p>

<p>做web开发的朋友都知道，一个网站在发展的过程中，随着流量的不断增加，必然会遇到伸缩性的问题，虽然目前硬件的价格已经在减低，有时候可以通过垂直伸缩的方式来达到应对访问量不断增加的麻烦，但是垂直伸缩总是会遇到瓶颈，那么此时就需要水平伸缩了。当水平伸缩的时候，最重要的一点就是状态管理，而web应用的状态通产采用httpsession的管理方式，不同的web server(比如tomcat,jboss,jetty等等)都提供了对httpsession的支持，但是webserver通常采用了集群节点之间互相复制session状态的方式来进行状态管理，这样随着集群节点的增加，集群之间的复制的开销会越来越大，这从某种程度上来说也限制了应用的伸缩性。本文就简单总结一下构建一个Java web 应用的session框架的思路是什么样子。</p>

<p>本文将会从session状态的存储，session信息的管理，安全性问题，以及如何与Servlet Container结合。</p>

<blockquote><p>在开始之前，我们首先需要明确一点这里所说的session的概念是广义的，不仅仅是指httpSession。</p></blockquote>

<!-- more -->


<h1>Session状态存储</h1>

<p>咋们首先来谈谈Session状态的存储。我们先来看看平常的日常工作当中，我们是怎么存储Session状态信息的。我们举个例子来说，比如用户的浏览历史，我们可能会将其保存在http cookie中，另外比如用户是否登陆的信息，我们可能选择保存在httpsession之中。上面说了存储到httpsession中会受限于web server的实现，伸缩性有限。那么我们在构建session框架的时候，可以考虑用一个分布式的缓存服务器来存储session状态，比如可以利用memecached服务器来进行存储。</p>

<p>另外这里面也涉及到另外一个问题，状态的跟踪问题，我们如何区分不同的用户的session信息？这里其实就需要通过cookie来实现了，我们会给每个用户产生的session分配一个唯一的Id，把这个id存放在cookie中，当用户请求服务器的时候会带上sessionId,服务器从cookie中获取sessionId后可以根据Id从缓存中获取到session状态信息。</p>

<p>说到这里，可能有同学会问？为什么我们不能把信息都放到cookie中，这样服务器端都不用存储任何的状态信息，这样对于服务器来说不也是无状态了吗？其实这里面主要涉及安全性以及浏览器的实现问题，因为存储到cookie中的信息是不安全的，黑客可以进行cookie劫持，这样你保存到cookie中的信息就会被非法用户获取了。另外我们知道不同的浏览器对cookie数量以及大小是有限制的，比如IE8限制cookie的大小为4095字节，每个域名cookie的数量为50个，这样以来就可能会遇到cookie丢失的问题。</p>

<p>综上，Session状态的存储，我们需要结合客户端存储和服务器端存储，在客户端存储中，我们借用http cookie来存储sessionId,而session的具体信息我们可以存放到服务器端，而具体实现的过程中，我们可以将起放入分布式缓存服务器中。</p>

<h1>Session信息的管理</h1>

<p>接下来我们再来说说Session信息管理，一些公司可能对这块没有什么重视，session状态的管理完全依赖于开发人员自己，开发人员可以随意将信息写入到cookie或者httpsession中，这样造成的问题就是session状态混乱，最后随着开发人员的离职，新来的人只能通过查看源代码的方式来了解session中都放入了什么信息，到后来可能公司没人知道在cookie或者httpsession中到底存放了哪些信息了？这对与系统的维护以及扩展都是不利的，那么怎么解决这个问题？</p>

<p>其实这个时候我们就可以通过session信息的统一配置话管理来解决了。具体来说就是Session框架通过一个配置文件对可放入的session信息进行统一的管理，要想往cookie或者服务器session中放入任何信息都要在配置文件中配置，这样才容许写入。这样要知道session中存放了哪些信息只需要查看配置文件即可知道了。</p>

<p>不过采用配置文件管理session信息了以后，可能又会遇到一个问题，配置文件如何管理？这个不同的公司可以有不同的做法，比如配置文件可以存放在数据库中，session框架启动的时候去数据库查询到最新的配置信息，或者也可以将其放入classpath文件中，session框架通过启动的时候去classpath中获取，另外一些公司都有统一的配置管理服务器，这样可以将session配置也纳入到配置管理服务器中，这样就更加规范了。</p>

<h1>信息安全性问题</h1>

<p>上面说了session信息的存储，我们的Session框架要支持两种存储方式，一种是cookie的客户端存储，一种是存储到服务端，当存储到客户端cookie中的，信息容易被非法意图的人窃取，如果什么信息都明文保存在cookie中，那么就存在用户信息泄露的风险。那么此时就需要对放入cookie的信息进行加密处理。关于加密和解密算法本人也没有深入研究过，不过这方面已经有很多人给出了解决方案。我在写Session框架的时候，采用了<a href="http://www.schneier.com/blowfish.html">Blowfish</a>，有兴趣的同学可以去看看。</p>

<h1>如何与Servlet Container结合</h1>

<p>本文的最后，咋们来看看在Java web 开发中，自己开发的Session框架如何与Servlet 容器结合起来。
Servlet规范中有过滤器的概念，过滤器是每个请求过来的时候，可以在请求进入Servlet之前和之后可以做一些通用的事情，那么我们的Session框架可以提供一个SessionFilter纳入到Servlet容器的管理。下面通过一个简单图来形象的描述一下Session框架中主要的角色。
<img class="center" src="http://imtiger.github.io/images/2012/05/10/sessionFramework.jpg">
上图中绿色的部分为Session框架的核心部分，我们下面分别来描述一下。</p>

<h2>SessionFilter</h2>

<p>SessionFilter的主要职责就是对web server生成的HttpServletRequest和HttpServletReponse进行封装，将其封装为<code>CustomHttpServletRequest</code>和<code>CustomHttpServletReponse</code>.
SessionFilter的核心代码如下：</p>

<figure class='code'><figcaption><span>SessionFilter.java</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@Override</span>
</span><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">doFilter</span><span class="o">(</span><span class="n">ServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="n">ServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="n">FilterChain</span> <span class="n">chain</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span><span class="o">,</span> <span class="n">ServletException</span> <span class="o">{</span>
</span><span class='line'>    <span class="c1">//对原生的HttpServletRequest和HttpServletReponse进行封装。</span>
</span><span class='line'>    <span class="n">CustomSessionServletRequest</span> <span class="n">customRequest</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CustomSessionServletRequest</span><span class="o">((</span><span class="n">HttpServletRequest</span><span class="o">)</span> <span class="n">request</span><span class="o">);</span>
</span><span class='line'>    <span class="n">CustomSessionServletResponse</span> <span class="n">customResponse</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CustomSessionServletResponse</span><span class="o">((</span><span class="n">HttpServletResponse</span><span class="o">)</span> <span class="n">response</span><span class="o">);</span>
</span><span class='line'>    <span class="c1">//对于一些静态资源可以不经过session框架过滤</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">letitgo</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">,</span> <span class="n">chain</span><span class="o">,</span> <span class="n">customRequest</span><span class="o">))</span> <span class="k">return</span><span class="o">;</span>
</span><span class='line'>    <span class="c1">//reponseBuffer开关，控制服务器刷新响应流的方式，如果打开的话，会等整个请求处理完成后一次性刷到客户端</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">needResponseBuffered</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isDebugEnabled</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">logger</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">&quot;session framework responseBuffered is on&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">customResponse</span><span class="o">.</span><span class="na">setWriterBuffered</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="n">CustomSession</span> <span class="n">customSession</span> <span class="o">=</span> <span class="n">createCustomSession</span><span class="o">(</span><span class="n">customRequest</span><span class="o">,</span> <span class="n">customResponse</span><span class="o">);</span>
</span><span class='line'>    <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">chain</span><span class="o">.</span><span class="na">doFilter</span><span class="o">(</span><span class="n">customRequest</span><span class="o">,</span> <span class="n">customResponse</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="kc">null</span> <span class="o">!=</span> <span class="n">customSession</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isDebugEnabled</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">logger</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">&quot;session framework start to commit session--&quot;</span> <span class="o">+</span> <span class="s">&quot;customSession.commit&quot;</span><span class="o">);</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>            <span class="c1">//将后续业务写入session的信息进行存储，这里就涉及到了将信息写入cookie或者缓存</span>
</span><span class='line'>            <span class="n">customSession</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">&quot;session framework occur exception&quot;</span><span class="o">,</span> <span class="n">ex</span><span class="o">);</span>
</span><span class='line'>        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="n">ex</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isDebugEnabled</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">logger</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">&quot;session framework start to commit buffer--&quot;</span> <span class="o">+</span> <span class="s">&quot;customResponse.commitBuffer&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="c1">//将响应流刷到客户端</span>
</span><span class='line'>        <span class="n">customResponse</span><span class="o">.</span><span class="na">commitBuffer</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>CustomHttpServletRequest</h2>

<p>CustomHttpServletRequest包转了原生的HttpServletRequest，它最核心的就是要覆盖getSession方法，主要的代码如下：</p>

<figure class='code'><figcaption><span>CustomHttpServletRequest.java</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@Override</span>
</span><span class='line'><span class="kd">public</span> <span class="n">CustomSession</span> <span class="nf">getSession</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">session</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="nd">@Override</span>
</span><span class='line'><span class="kd">public</span> <span class="n">CustomSession</span> <span class="nf">getSession</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">create</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nf">getSession</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样当应用通过getSession返回的则是经过封装以后的代码。</p>

<h2>CustomHttpServletReponse</h2>

<p>CustomHttpServletReponse封装了原生的HttpServletReponse,此类的实现的时候需要注意在Servlet3.0之前，不支持httponly的cookie，要写入Httponly的cookie需要手动通过addHeader的方法去加入，而Servlet3.0以后，可以直接通过addCookie方法实现，具体的伪代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">addCookie</span><span class="o">(</span><span class="n">CustomCookie</span> <span class="n">cookie</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">cookie</span><span class="o">.</span><span class="na">isHttpOnly</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">addHeader</span><span class="o">(</span><span class="n">SET_COOKIE</span><span class="o">,</span> <span class="n">buildHttpOnlyCookie</span><span class="o">(</span><span class="n">cookie</span><span class="o">));</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>            <span class="kd">super</span><span class="o">.</span><span class="na">addCookie</span><span class="o">(</span><span class="n">cookie</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>另外我们知道标准的Servlet 输出流有一个缓存区，当应用向缓存区写入数据的时候，如果缓存区已经满了就会刷流到客户端了，这样的话就有可能造成一种情况：部分流已经刷到客户端了，但是后来服务器处理抛异常了，这样用户可能看到的状态可能和服务器不一致，为了解决这个问题，我们可以重写getOutputStream和getWriter方法，这两个方法在返回一个经过我们包装的输出流，这样Session框架就可以保留应用写入的数据到最后请求处理完了以后再由SessionFilter刷新流到客户端。具体的伪代码可以参考如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@Override</span>
</span><span class='line'><span class="kd">public</span> <span class="n">ServletOutputStream</span> <span class="nf">getOutputStream</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">isWriterBuffered</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isDebugEnabled</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">logger</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">&quot;Created new byte buffer&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="c1">//这里返回一个ByteArrayOutputStream，方便Session框架控制输出流</span>
</span><span class='line'>        <span class="n">ByteArrayOutputStream</span> <span class="n">bytes</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ByteArrayOutputStream</span><span class="o">();</span>
</span><span class='line'>        <span class="n">stream</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BufferedServletOutputStream</span><span class="o">(</span><span class="n">bytes</span><span class="o">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">stream</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">getSession</span><span class="o">().</span><span class="na">commit</span><span class="o">();</span>
</span><span class='line'>        <span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">getOutputStream</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@Override</span>
</span><span class='line'><span class="kd">public</span> <span class="n">PrintWriter</span> <span class="nf">getWriter</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">isWriterBuffered</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isDebugEnabled</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">logger</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">&quot;response.getWriter(): Created new character buffer&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="c1">//这里返回StringWriter 方便Session框架控制输出流</span>
</span><span class='line'>        <span class="n">StringWriter</span> <span class="n">chars</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringWriter</span><span class="o">();</span>
</span><span class='line'>        <span class="n">writer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BufferedServletWriter</span><span class="o">(</span><span class="n">chars</span><span class="o">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">writer</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">getSession</span><span class="o">().</span><span class="na">commit</span><span class="o">();</span>
</span><span class='line'>        <span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">getWriter</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>另外需要重写的一些方法比如sendError,sendRedirect也需要重写。</p>

<h2>CustomHttpSession</h2>

<p>CustomHttpSession主要负责管理Session中的状态信息，它是HttpSession的子类，它会根据Session框架的配置，将不同的信息保存到对应的SessionHolder中，对于CustomHttpSession，我们主要需要重写setAttribute和getAttribute方法。它的伪代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setAttribute</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="n">Object</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">//1. 根据Session框架的配置文件，找到name的属性对应的session配置项</span>
</span><span class='line'>        <span class="kd">final</span> <span class="n">SessionConfigItem</span> <span class="n">sessionConfigItem</span> <span class="o">=</span> <span class="n">sessionConfig</span><span class="o">.</span><span class="na">getSessionConfigItem</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">sessionConfigItem</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">return</span><span class="o">;</span><span class="c1">//如果配置项为空，说明此name的属性没有经过session框架配置，不能写入</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="c1">//2. 根据配置类型获取具体的SessionHolder</span>
</span><span class='line'>        <span class="kd">final</span> <span class="n">SessionHolder</span> <span class="n">sessionHolder</span> <span class="o">=</span> <span class="n">sessionHolders</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">sessionConfigItem</span><span class="o">.</span><span class="na">getHolderType</span><span class="o">());</span>
</span><span class='line'>        <span class="c1">//2. 找到对应的SessionHolder将其存储</span>
</span><span class='line'>        <span class="n">sessionHolder</span><span class="o">.</span><span class="na">setAttribute</span><span class="o">(</span><span class="n">sessionConfigItem</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">getAttribute</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="kd">final</span> <span class="n">SessionConfigItem</span> <span class="n">sessionConfigItem</span> <span class="o">=</span> <span class="n">sessionConfig</span><span class="o">.</span><span class="na">getSessionConfigItem</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">sessionConfigItem</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="kd">final</span> <span class="n">SessionHolder</span> <span class="n">sessionHolder</span> <span class="o">=</span> <span class="n">sessionHolders</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">sessionConfigItem</span><span class="o">.</span><span class="na">getHolderType</span><span class="o">());</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">sessionHolder</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">sessionHolder</span><span class="o">.</span><span class="na">getAttribute</span><span class="o">(</span><span class="n">sessionConfigItem</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>SessionHolder</h2>

<p>SessionHolder抽象了Session保存的接口，具体实现可以有好多种，比如你可以选择把session信息保存到cookie中，也可以将其保存到缓存中，甚至你可以将其保存到文件系统中。我自己写的session框架，根据前面的讨论，提供了两种存储方式，CookieHolder和CacheHolder分别对应客户端存储和服务器端缓存存储。在CookieHolder中要涉及到对cookie的解析，保存以及加密等操作，而CacheHolder涉及到从分布式缓存中查询到Session的信息以及同步session信息到缓存等一系列操作，具体代码我就贴了。</p>

<p>上面就是写一个Session框架大体的思路，对此有兴趣的同学可以一起讨论一下。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript 作用域和作用域链解析]]></title>
    <link href="http://imtiger.github.io/blog/2011/10/17/javascript-scope-and-scope-chain-explain/"/>
    <updated>2011-10-17T18:26:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2011/10/17/javascript-scope-and-scope-chain-explain</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://imtiger.github.io/images/2011/10/17/JavaScript-Logo.png">
最近看了下JavaScript方面的几本书，把里面的一些核心概念按照自己的理解做个总结。</p>

<p>JavaScript 中有 Scope( 作用域 ) ， Scope chain( 作用域链 ) ， Execute context( 执行上下文 ) ， Active Object ( 活动对象 ),Dynamic Scope( 动态作用域 ) ， Closure( 闭包 ) 这些概念，要理解这些概念，我们从静态和动态两个方面去分析一下。</p>

<p>首先我们写一个简单的 function 来做一个例子：</p>

<figure class='code'><figcaption><span>JavaScript code</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span> <span class="nx">add</span><span class="p">(</span><span class="nx">num1</span><span class="p">,</span> <span class="nx">num2</span><span class="p">){</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">sum</span> <span class="o">=</span> <span class="nx">num1</span> <span class="o">+</span> <span class="nx">num2</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="nx">sum</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<!-- more -->


<p>我们定义了一个具有两个形参的 add 函数。</p>

<p><strong>静态方面：</strong></p>

<p>当创建 add 函数的时候， Javascript 引擎会创建 add 函数的 <code>Scope chain</code>, 这个作用域链指向了 <code>Global Context( 全局上下文 )</code> 。如果用图形形象化的表述如下图所示：</p>

<p><img class="center" src="http://imtiger.github.io/images/2011/10/17/add-method.jpg"></p>

<p>从上图可以看出，当 add 函数创建的时候，作用域链就已经创建了，因此可以得出一个结论:</p>

<blockquote><p>函数的作用域链是创建函数的时候就已经创建了，而不是动态运行期。</p></blockquote>

<p>下面就来看看动态运行期的时候会发生什么事情。</p>

<p><strong>动态方面：</strong></p>

<p>当执行 add 函数的时候， JavaScript 会创建一个 <code>Execute context （执行上下文）</code>，执行上下文中就包含了 add 函数运行期所需要的所有信息。 Execute context 也有自己的 Scope chain, 当函数运行的时候， JavaScript 引擎会首先从用 add 函数的作用域链来初始化执行上下文的作用域链，然后 JavaScript 引擎又会创建一个 Active Object, 这个对象里面包含了函数运行期的所有局部变量，参数以及 this 等变量。</p>

<p>如果形象的描述 add 函数动态运行期会发生什么，可以用如下图来描述：
<img class="center" src="http://imtiger.github.io/images/2011/10/17/add-method-runtime.jpg"></p>

<p>从上图可以看出，执行上下文是一个动态的概念，它是当函数运行的时候创建的，同时 Active Object 对象也是一个动态的概念，它是被执行上下文的作用域链引用的。因此可以得出一个结论：</p>

<blockquote><p>执行上下文和活动对象都是动态概念，并且执行上下文的作用域链是由函数作用域链初始化的。</p></blockquote>

<p>上面说了函数作用域和执行上下文作用域，下面接着说一下动态作用域的问题.<br/>
当在 JavaScript 通过 with 语句， try-catch 的 catch 子句，以及 eval 方法的时候， JavaScript 引擎就会动态的改变执行上下文的作用域。下面还是通过一个例子来看看：</p>

<figure class='code'><figcaption><span>JavaScript Code</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span> <span class="nx">initUI</span><span class="p">(){</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">with</span> <span class="p">(</span><span class="nb">document</span><span class="p">){</span> <span class="c1">//avoid!</span>
</span><span class='line'>      <span class="kd">var</span> <span class="nx">bd</span> <span class="o">=</span> <span class="nx">body</span><span class="p">,</span>
</span><span class='line'>      <span class="nx">links</span> <span class="o">=</span> <span class="nx">getElementsByTagName</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">),</span>
</span><span class='line'>      <span class="nx">i</span><span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
</span><span class='line'>      <span class="nx">len</span> <span class="o">=</span> <span class="nx">links</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
</span><span class='line'>      <span class="k">while</span><span class="p">(</span><span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">){</span>
</span><span class='line'>      <span class="nx">update</span><span class="p">(</span><span class="nx">links</span><span class="p">[</span><span class="nx">i</span><span class="o">++</span><span class="p">]);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;go-btn&quot;</span><span class="p">).</span><span class="nx">onclick</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
</span><span class='line'>      <span class="nx">start</span><span class="p">();</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">bd</span><span class="p">.</span><span class="nx">className</span> <span class="o">=</span> <span class="s2">&quot;active&quot;</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当执行上面的 initUI 函数的时候， JavaScript 会动态的创建一个 with 语句对应的作用域放到执行上下文作用域链的最前端，通过下图可以形象的描述上述过程，下图红色标注的区域就显示了 with 语句产生的作用域。
<img class="center" src="http://imtiger.github.io/images/2011/10/17/initui-method.jpg"></p>

<p>最后，我们来看看 JavaScript 最神秘的 Closure （闭包），闭包在 JavaScript 其实就是一个函数，闭包是在函数运行期被创建的，下面还是以一个实例来看看：</p>

<figure class='code'><figcaption><span>JavaScript Code</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span> <span class="nx">assignEvents</span><span class="p">(){</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">id</span> <span class="o">=</span> <span class="s2">&quot;xdi9592&quot;</span><span class="p">;</span>
</span><span class='line'>  <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;save-btn&quot;</span><span class="p">).</span><span class="nx">onclick</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">){</span>
</span><span class='line'>      <span class="nx">saveDocument</span><span class="p">(</span><span class="nx">id</span><span class="p">);</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当上面的 assignEvents 函数被执行的时候，会创建一个闭包，而这个闭包会引用 assignEvents 作用域中的 id 变量，如果按照传统的编程语言的方式， id 是存储在堆栈上的一个变量，当函数执行完了以后 id 就消失，那么怎么可能再次引用呢？显然这里 JavaScript 采用了另外的方式。<br/>
下面就来看看 JavaScript 是如何来实现闭包的。当执行 assignEvents 函数的时候， JavaScript 引擎会创建assignEvents函数执行上下文的作用域链，这个作用域链包含了 assignEvents 执行时的活动对象，而同时 JavaScript 引擎也会创建一个闭包，而闭包的作用域链也会引用 assignEvent 执行时候的活动对象，这样当 assignEvents 执行完的时候，虽然它本身执行上下文的作用域链不再引用活动对象了，但是闭包还是引用着 assignEvents 运行期对应的活动对象，这就解释了 JavaScipt 内部的闭包机制。可以用下图形象的表述上面 assignEvents 函数运行期的情形：
<img class="center" src="http://imtiger.github.io/images/2011/10/17/assignevents-method.jpg"></p>

<p>从上面可以看出，当 assignEvents 函数执行完毕以后， document.getElementById(&ldquo;save-btn&rdquo;).onclick 引用了闭包，这样当用户点击 save-btn 的时候，就会触发闭包的执行，那么下面就来看看闭包执行时的情形。前面也说了 JavaScript 中闭包其实就是函数，因此闭包执行和函数执行时的情形是一致的，通过下图来形象的描述上述 onclick 事件所关联的闭包。
<img class="center" src="http://imtiger.github.io/images/2011/10/17/closure-runtime.jpg"></p>

<p>从上图可以看出 JavaScript 引擎首先创建了闭包的执行上下文，然后用闭包作用域链来初始化闭包的执行上下文作用域链，最后再将闭包执行时对应的活动对象放入到作用域的最前端，这也进一步验证了闭包就是函数的论断。</p>

<p>参考资料：</p>

<ol>
<li><a href="http://book.douban.com/subject/5362856/">High Performance JavaScript</a></li>
<li><a href="http://book.douban.com/subject/4886879/">JavaScript高级程序设计</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Web开发之Http Cache]]></title>
    <link href="http://imtiger.github.io/blog/2011/07/07/optimize-your-site-using-http-caching/"/>
    <updated>2011-07-07T22:27:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2011/07/07/optimize-your-site-using-http-caching</id>
    <content type="html"><![CDATA[<p>在如今的 web 系统中， cache 应该是每个 web 系统架构师或者开发人员必须要掌握的技能。而 cache 在 web 的世界中一般分为客户端 cache( 当然有些人也叫它浏览器 cache) 和服务端 cache, 这篇文章不涉及 服务端 cache 的内容 . 下面我们主要来看看客户端 cache 所涉及 http header 相关联的知识。</p>

<h2>1.Last-modified/if-modified-since</h2>

<p>首先登场的是 <code>Last-modified/if-modified-since</code> ，当用户第一次浏览一个网站的时候，服务器会在响应头中增加 Last-modified 这个 http 响应头， Last-modified 的格式如：<code>Last-modified: Fri, 16 Mar 201 04:00:25 GMT</code>当用户第二次再请求同样的 url 的时候，浏览器会将 <code>last-modified</code> 的值附加到 <code>if-modified-since</code> 这个 http 请求头中，服务器端接收到请求后，首先 check 一下 <code>if-modified-since</code> 头信息中的时间是否与当前 url 对应的资源的最后修改时间一致，如果一致，则服务器返回 http 304 状态码，这样当浏览器收到 http 304 状态码了以后，就会利用本地缓存的内容来完成对本次用户操作的响应。如果过程的形象点的描述可以通过如下图描述：</p>

<!-- more -->


<p><img class="center" src="http://imtiger.github.io/images/2011/07/07/HTTP-caching-last-modified_1.png"></p>

<center>（上图来自于<a href="http://betterexplained.com">http://betterexplained.com</a>）</center>


<p>对于 <code>Last-modified/if-modified-since</code> 的缓存控制，可能有人会问对于动态内容是否有效果？其实这个与动态内容和静态内容没什么关系，浏览器和服务器之间是通过 http 协议通信的，浏览器本身并不关心，也不知道本地缓存中的内容是服务器动态生成的还是仅仅是静态数据，对于浏览器来说，只要服务器在对某此请求设置了 <code>Last-modified</code> 的 http 响应头以后，浏览器就会在下次请求的时候带上 <code>if-modified-since</code> 的请求头，从而完成和服务器之间的缓存协商控制。如果用 java servlet 为例，服务器只需要通过如下代码：</p>

<figure class='code'><figcaption><span>Servlet code</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">response</span><span class="o">.</span><span class="na">addDateHeader</span><span class="o">(</span><span class="s">&quot;Last-Modified&quot;</span><span class="o">,</span><span class="n">time</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>
即可完成将 http 响应头写入响应。另外基于 <code>Last-modified/if-modified-since</code> 的客户端缓存，存在一些缺点，比如当你的 web 站点部署在一个集群环境中，而当用户的同样的请求被路由到不同的 web 服务器的时候就有可能会造成缓存失效，因为不同的服务器时间有可能存在不一致的情况。</p>

<h2>2.Etag/if-none-match</h2>

<p><code>Etag</code> 是 http 1.1 规范引入的一个新的 http 实体头， Etag 在规范中仅仅只 etag 可以用来对同一个资源的其它实体头进行对比，没有做进一步的解释，其实我们可以把 Etag 理解为一个服务器在某个资源上面做的一个记号，至于这个记号用来做什么要看服务器如何去解析它，因此我们在设计我们自己的应用的时候，可以借助 Etag 来实现客户端缓存和服务器之间的缓存协商控制。下面我们来看一下 Etag 如何结合到一个 web 的请求之中。当浏览器第一次请求一个资源的时候，服务器在响应头里面加入 Etag 的标识， Etag 的值既是当前响应内容经过计算以后的值（ http 规范没有对 etag 值的计算方式做规定，可以是 md5 或者其它方式）当第二次浏览器发送请求的时候，浏览器便会用原先请求中 Etag 响应头的值作为 if-None-Match 请求头的值，这样服务器接受到此次请求以后，根据 <code>if-None-Match</code> 的取值和当前的内容进行对比，如果相同则返回一个 304 not modified 响应码，这样浏览器收到 304 后就会用客户端本地 cache 来完成对本次请求的响应。上述过程可以通过下图形象的描述：</p>

<p><img class="center" src="http://imtiger.github.io/images/2011/07/07/HTTP_caching_if_none_match.png"></p>

<p>通过以上的描述我们可以看出， Etag 可以避免 Last-Modified 因为服务器时间不同步造成的缓存失效问题，另外值得我们关注的是 <code>Etag</code> 和 <code>last-modified</code> 仅仅只能节省网络带宽，并不能真正的减少对服务器的 http 请求数，如果要想真正的减少服务器端得请求数，还需要另外的 http  header 的协助，下面我们就来看一下，如何减少对服务器端得请求数。</p>

<h2>3.Expries</h2>

<p><code>Expries</code> 是另外一个与客户端缓存有关系的 http 头，在浏览器请求一个资源的时候，服务器设置了 Expries 头以后，下次浏览器再请求同样资源的时候，如果发现资源 expires 没有超期，则直接用客户端本地 cache 中数据来完成本次响应，不会向服务器再发送请求。此过程可以通过下图形象的描述：
<img class="center" src="http://imtiger.github.io/images/2011/07/07/HTTP_caching_expires.png"></p>

<p>如果在 java servlet 中，则可以通过如下方法来设置一次响应内容的超期时间。</p>

<figure class='code'><figcaption><span>Servlet code</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'>  <span class="n">response</span><span class="o">.</span><span class="na">setDateHeader</span><span class="o">(</span><span class="s">&quot;Expires&quot;</span><span class="o">,</span> <span class="n">expiresTime</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>对于 Expires 响应头我们需要注意一点，当响应头中已经设置了 Cache-Contrl:max-age 以后， max-age 将覆盖掉 expires 的效果（参见 http1.1 规范）原文如下：</p>

<blockquote><p>Note: if a response includes a Cache-Control field with the max-age directive (see section 14.9.3 ), that directive overrides the Expires field.</p></blockquote>

<p>对于 <code>Expires</code> 特别适合对于网站静态资源的缓存，比如 js,image,logo 等，这些资源不会经常发生变化，另外一个也适合于一些周期性更新的内容。</p>

<p>上面说了 <code>Expires</code> ，虽然它可以避免每次都向服务器发送请求，但是它依赖于服务器时间和客户端的时间一致，如果服务器端时间和客户端时间不一致的话，往往会导致缓存失效，接下来我们再来看看另外一个比较重要的 http header: <code>Cache-Control</code>.</p>

<h2>4.Cache-Control</h2>

<p><code>Cache-Control</code>采用基于客户端的时间来进行对缓存的控制。 <code>Cache-Control</code> 这个 HTTP header 的取值有很多，我们主要来与本主题相关的 max-age: 这个取值代表缓存内容从请求时间开始多久过期，作用类似于 expires 。</p>

<p>另外 <code>Cache-control : no-cache</code>: 告诉浏览器，响应的内容不容许缓存，说到<code>no-cache</code>, 我们有必要看看另外一个响应头 <code>Pragma:no-cache</code>, 可能很多人（包括我之前也是）认为设置了 <code>Pragma:on-cache</code> 以后，浏览器将不会对其内容进行缓存，但是我们错了，在 http1.1 规范没有明确的规定 <code>Pragma:no-cache</code> 作为响应头的意义，原文如下（来自 http1.1 规范）：</p>

<blockquote><p>Note: because the meaning of &ldquo;Pragma: no-cache as a response header field is not actually specified, it does not provide a reliable replacement for &#8220;Cache-Control: no-cache&rdquo; in a response</p></blockquote>

<p>最后我们需要关注另外一个问题：<strong>如何清除浏览器缓存？</strong>假如我们一个资源超期时间设置的太长了，而我们又更新了一些资源怎么办？这里大多数网站都采用资源版本化来解决，通俗一点就是给每个资源分配一个缓存版本，当修改资源以后，只需要增加一下版本号即可。比如 javaeye 的 <a href="http://www.iteye.com/javascripts/application.js?1309443254">http://www.iteye.com/javascripts/application.js?1309443254</a> ， 1309443254 这个既是版本号，当 application.js 发生变化的时候，只需要修改此版本号即可。一般一些前端的MVC框架都会支持框架层面来加版本号。</p>

<p>最后附上一些关于Web缓存相光的文章：</p>

<p><a href="http://www.infoq.com/cn/articles/etags">使用ETags减少Web应用带宽和负载</a><br/>
<a href="http://betterexplained.com/articles/how-to-optimize-your-site-with-http-caching/">How To Optimize Your Site With HTTP Caching</a><br/>
<a href="http://www.jdon.com/jivejdon/thread/40381">Http缓存Last-Modified、ETag和Expires的Java终结解决之道</a><br/>
<a href="http://www.mnot.net/cache_docs/#CACHE-CONTROL">Caching Tutorial</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分布式应用中客户端的设计]]></title>
    <link href="http://imtiger.github.io/blog/2011/03/25/client-design-of-distributed-system/"/>
    <updated>2011-03-25T18:16:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2011/03/25/client-design-of-distributed-system</id>
    <content type="html"><![CDATA[<p>一个分布式的系统一般都会有很多的节点，节点和节点之间的通讯采用远程调用的方式，而当在实现业务逻辑的时候，我们可以通过客户端的实现方式实现，目前实现客户端的方式有两种方式，瘦客户端和富客户端。</p>

<h1>瘦客户端</h1>

<p>所谓瘦客户端类似于之前EJB那种方式，瘦客户端本身不具有业务逻辑，瘦客户端通过业务接口调用服务端逻辑，这个时候逻辑运算还是跑那个被多个系统共用的服务器，这样当存在大量的请求的情况下，负责逻辑运算的服务器就会成为瓶颈，这个时候通过水平伸缩负责逻辑运算的服务器，这个时候涉及到客户端请求的负载均衡，每次将远程调用采用负载均衡算法将其分配到逻辑端服务器，采用这种方式以后，可能就需要远程调用框架内部支持一些比如流量控制，负载均衡等的机制，这样使得调用方本身不需要关心服务器端的物理部署。</p>

<p>当然了，我们也可以通过富客户端的方式来实现，下面我们就来介绍一下富客户端的设计。</p>

<!-- more -->


<h1>富客户端</h1>

<p>富客户端是将运算逻辑以客户端包的形式提供给调用方来使用，这样可以分摊逻辑运算服务器的压力，将压力分担到调用方服务器。这种方式非常适合调用方服务器本身负责的逻辑很简单，运算量很小的情况下，采用富客户端以后可以合理利用调用方服务器的资源来分摊掉被调用方服务器的压力。另外一方面，富客户端也适用于当需要将一些非核心的业务从核心业务中剥离出来，然后让非核心的业务跑到调用方的服务器中，同时富客户端还可以做其它的一些事情，比如缓存调用结果，实现调用方的local cache等。</p>

<p>当然了采用富客户端也会带来一个明显的问题，那就是客户端的升级，假如逻辑有变化需要让调用方升级客户端包，当然这也有解决办法，就是将业务逻辑进行抽象，每一步都采用动态脚本的方式比如Groovy脚本去执行，每次客户端服务器启动的时候，中心服务器推送最新的Groovy脚本到web客户端服务器，这样客户端服务器就可以获取到最新的执行逻辑,当然这对客户端的设计要求严格，客户端可能要设计的具有插件式的灵活功能。</p>

<p>采用富客户端另外一个问题就是富客户端的状态和服务器端的如何进行同步，假如服务器端的一些数据变化了，而客户端需要感知这些变化怎么办？这也有解决办法，一种方式是<code>拉模式</code>，另外一种模式<code>推模式</code>。</p>

<ol>
<li><p>拉模式 <br/>
拉模式就是每次服务端有变化的时候，给富客户端发条指令，然后富客户端会主动向服务器端来拉数据，这种方式对于客户端服务器量比较大的情况下比较方便，比如富客户端被前端数百台机器使用，这个时候可以显著减少服务端的工作量。</p></li>
<li><p>推模式<br/>
推模式就是当服务器端发生变化的时候，主动推送给每个客户端，这种情况适合客户端服务器数量不多的情况，当然无论是采用拉还是推模式都需客户端和服务端保持一定的联系，这可能需要客户端在启动的时候主动的向服务端去注册一下，客户端注册以后，中心服务器端可以监控客户端的一些运行状况等信息。</p></li>
</ol>


<p>以上两种是在分布式系统中常见的两种客户端的设计策略，具体需要哪种，需要根据系统场景进行取舍。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[构建可伸缩、高性能的互联网应用]]></title>
    <link href="http://imtiger.github.io/blog/2010/07/12/scalable-and-high-performance-system/"/>
    <updated>2010-07-12T15:52:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2010/07/12/scalable-and-high-performance-system</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://imtiger.github.io/images/2010/07/12/high-scalability.jpg"></p>

<blockquote><p>本文发布在我原来的博客上面，后来换博客了，重新整理一下，发布在新的博客上。</p></blockquote>

<p>本文结合本人的工作经验分析一下，如何构建一个可伸缩，高性能的互联网应用？下面从几个方面来谈谈个人的一些浅见，供有兴趣的同学参考下，也欢迎大家一起讨论。</p>

<h1>1. 应用无状态</h1>

<p>俗话说，一个系统的伸缩性的好坏取决于应用的状态如何管理。为什么这么说呢？咱们试想一下，假如我们在session中保存了大量与客户端的状态信息的话，那么当保存状态信息的server宕机的时候，我们怎么办？通常来说，我们都是通过集群来解决这个问题，而通常所说的集群，不仅有负载均衡，更重要的是要有失效恢复failover,比如tomcat采用的集群节点广播复制，jboss采用的配对复制等session状态复制策略，但是集群中的状态恢复也有其缺点，那就是严重影响了系统的伸缩性，系统不能通过增加更多的机器来达到良好的水平伸缩，因为集群节点间session的通信会随着节点的增多而开销增大，因此要想做到应用本身的伸缩性，我们需要保证应用的无状态性，这样集群中的各个节点来说都是相同的，从而是的系统更好的水平伸缩。</p>

<!-- more -->


<p>上面说了无状态的重要性，那么具体如何实现无状态呢？此时一个session框架就会发挥作用了。一般通过cookie来实现，或者也可以采用集中式session管理来完成，说具体点就是多个无状态的应用节点连接一个session 服务器，session服务器将session保存到缓存中，session服务器后端再配有底层持久性数据源，比如数据库，文件系统等等。</p>

<h1>2. 有效使用缓存</h1>

<p>做互联网应用的兄弟应该都清楚，缓存对于一个互联网应用是多么的重要，从浏览器缓存，反向代理缓存，页面缓存，局部页面缓存，对象缓存等等都是缓存应用的场景。</p>

<p>一般来说缓存根据与应用程序的远近程度不同可以分为：local cache 和 remote cache。一般系统中要么采用local cache，要么采用remote cache,两者混合使用的话对于local cache和remote cache的数据一致性处理会变大比较麻烦.</p>

<p>在大部分情况下,我们所说到的缓存都是读缓存,缓存还有另外一个类型:写缓存.  对于一些读写比不高，同时对数据安全性需求不高的数据，我们可以将其缓存起来从而减少对底层数据库的访问,比如统计商品的访问次数,统计API的调用量等等,可以采用先写内存缓存然后延迟持久化到数据库，这样可以大大减少对数据库的写压力。</p>

<p>关于浏览器缓存,可以参考本人的另外一篇文章：<a href="http://imtiger.github.io/blog/2011/07/07/optimize-your-site-using-http-caching/">Web开发之Http Cache</a></p>

<h1>3. 应用拆分</h1>

<p>首先，在说明应用拆分之前，我们先来回顾一下一个系统从小变大的过程中遇到的一些问题，通过这些问题我们会发现拆分对于构建一个大型系统是如何的重要。</p>

<p>系统刚上线初期，用户数并不多，所有的逻辑也许都是放在一个系统中的，所有逻辑跑到一个进程或者一个应用当中，这个时候因为比较用户少，系统访问量低，因此将全部的逻辑都放在一个应用未尝不可。但是，兄弟们都清楚，好景不长，随着系统用户的不断增加，系统的访问压力越来越多，同时随着系统发展，为了满足用户的需求，原有的系统需要增加新的功能进来，系统变得越来越复杂的时候，我们会发现系统变得越来越难维护，难扩展，同时系统伸缩性和可用性也会受到影响。那么这个时候我们如何解决这些问题呢？明智的办法就是拆分（这也算是一种解耦），我们需要将原来的系统根据一定的标准，比如业务相关性等分为不同的子系统，不同的系统负责不同的功能，这样切分以后，我们可以对单独的子系统进行扩展和维护，从而提高系统的扩展性和可维护性，同时我们系统的水平伸缩性scale out大大的提升了，因为我们可以有针对性的对压力大的子系统进行水平扩展而不会影响到其它的子系统，而不会像拆分以前，每次系统压力变大的时候，我们都需要对整个大系统进行伸缩，而这样的成本是比较大的，另外经过切分，子系统与子系统之间的耦合减低了，当某个子系统暂时不可用的时候，整体系统还是可用的，从而整体系统的可用性也大大增强了。</p>

<p>因此一个大型的互联网应用，肯定是要经过拆分，因为只有拆分了，系统的扩展性，维护性,伸缩性，可用性才会变的更好。但是拆分也给系统带来了问题，就是子系统之间如何通信的问题，而具体的通信方式有哪些呢？一般有同步通信和异步通信，这里我们首先来说下同步通信，下面会说到异步通信。既然需要通信，这个时候一个高性能的远程调用框架就显得非常总要啦.一般大公司都有自己的远程RPC框架，关于远程调用框架，阿里巴巴的技术团队开源了一个不错的框架：<a href="http://code.alibabatech.com/wiki/display/dubbo/Home/">dubbo</a></p>

<p>上面所说的都是拆分的好处，但是拆分以后必然的也会带来新的问题，除了刚才说的子系统通信问题外，最值得关注的问题就是系统之间的依赖关系，因为系统多了，系统的依赖关系就会变得复杂，此时就需要更好的去关注拆分标准，比如能否将一些有依赖的系统进行垂直化，使得这些系统的功能尽量的垂直，这也是目前公司正在做的系统垂直化，同时一定要注意系统之间的循环依赖，如果出现循环依赖一定要小心，因为这可能导致系统连锁启动失败。</p>

<p>从上面可以看出，一个大型系统要想变得可维护，可扩展，可伸缩，我们必须的对它进行拆分，拆分必然也带来系统之间如何通信以及系统之间依赖管理等问题。</p>

<h1>4. 数据库拆分</h1>

<p>在前面“应用拆分”主题中，我们提到了一个大型互联网应用需要进行良好的拆分，而那里我们仅仅说了”应用级别”的拆分，其实我们的互联网应用除了应用级别的拆分以外，还有另外一个很重要的层面就是存储如何拆分的。因此这个主题主要涉及到如何对存储系统（本文主要谈RDBMS）进行拆分。</p>

<p>好了，确定了这个小节的主题之后，我们回顾一下，一个互联网应用从小变大的过程中遇到的一些问题，通过遇到的问题来引出我们拆分RDBMS的重要性。</p>

<p>系统刚开始的时候，因为系统刚上线，用户不多，那个时候，所有的数据都放在了同一个数据库中，这个时候因为用户少压力小，一个数据库完全可以应付的了，但是随着运营那些哥们辛苦的呐喊和拼命的推广以后，突然有一天发现，oh,god,用户数量突然变多了起来，随之而来的就是数据库这哥们受不了，它终于在某一天大家都和惬意的时候挂掉啦。此时，咱们搞技术的哥们，就去看看究竟是啥原因，我们查了查以后，发现原来是数据库读取压力太大了，此时咱们都清楚是到了读写分离的时候，这个时候我们会配置一个server为master节点，然后配几个salve节点，这样以来通过读写分离，使得读取数据的压力分摊到了不同的salve节点上面，系统终于又恢复了正常，开始正常运行了。但是好景还是不长，有一天我们发现master这哥们撑不住了，它负载老高了，汗流浃背，随时都有翘掉的风险，这个时候就需要咱们垂直分区啦（也就是所谓的分库），比如对于一个电子商务系统来说，我们可以将商品信息，用户信息，交易信息分别存储到不同的数据库中，同时还可以针对商品信息的库采用master，salve模式，OK，通过分库以后，各个按照功能拆分的数据库写压力被分担到了不同的server上面，这样数据库的压力终于有恢复到正常状态。但是是不是这样，我们就可以高枕无忧了呢？NO,这个NO，不是我说的，是前辈们通过经验总结出来的，随着用户量的不断增加，你会发现系统中的某些表会变的异常庞大，比如好友关系表，店铺的参数配置表等，这个时候无论是写入还是读取这些表的数据，对数据库来说都是一个很耗费精力的事情，因此此时就需要我们进行“水平分区”了（这就是俗话说的分表，或者说sharding）.</p>

<p>OK,上面说了一大堆，无非就是告诉大家一个事实“数据库是系统中最不容易scale out的一层”，一个大型的互联网应用必然会经过一个从单一DB server,到Master/salve,再到垂直分区（分库），然后再到水平分区（分表，sharding）的过程，而在这个过程中，Master/salve 以及垂直分区相对比较容易，对应用的影响也不是很大，但是分表会引起一些棘手的问题，比如不能跨越多个分区join查询数据，如何平衡各个shards的负载等等，这个时候就需要一个通用的DAL框架来屏蔽底层数据存储对应用逻辑的影响，使得底层数据的访问对应用透明化。不过目前大的互联网公司都会有自己的一套通用的数据库访问框架来解决拆分对应用侵入性问题。</p>

<h1>5. 异步通信</h1>

<p>在”远程调用框架”的介绍中,我们说了一个大型的系统为了扩展性和伸缩性方面的需求,肯定是要进行拆分,但是拆分了以后,子系统之间如何通信就成了我们首要的问题,在”远程调用框架”小节中,我们说了同步通信在一个大型分布式系统中的应用,那么这一小节我们就来说说异步通信.好了,既然说到了异步通信,那么”消息中间件”就要登场了,采用异步通信这其实也是关系到系统的伸缩性,以及最大化的对各个子系统进行解耦.</p>

<p>说到异步通信，我们需要关注的一点是这里的异步一定是根据业务特点来的，一定是针对业务的异步，通常适合异步的场合是一些松耦合的通信场合，而对于本身业务上关联度比较大的业务系统之间，我们还是要采用同步通信比较靠谱。</p>

<p>OK,那么下一步我们说说异步能给系统带来什么样子的好处。<br/>
首先我们想想，假如系统有A和B两个子系统构成，假如A和B是同步通信的话，那么要想使得系统整体伸缩性提高必须同时对A和B进行伸缩，这就影响了对整个系统进行scale out.</p>

<p>其次，同步调用还会影响到可用性，从数学推理的角度来说，A同步调用B，如果A可用，那么B可用，逆否命题就是如果B不可用，那么A也不可用，这将大大影响到系统可用性。</p>

<p>再次，系统之间异步通信以后可以大大提高系统的响应性，使得每个请求的响应时间变短，从而提高用户体验，因此异步在提高了系统的伸缩性以及可用性的同时，也大大的增强了请求的响应性（当然了，请求的总体处理时间也许不会变少）。</p>

<p>最后，关于异步方面的讨论，我可以推荐大家一些资源：</p>

<ol>
<li><a href="http://www.ibm.com/developerworks/web/library/wa-aj-web2jee/?S_CMP=cn-a-wa&amp;S_TACT=105AGX52">J2EE meets web2.0</a></li>
<li><a href="http://www.jdon.com/37753">Ebay架构特点(HPTS 2009)</a></li>
</ol>


<h1>5. 非结构化数据存储</h1>

<p>在一个大型的互联网应用当中，我们会发现并不是所有的数据都是结构化的，比如一些配置文件，一个用户对应的动态，以及一次交易的快照等信息，这些信息一般不适合保存到RDBMS中，它们更符合一种Key-value的结构，另外还有一类数据，数据量非常的大，但是实时性要求不高，此时这些数据也需要通过另外的一种存储方式进行存储，另外一些静态文件，比如各个商品的图片，商品描述等信息，这些信息因为比较大，放入RDBMS会引起读取性能问题，从而影响到其它的数据读取性能，因此这些信息也需要和其它信息分开存储，而一般的互联网应用系统都会选择把这些信息保存到分布式文件系统中。</p>

<p>随着互联网的发展，业界从08年下半年开始逐渐流行了一个概念就是NOSQL。我们都知道根据CAP理论，一致性，可用性和分区容错性3者不能同时满足，最多只能同时满足两个，我们传统的关系数据采用了ACID的事务策略，而ACID的事务策略更加讲究的是一种高一致性而降低了可用性的需求，但是互联网应用往往对可用性的要求要略高于一致性的需求，这个时候我们就需要避免采用数据的ACID事务策略，转而采用BASE事务策略，BASE事务策略是基本可用性，事务软状态以及最终一致性的缩写，通过BASE事务策略，我们可以通过最终一致性来提升系统的可用性，这也是目前很多NOSQL产品所采用的策略，包括facebook 的cassandra,apache hbase,google bigtable等，这些产品非常适合一些非结构化的数据，比如key-value形式的数据存储，并且这些产品有个很好的优点就是水平伸缩性。目前公司也在研究和使用一些成熟的NOSQL产品。</p>

<h1>6. 监控、预警系统</h1>

<p>对于大型的系统来说，唯一可靠的就是<code>系统的各个部分是不可靠</code>。</p>

<p>因为一个大型的分布式系统中势必会涉及到各种各样的设备，比如网络交换机，普通PC机，各种型号的网卡，硬盘，内存等等，而这些东东都在数量非常多的时候，出现错误的概率也会变大，因此我们需要时时刻刻监控系统的状态，而监控也有粒度的粗细之分，粒度粗一点的话，我们需要对整个应用系统进行监控，比如目前的系统网络流量是多少，内存利用率是多少，IO，CPU的负载是多少，服务的访问压力是多少，服务的响应时间是多少等这一系列的监控，而细粒度一点的话，我们就需对比如应用中的某个功能，某个URL的访问量是多，每个页面的PV是多少，页面每天占用的带宽是多少，页面渲染时间是多少，静态资源比如图片每天占用的带宽是多少等等进行进一步细粒度的监控。因此一个监控系统就变得必不可少了。</p>

<p>前面说了一个监控系统的重要性，有了监控系统以后，更重要的是要和预警系统结合起来，比如当某个页面访问量增多的时候，系统能自动预警，某台Server的CPU和内存占用率突然变大的时候，系统也能自动预警，当并发请求丢失严重的时候，系统也能自动预警等等，这样以来通过监控系统和预警系统的结合可以使得我们能快速响应系统出现的问题，提高系统的稳定性和可用性。</p>

<h1>7. 配置统一管理</h1>

<p>一个大型的分布式应用，一般都是有很多节点构成的，如果每次一个新的节点加入都要更改其它节点的配置，或者每次删除一个节点也要更改配置的话，这样不仅不利于系统的维护和管理，同时也更加容易引入错误。另外很多时候集群中的很多系统的配置都是一样的，如果不进行统一的配置管理，就需要再所有的系统上维护一份配置，这样会造成配置的管理维护很麻烦，而通过一个统一的配置管理可以使得这些问题得到很好的解决，当有新的节点加入或者删除的时候，配置管理系统可以通知各个节点更新配置，从而达到所有节点的配置一致性，这样既方便也不会出错。</p>

<p>上面结合了自己的工作经验说了下构建互联网应用的时候的一些关注点。也欢迎各位感兴趣的同学一起讨论。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jvm内存模型以及垃圾收集策略解析系列（二）]]></title>
    <link href="http://imtiger.github.io/blog/2010/02/21/jvm-memory-and-gc-2/"/>
    <updated>2010-02-21T13:40:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2010/02/21/jvm-memory-and-gc-2</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://imtiger.github.io/images/2010/02/21/jvm-original-logo.jpg"></p>

<p>本文是<code>Jvm内存模型以及垃圾收集策略解析系列</code>第二篇，第一篇为<a href="http://imtiger.github.io/blog/2010/02/21/jvm-memory-and-gc/">Jvm内存模型以及垃圾收集策略解析系列(一)</a>。<br/>
本文之前发布在本人Iteye的<a href="http://xmuzyq.iteye.com">博客</a>上，换了新博客后，重新整理一下，发布在此，希望对Jvm 内存以及垃圾收集策略感兴趣的朋友有点帮助。</p>

<p><a href="http://imtiger.github.io/blog/2010/02/21/jvm-memory-and-gc/">Jvm内存模型以及垃圾收集策略解析系列(一)</a>介绍了下面的前3部分，本篇文章将介绍第4和第5部分</p>

<ol>
<li>Java虚拟机规范规定的Jvm 内存概念模型</li>
<li>HotSpot Jvm 内存的模型</li>
<li>常见的垃圾收集策略</li>
<li><code>HotSpot Jvm 垃圾收集策略</code></li>
<li><code>HotSpot Jvm 垃圾收集器的配置策略</code></li>
</ol>


<!-- more -->


<h1>4.HotSpot Jvm 垃圾收集策略</h1>

<p>GC的执行时要耗费一定的CPU资源和时间的，因此在JDK1.2以后，JVM引入了分代收集的策略，其中对新生代采用&#8221;Mark-Compact&#8221;策略，而对老生代采用了“Mark-Sweep&#8221;的策略。其中新生代的垃圾收集器命名为“minor gc”，老生代的GC命名为&#8221;Full Gc 或者Major GC&#8221;.其中用System.gc()强制执行的是Full Gc.
HotSpot Jvm的垃圾收集器按照并发性可以分为如下三种类型：</p>

<h2>4.1 串行收集器（Serial Collector）</h2>

<p>Serial Collector是指任何时刻都只有一个线程进行垃圾收集，这种策略有一个名字“stop the whole world&#8221;,它需要停止整个应用的执行。这种类型的收集器适合于单CPU的机器。
Serial Collector 有如下两个：</p>

<ol>
<li><p>Serial Copying Collector:<br/>
此种GC用-XX:UseSerialGC选项配置，它只用于<code>新生代</code>对象的收集。1.5.0以后.<br/>
<code>-XX:MaxTenuringThreshold</code>来设置对象复制的次数。当eden空间不够的时候，GC会将eden的活跃对象和一个名叫From survivor空间中尚不够资格放入Old代的对象复制到另外一个名字叫To Survivor的空间。而此参数就是用来说明到底From survivor中的哪些对象不够资格，假如这个参数设置为31，那么也就是说只有对象复制31次以后才算是有资格的对象。</p>

<blockquote><p>这里需要注意几个个问题：<br/>
From Survivor和To survivor的角色是不断的变化的，同一时间只有一块空间处于使用状态，这个空间就叫做From Survivor区，当复制一次后角色就发生了变化。<br/>
如果复制的过程中发现To survivor空间已经满了，那么就直接复制到old generation.<br/>
比较大的对象也会直接复制到Old generation,在开发中，我们应该尽量避免这种情况的发生。</p></blockquote></li>
<li><p>Serial  Mark-Compact Collector： <br/>
串行的标记-整理收集器是JDK5 update6之前默认的<code>老生代</code>的垃圾收集器，此收集使得内存碎片最少化，但是它需要暂停的时间比较长</p></li>
</ol>


<h2>4.2 并行收集器（Parallel Collector）</h2>

<p>Parallel Collector主要是为了应对多CPU，大数据量的环境。<br/>
Parallel Collector又可以分为以下三种：</p>

<ol>
<li>Parallel Copying Collector<br/>
此种GC用-XX:UseParNewGC参数配置,它主要用于<code>新生代</code>的收集,此GC可以配合CMS一起使用，适用于1.4.1以后。</li>
<li>Parallel Mark-Compact Collector<br/>
此种GC用-XX:UseParallelOldGC参数配置，此GC主要用于<code>老生代</code>对象的收集。适用于1.6.0以后。</li>
<li>Parallel scavenging Collector<br/>
此种GC用-XX:UseParallelGC参数配置，它是对<code>新生代</code>对象的垃圾收集器，但是它不能和CMS配合使用，它适合于比较大新生代的情况，此收集器起始于jdk 1.4.0。它比较适合于对吞吐量高于暂停时间的场合。</li>
</ol>


<p>串行收集器和并行收集器可以通过如下的图来表示：</p>

<p><img class="center" src="http://imtiger.github.io/images/2010/02/21/serial-and-parallel-gc.jpg"></p>

<h2>4.3 并发收集器 (Concurrent Collector)</h2>

<p>Concurrent Collector通过并行的方式进行垃圾收集，这样就减少了垃圾收集器收集一次的时间，在HotSpot Jvm中，我们称之为CMS GC,这种GC在实时性要求高于吞吐量的时候比较有用。此种GC可以用参数-XX:UseConcMarkSweepGC配置，此GC主要用于老生代和Perm代的收集。
并发收集器可以通过下图形象的描述：
<img class="center" src="http://imtiger.github.io/images/2010/02/21/concurrent-gc.jpg"></p>

<p>CMS GC有可能出现并发模型失败：</p>

<blockquote><p>并发模型失败：我们CMS GC在运行的时候，用户线程也在运行，当gc的速度比新增对象的速度慢的时候，或者说当正在GC的时候，老年代的空间不能满足用户线程内存分配的需求的时候，就会出现并发模型失败，出现并发模型失败的时候，JVM会触发一次stop-the-world的Full GC这将导致暂停时间过长。不过CMS GC提供了一个参数<code>-XX:CMSInitiatingOccupancyFraction</code>来指定当老年代的空间超过某个值的时候即触发GC。因此如果此参数设置的过高，可能会导致更多的并发模型失败。</p></blockquote>

<p>并发和并行收集器区别：</p>

<blockquote><p>对于并发和并行收集器，我们需要注意一点：并发收集器是指垃圾收集器线程和应用线程可以并发的执行，也就是清除的时候不需要stop the world，但是并行收集器指的的是可以多个线程并行的进行垃圾收集，并行收集器还是要暂停应用的（即所谓的stop the world）</p></blockquote>

<h1>5.HotSpot Jvm 垃圾收集器的配置策略</h1>

<p>通过上面的描述，我们知道HotSpot Jvm中都有哪些垃圾收集器供我们使用，接下来我们总结一下如何配置垃圾收集器。在继续之前我们需要明白，上面所讲的垃圾收集器有些用于新生代，有些用于老年代，并且不是任何两个都可以配对使用的，下面我们通过下图来形象的描述一下哪些收集器可以配对使用：
<img class="center" src="http://imtiger.github.io/images/2010/02/21/hotspot-gc-collectors.png"></p>

<p>Ok,知道新生代和老年代垃圾收集器都有哪些收集器以后，咋们接下来看看具体如何来选择垃圾收集器。这需要根据我们的应用特点来进行选择。下面我们分两种情况来分别描述一下不同情况下的垃圾收集配置策略。</p>

<h2>5.1 吞吐量优先</h2>

<p>吞吐量是指GC的时间与运行总时间的比值，比如系统运行了100分钟，而GC占用了一分钟，那么吞吐量就是99%，吞吐量优先一般运用于对响应性要求不高的场合，比如web应用，因为网络传输本来就有延迟的问题，GC造成的短暂的暂停使得用户以为是网络阻塞所致。<br/>
吞吐量优先可以通过-XX:GCTimeRatio来指定。当通过-XX:GCTimeRatio不能满足系统的要求以后，我们可以更加细致的来对JVM进行调优。<br/>
首先因为要求高吞吐量，这样就需要一个较大的Young generation，此时就需要引入“<code>Parallel scavenging Collector</code>”,可以通过参数：<code>-XX:UseParallelGC</code>来配置。</p>

<figure class='code'><figcaption><span>Jvm config</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">java</span> <span class="o">-</span><span class="n">server</span> <span class="o">-</span><span class="n">Xms3072m</span> <span class="o">-</span><span class="n">Xmx3072m</span> <span class="o">-</span><span class="nl">XX:</span><span class="n">NewSize</span><span class="o">=</span><span class="mi">2560</span><span class="n">m</span> <span class="o">-</span><span class="nl">XX:</span><span class="n">MaxNewSize</span><span class="o">=</span><span class="mi">2560</span> <span class="nl">XX:</span><span class="n">SurvivorRatio</span><span class="o">=</span><span class="mi">2</span> <span class="o">-</span> <span class="nl">XX:</span><span class="o">+</span><span class="n">UseParallelGC</span>
</span></code></pre></td></tr></table></div></figure>


<p>
当年轻代使用了&#8221;<code>Parallel scavenge collector</code>&ldquo;后，老生代就不能使用&#8221;CMS&#8221;GC了，在JDK1.6之前，此时老生代只能采用串行收集，而JDK1.6引入了并行版本的老生代收集器，可以用参数<code>-XX:UseParallelOldGC</code>来配置。</p>

<p>1.控制并行的线程数  <br/>
缺省情况下，Parallel scavenging Collector 会开启与cpu数量相同的线程进行并行的收集，但是也可以调节并行的线程数。假如你想用4个并行的线程去收集Young generation的话，那么就可以配置-XX:ParallelGCThreads=4,此时JVM的配置参数如下：</p>

<figure class='code'><figcaption><span>Jvm config</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">java</span> <span class="o">-</span><span class="n">server</span> <span class="o">-</span><span class="n">Xms3072m</span> <span class="o">-</span><span class="n">Xmx3072m</span> <span class="o">-</span><span class="nl">XX:</span><span class="n">NewSize</span><span class="o">=</span><span class="mi">2560</span><span class="n">m</span> <span class="o">-</span><span class="nl">XX:</span><span class="n">MaxNewSize</span><span class="o">=</span><span class="mi">2560</span> <span class="nl">XX:</span><span class="n">SurvivorRatio</span><span class="o">=</span><span class="mi">2</span> <span class="o">-</span><span class="nl">XX:</span><span class="o">+</span><span class="n">UseParallelGC</span> <span class="o">-</span><span class="nl">XX:</span><span class="n">ParallelGCThreads</span><span class="o">=</span><span class="mi">4</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.自动调节新生代    <br/>
在采用了&#8221;Parallel scavenge collector&#8221;后，此GC会根据运行时的情况自动调节survivor ratio来使得性能最优，因此&#8221;Parallel scavenge collector&#8221;应该总是开启此参数。此时JVM的参数配置如下：</p>

<figure class='code'><figcaption><span>Jvm config</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">java</span> <span class="o">-</span><span class="n">server</span> <span class="o">-</span><span class="n">Xms3072m</span> <span class="o">-</span><span class="n">Xmx3072m</span> <span class="o">-</span><span class="nl">XX:</span><span class="o">+</span><span class="n">UseParallelGC</span> <span class="o">-</span><span class="nl">XX:</span><span class="n">ParallelGCThreads</span><span class="o">=</span><span class="mi">4</span> <span class="o">-</span><span class="nl">XX:</span><span class="o">+</span><span class="n">UseAdaptiveSizePolicy</span>
</span></code></pre></td></tr></table></div></figure>


<h2>5.2 响应时间优先</h2>

<p>响应时间优先是指GC每次运行的时间不能太久，这种情况一般使用与对及时性要求很高的系统，比如股票系统等。</p>

<p>响应时间优先可以通过参数-XX:MaxGCPauseMillis来配置，配置以后JVM将会自动调节年轻代，老生代的内存分配来满足参数设置。</p>

<p>在一般情况下，JVM的默认配置就可以满足要求，只有默认配置不能满足系统的要求时候，才会根据具体的情况来对JVM进行性能调优。如果采用默认的配置不能满足系统的要求，那么此时就可以自己动手来调节。此时&#8221;Young generation&#8221;可以采用&#8221;Parallel copying collector&#8221;，而&#8221;Old generation&#8221;则可以采用&#8221;Concurrent Collector&#8221;.<br/>
举个例子来说，以下参数设置了新生代用Parallel Copying Collector，老生代采用CMS收集器。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">java</span> <span class="o">-</span><span class="n">server</span> <span class="o">-</span><span class="n">Xms512m</span> <span class="o">-</span><span class="n">Xmx512m</span>  <span class="o">-</span><span class="nl">XX:</span><span class="n">NewSize</span><span class="o">=</span><span class="mi">64</span><span class="n">m</span> <span class="o">-</span><span class="nl">XX:</span><span class="n">MaxNewSize</span><span class="o">=</span><span class="mi">64</span><span class="n">m</span> <span class="o">-</span><span class="nl">XX:</span><span class="n">SurvivorRatio</span><span class="o">=</span><span class="mi">2</span>  <span class="o">-</span><span class="nl">XX:</span><span class="o">+</span><span class="n">UseConcMarkSweepGC</span> <span class="o">-</span><span class="nl">XX:</span><span class="o">+</span><span class="n">UseParNewGC</span>
</span></code></pre></td></tr></table></div></figure>


<blockquote><p>此时需要注意两个问题：<br/>
1.如果没有指定-XX:+UseParNewGC，则采用默认的非并行版本的copy collector.<br/>
2.如果在一个单CPU的系统上设置了-XX:+UseParNewGC ,则默认还是采用缺省的copy collector.</p></blockquote>

<p>1.控制并行的线程数<br/>
默认情况下，Parallel copy collector启动和CPU数量一样的线程，也可以通过参数-XX:ParallelGCThreads来指定，比如你想用3个线程去进行并发的复制收集，那么可以改变上述参数如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">java</span> <span class="o">-</span><span class="n">server</span> <span class="o">-</span><span class="n">Xms512m</span> <span class="o">-</span><span class="n">Xmx512m</span> <span class="o">-</span><span class="nl">XX:</span><span class="n">NewSize</span><span class="o">=</span><span class="mi">64</span><span class="n">m</span>  <span class="o">-</span><span class="nl">XX:</span><span class="n">MaxNewSize</span><span class="o">=</span><span class="mi">64</span><span class="n">m</span> <span class="o">-</span><span class="nl">XX:</span><span class="n">SurvivorRatio</span><span class="o">=</span><span class="mi">2</span>        <span class="o">-</span><span class="nl">XX:</span><span class="n">ParallelGCThreads</span><span class="o">=</span><span class="mi">4</span> <span class="o">-</span><span class="nl">XX:</span><span class="o">+</span><span class="n">UseConcMarkSweepGC</span> <span class="o">-</span><span class="nl">XX:</span><span class="o">+</span><span class="n">UseParNewGC</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.控制并发收集的临界值 <br/>
默认情况下，CMS gc在&#8221;old generation&#8221;空间占用率高于68%的时候，就会进行垃圾收集，而如果想控制收集的临界值，可以通过参数：-XX:CMSInitiatingOccupancyFraction来控制，比如改变上述的JVM配置如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">java</span> <span class="o">-</span><span class="n">server</span> <span class="o">-</span><span class="n">Xms512m</span> <span class="o">-</span><span class="n">Xmx512m</span> <span class="o">-</span><span class="nl">XX:</span><span class="n">NewSize</span><span class="o">=</span><span class="mi">64</span><span class="n">m</span> <span class="o">-</span><span class="nl">XX:</span><span class="n">MaxNewSize</span><span class="o">=</span><span class="mi">64</span><span class="n">m</span> <span class="o">-</span><span class="nl">XX:</span><span class="n">SurvivorRatio</span><span class="o">=</span><span class="mi">2</span>  <span class="o">-</span><span class="nl">XX:</span><span class="n">ParallelGCThreads</span><span class="o">=</span><span class="mi">4</span> <span class="o">-</span><span class="nl">XX:</span><span class="o">+</span><span class="n">UseConcMarkSweepGC</span> <span class="o">-</span><span class="nl">XX:</span><span class="o">+</span><span class="n">UseParNewGC</span> <span class="o">-</span><span class="nl">XX:</span><span class="n">CMSInitiatingOccupancyFraction</span><span class="o">=</span><span class="mi">35</span>
</span></code></pre></td></tr></table></div></figure>


<p>此外顺便说一个参数：<code>-XX:+PrintCommandLineFlags</code> 通过此参数可以知道在没有显示指定内存配置和垃圾收集算法的情况下，JVM采用的默认配置。<br/>
比如我在自己的机器上面通过如下命令<code>java -XX:+PrintCommandLineFlags -version</code>得到的结果如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="o">-</span><span class="nl">XX:</span><span class="n">InitialHeapSize</span><span class="o">=</span><span class="mi">524747648</span> <span class="o">-</span><span class="nl">XX:</span><span class="n">MaxHeapSize</span><span class="o">=</span><span class="mi">8395962368</span> <span class="o">-</span><span class="nl">XX:</span><span class="n">ParallelGCThreads</span><span class="o">=</span><span class="mi">23</span> <span class="o">-</span><span class="nl">XX:</span><span class="o">+</span><span class="n">PrintCommandLineFlags</span> <span class="o">-</span><span class="nl">XX:</span><span class="o">+</span><span class="n">UseCompressedOops</span> <span class="o">-</span><span class="nl">XX:</span><span class="o">+</span><span class="n">UseParallelGC</span>
</span><span class='line'><span class="n">java</span> <span class="n">version</span> <span class="s">&quot;1.6.0_25&quot;</span>
</span><span class='line'><span class="n">Java</span><span class="o">(</span><span class="n">TM</span><span class="o">)</span> <span class="n">SE</span> <span class="n">Runtime</span> <span class="n">Environment</span> <span class="o">(</span><span class="n">build</span> <span class="mf">1.6</span><span class="o">.</span><span class="mi">0</span><span class="n">_25</span><span class="o">-</span><span class="n">b06</span><span class="o">)</span>
</span><span class='line'><span class="n">Java</span> <span class="nf">HotSpot</span><span class="o">(</span><span class="n">TM</span><span class="o">)</span> <span class="mi">64</span><span class="o">-</span><span class="n">Bit</span> <span class="n">Server</span> <span class="n">VM</span> <span class="o">(</span><span class="n">build</span> <span class="mf">20.0</span><span class="o">-</span><span class="n">b11</span><span class="o">,</span> <span class="n">mixed</span> <span class="n">mode</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>从输出可以清楚的看到JVM通过自己检测硬件配置而给出的缺省配置。</p>

<p>最后附上一些JVM 垃圾收集方面的文章供大家参考：<br/>
<a href="http://www.ibm.com/developerworks/library/j-jtp10283/index.html?S_TACT=105AGX52&amp;S_CMP=cn-a-j">Java theory and practice: A brief history of garbage collection</a> <br/>
<a href="http://www.ibm.com/developerworks/library/j-jtp11253/index.html?S_TACT=105AGX52&amp;S_CMP=cn-a-j">Java theory and practice: Garbage collection in the HotSpot JVM</a><br/>
<a href="https://blogs.oracle.com/poonam/entry/understanding_cms_gc_logs"> Understanding CMS GC Logs </a> <br/>
<a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">Java HotSpot VM Options</a>
<a href="http://docs.oracle.com/javase/6/docs/technotes/guides/vm/server-class.html">Server-Class Machine Detection</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jvm内存模型以及垃圾收集策略解析系列（一）]]></title>
    <link href="http://imtiger.github.io/blog/2010/02/21/jvm-memory-and-gc/"/>
    <updated>2010-02-21T09:33:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2010/02/21/jvm-memory-and-gc</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://imtiger.github.io/images/2010/02/21/jvm-original-logo.jpg">
本文之前发布在本人Iteye的<a href="http://xmuzyq.iteye.com">博客</a>上，换了新博客后，重新整理一下，发布在此，希望对Jvm 内存以及垃圾收集策略感兴趣的朋友有点帮助。</p>

<p>本文主要内容分为如下几部分：</p>

<ol>
<li><code>Java虚拟机规范规定的Jvm 内存概念模型</code></li>
<li><code>HotSpot Jvm 内存的模型</code></li>
<li><code>常见的垃圾收集策略</code></li>
<li>HotSpot Jvm 垃圾收集策略</li>
<li>HotSpot Jvm 垃圾收集器的配置策略<br/>
本篇文章只涉及1，2，3部分，第4和5部分<a href="http://imtiger.github.io/blog/2010/02/21/jvm-memory-and-gc-2/">Jvm内存模型以及垃圾收集策略解析系列(二)</a>文章我们再来说。</li>
</ol>


<!-- more -->


<h1>1.Java虚拟机内存概念模型</h1>

<p>在本文开始之前，首先我们这里要明确一点，Jvm的内存模型分为<code>Java 虚拟机规范规定的概念模型</code>以及具体厂商的<code>实现模型</code>。不同的厂商的Jvm在实现方式上可能会存在差别，本文中如果没有特别指出，Jvm 默认都指HotSpot Jvm。</p>

<p>OK，明确了上面一点以后，咋们首先来看一下<code>Java 虚拟机规范</code>对Jvm 内存模型的要求，咋们具体可以参考下图：<br/>
<img class="center" src="http://imtiger.github.io/images/2010/02/21/jvm-memory-mode.png"></p>

<p>由上图可以看出Jvm 运行时的内存主要分为两部分：</p>

<ol>
<li><p>所有线程共享的区域<br/>
 线程共享的区域分为又分为下面两部分：</p>

<ol>
<li>方法区<br/>
方法区主要存放虚拟机中已经加载的类的信息，静态变量，常量等。方法区中有一块非常重要的区域<code>运行时常量池</code>,我们知道Java Class的文件结构中有一个叫<code>常量池</code>的结构，它主要存放了编译器生成的各种字面常量和符号引用，这部分的内容也将放到运行时常量池。</li>
<li>堆<br/>
堆中存放了Java 对象，现代虚拟机，对于堆又进行了进一步的划分，具体细节到下面的HotSpot jvm 的实现中再来说说。</li>
</ol>
</li>
<li><p>线程独享的区域</p>

<ol>
<li>Java虚拟机栈<br/>
Java 方法在运行的时候，虚拟机会分配给每次方法调用一个<code>栈帧</code>,栈帧中包含了局部变量表，操作数栈，方法出口等信息。</li>
<li>本地方法栈<br/>
本地方法栈是为Java 中执行Native 方法服务的，作用和Java 虚拟机栈是一样的。</li>
<li>程序计数器 <br/>
每个线程都会有自己的程序计数器方面在执行Java 方法的时候，能顺利的找到下面要执行的指令。</li>
</ol>
</li>
</ol>


<h1>2.HotSpot jvm内存实现模型</h1>

<p>Ok,上面说了Java 虚拟机规范规定的虚拟机概念模型中的内存布局，接下来我们以Sun公司的HopSpot jvm为例（现以及被Oracle 收购），来具体的看看JVM的内存模型和垃圾收集方面的知识。</p>

<p>Java HotSopt jvm 将JVM的堆内存分为了几个区域，我们可以通过下图来形象的描述：
<img class="center" src="http://imtiger.github.io/images/2010/02/21/hotsopt-jvm-memory.jpg"></p>

<p>从上图我们可以清晰的看到HotSpot jvm 将堆分为如下三部分：</p>

<ol>
<li><p>新生代（Young）<br/>
新生代被划分为三部分，Eden区和两个大小严格相同的Survivor区，其中Survivor区间，某一时刻只有其中一个是被使用的，另外一个留做垃圾收集时复制对象用，在Young区间变满的时候，minor GC就会将存活的对象移到空闲的Survivor区间中，根据JVM的策略，在经过几次垃圾收集后，仍然存活于Survivor的对象将被移动到Tenured区间。</p></li>
<li><p>老年代（Tenured）<br/>
Tenured区主要保存生命周期长的对象，一般是一些老的对象，当一些对象在Young复制转移一定的次数以后，对象就会被转移到Tenured区，一般如果系统中用了application级别的缓存，缓存中的对象往往会被转移到这一区间。</p></li>
<li><p>持久代（Perm）<br/>
Perm代主要保存class,method,filed对象，这部分的空间一般不会溢出，除非一次性加载了很多的类，不过在涉及到热部署的应用服务器的时候，有时候会遇到java.lang.OutOfMemoryError : PermGen space 的错误，造成这个错误的很大原因就有可能是每次都重新部署，但是重新部署后，类的class没有被卸载掉，这样就造成了大量的class对象保存在了perm中，这种情况下，一般重新启动应用服务器可以解决问题。</p>

<blockquote><p>说到持久代，我们有必要来说一下虚拟机概念模型和实现模型方面的差异，在HotSpot虚拟机的实现中利用持久代实现了概念模型的方法区。</p></blockquote></li>
</ol>


<p>OK,接下来我们再来看看 HotSpot jvm都给我们提供了哪些参数来对内存进行配置：</p>

<ul>
<li>配置总内存<br/>
<code>-Xms</code> ：指定了JVM初始启动以后初始化内存<br/>
<code>-Xmx</code>：指定JVM堆得最大内存，在JVM启动以后，会分配-Xmx参数指定大小的内存给JVM，但是不一定全部使用，JVM会根据-Xms参数来调节真正用于JVM的内存<br/>
-Xmx-Xms之差就是三个Virtual空间的大小</li>
<li>配置新生代 <br/>
<code>-Xmn</code>: 参数设置了年轻代的大小 <br/>
<code>-XX:SurvivorRatio</code>: 表示eden和一个surivivor的比例，缺省值为8.假如<code>-XX:SurvivorRatio=32</code>意味着eden和一个survivor的比值是32：1，这样一个Survivor就占Young区的1/34.</li>
<li>配置老年代  <br/>
<code>-XX:NewRatio</code>: 表示年老年代和新生代内存的比例，缺省值为2.假如<code>-XX:NewRatio=8</code>意味着tenured 和 young的比值8：1</li>
<li>配置持久代<br/>
<code>-XX:MaxPermSize</code>：表示持久代的最大值</li>
</ul>


<p>有了上面虚拟机的内存模型的相关介绍做为铺垫，我们接着来看一下有关垃圾收集方面的知识。</p>

<h1>3.常见的垃圾收集策略</h1>

<p>垃圾收集提供了内存管理的机制，使得应用程序不需要在关注内存如何释放，内存用完后，垃圾收集会进行收集，这样就减轻了因为人为的管理内存而造成的错误，比如在C++语言里，出现内存泄露时很常见的。Java语言是目前使用最多的依赖于垃圾收集器的语言，但是垃圾收集器策略从20世纪60年代就已经流行起来了，比如Smalltalk,Eiffel等编程语言也集成了垃圾收集器的机制。</p>

<p>所有的垃圾收集算法都面临同一个问题，那就是找出应用程序不可到达的内存块，将其释放，这里面得不可到达主要是指应用程序已经没有内存块的引用了，而在JAVA中，某个对象对应用程序是可到达的是指：这个对象被根（根主要是指类的静态变量，常量或者活跃在所有线程栈的对象的引用）引用或者对象被另一个可到达的对象引用，可以通过下图来形象的描述：
<img class="center" src="http://imtiger.github.io/images/2010/02/21/root-avaliable.jpg"></p>

<p>下面我们介绍一下几种常见的垃圾收集策略：</p>

<h2>1. Reference Counting(引用计数）</h2>

<p>引用计数是最简单直接的一种方式，这种方式在每一个对象中增加一个引用的计数，这个计数代表当前程序有多少个引用引用了此对象，如果此对象的引用计数变为0，那么此对象就可以作为垃圾收集器的目标对象来收集。<br/>
优点：<br/>
简单，直接，不需要暂停整个应用<br/>
缺点：<br/>
需要编译器的配合，编译器要生成特殊的指令来进行引用计数的操作，比如每次将对象赋值给新的引用，或者者对象的引用超出了作用域等。<br/>
不能处理循环引用的问题</p>

<h2>2. 跟踪收集器</h2>

<p>跟踪收集器首先要暂停整个应用程序，然后开始从根对象扫描整个堆，判断扫描的对象是否有对象引用。
如果每次扫描整个堆，那么势必让GC的时间变长，从而影响了应用本身的执行。因此在JVM里面采用了分代收集，在新生代收集的时候minor gc只需要扫描新生代，而不需要扫描老生代。<br/>
JVM采用了分代收集以后，minor gc只扫描新生代，但是minor gc怎么判断是否有老生代的对象引用了新生代的对象，JVM采用了卡片标记的策略，卡片标记将老生代分成了一块一块的，划分以后的每一个块就叫做一个卡片，JVM采用卡表维护了每一个块的状态，当JAVA程序运行的时候，如果发现老生代对象引用或者释放了新生代对象的引用，那么就JVM就将卡表的状态设置为脏状态，这样每次minor gc的时候就会只扫描被标记为脏状态的卡片，而不需要扫描整个堆。具体如下图：<br/>
<img class="center" src="http://imtiger.github.io/images/2010/02/21/jvm-memory-table-card.jpg">
上面说了Jvm 需要判断对象是否有引用存在，而Java 中的引用又分为了如下几种，不同种类的引用对垃圾收集有不同的影响，下面我们分开描述一下：<br/>
<code>1.Strong Reference(强引用)</code><br/>
强引用是JAVA中默认采用的一种方式，我们平时创建的引用都属于强引用。如果一个对象没有强引用，那么对象就会被回收。<br/>
<code>2.Soft Reference(软引用)</code>
软引用的对象在GC的时候不会被回收，只有当内存不够用的时候才会真正的回收，因此软引用适合缓存的场合，这样使得缓存中的对象可以尽量的再内存中待长久一点。 <br/>
<code>3.Weak Reference(弱引用)</code><br/>
弱引用有利于对象更快的被回收，假如一个对象没有强引用只有弱引用，那么在GC后，这个对象肯定会被回收。<br/>
<code>4.Phantom reference(幽灵引用)</code> <br/>
幽灵引用说是引用，但是你不能通过幽灵引用来获取对象实例，它主要目的是为了当设置了幽灵引用的对象在被回收的时候可以收到通知。 <br/>
跟踪收集器常见的有如下几种：</p>

<h3>2.1 Mark-Sweep Collector(标记-清除收集器）</h3>

<p>标记清除收集器最早由Lisp的发明人于1960年提出，标记清除收集器停止所有的工作，从根扫描每个活跃的对象，然后标记扫描过的对象，标记完成以后，清除那些没有被标记的对象。<br/>
优点：<br/>
解决循环引用的问题<br/>
不需要编译器的配合，从而就不执行额外的指令<br/>
缺点：  <br/>
每个活跃的对象都要进行扫描，收集暂停的时间比较长。</p>

<h3>2.2 Copying Collector(复制收集器）</h3>

<p>复制收集器将内存分为两块一样大小空间，某一个时刻，只有一个空间处于活跃的状态，当活跃的空间满的时候，GC就会将活跃的对象复制到未使用的空间中去，原来不活跃的空间就变为了活跃的空间。复制收集器具体过程可以参考下图：
<img class="center" src="http://imtiger.github.io/images/2010/02/21/copy-gc.jpg">
优点： <br/>
只扫描可以到达的对象，不需要扫描所有的对象，从而减少了应用暂停的时间<br/>
缺点：<br/>
需要额外的空间消耗，某一个时刻，总是有一块内存处于未使用状态<br/>
复制对象需要一定的开销</p>

<h3>2.3 Mark-Compact Collector(标记-整理收集器）</h3>

<p>标记整理收集器汲取了标记清除和复制收集器的优点，它分两个阶段执行，在第一个阶段，首先扫描所有活跃的对象，并标记所有活跃的对象，第二个阶段首先清除未标记的对象，然后将活跃的的对象复制到堆得底部。标记整理收集器的过程示意图请参考下图：
<img class="center" src="http://imtiger.github.io/images/2010/02/21/mark-compact-collector.jpg">
Mark-compact策略极大的减少了内存碎片，并且不需要像Copy Collector一样需要两倍的空间。</p>

<p>本篇文章介绍了Jvm内存的概念模型，HotSpot jvm内存实现模型，以及常见的垃圾收集策略，本系列的下篇文章将介绍，HotSpot jvm中的内存模型以及HotSpot Jvm 垃圾收集器的配置策略。下篇请参加如下文章：<br/>
<a href="http://imtiger.github.io/blog/2010/02/21/jvm-memory-and-gc-2/">Jvm内存模型以及垃圾收集策略解析系列（二)</a></p>

<p>最后附上一些JVM 垃圾收集方面的文章供大家参考：<br/>
<a href="http://www.ibm.com/developerworks/library/j-jtp10283/index.html?S_TACT=105AGX52&amp;S_CMP=cn-a-j">Java theory and practice: A brief history of garbage collection</a> <br/>
<a href="http://www.ibm.com/developerworks/library/j-jtp11253/index.html?S_TACT=105AGX52&amp;S_CMP=cn-a-j">Java theory and practice: Garbage collection in the HotSpot JVM</a><br/>
<a href="https://blogs.oracle.com/poonam/entry/understanding_cms_gc_logs"> Understanding CMS GC Logs </a> <br/>
<a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">Java HotSpot VM Options</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java Classloader机制解析]]></title>
    <link href="http://imtiger.github.io/blog/2009/11/09/java-classloader/"/>
    <updated>2009-11-09T10:10:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2009/11/09/java-classloader</id>
    <content type="html"><![CDATA[<p>做Java开发，对于ClassLoader的机制是必须要熟悉的基础知识，本文针对Java ClassLoader的机制做一个简要的总结。因为不同的JVM的实现不同，本文所描述的内容均只限于Hotspot Jvm.</p>

<p>本文将会从JDK默认的提供的ClassLoader，双亲委托模型，如何自定义ClassLoader以及Java中打破双亲委托机制的场景四个方面入手去讨论和总结一下。</p>

<h1>JDK默认ClassLoader</h1>

<p>JDK 默认提供了如下几种ClassLoader</p>

<ol>
<li>Bootstrp loader<br/>
Bootstrp加载器是用C++语言写的，它是在Java虚拟机启动后初始化的，它主要负责加载<code>%JAVA_HOME%/jre/lib</code>,<code>-Xbootclasspath</code>参数指定的路径以及<code>%JAVA_HOME%/jre/classes</code>中的类。</li>
</ol>


<!-- more -->


<ol>
<li><p>ExtClassLoader  <br/>
Bootstrp loader加载ExtClassLoader,并且将ExtClassLoader的父加载器设置为Bootstrp loader.ExtClassLoader是用Java写的，具体来说就是sun.misc.Launcher$ExtClassLoader，ExtClassLoader主要加载<code>%JAVA_HOME%/jre/lib/ext</code>，此路径下的所有classes目录以及<code>java.ext.dirs</code>系统变量指定的路径中类库。</p></li>
<li><p>AppClassLoader <br/>
Bootstrp loader加载完ExtClassLoader后，就会加载AppClassLoader,并且将AppClassLoader的父加载器指定为ExtClassLoader。AppClassLoader也是用Java写成的，它的实现类是sun.misc.Launcher$AppClassLoader，另外我们知道ClassLoader中有个<code>getSystemClassLoader</code>方法,此方法返回的正是AppclassLoader.AppClassLoader主要负责加载classpath所指定的位置的类或者是jar文档，它也是Java程序默认的类加载器。</p></li>
</ol>


<p>综上所述，它们之间的关系可以通过下图形象的描述：
<img class="center" src="http://imtiger.github.io/images/2009/10/09/java_classloader_hierarchy.png"></p>

<h1>双亲委托模型</h1>

<p>Java中ClassLoader的加载采用了双亲委托机制，采用双亲委托机制加载类的时候采用如下的几个步骤：</p>

<ol>
<li>当前ClassLoader首先从自己已经加载的类中查询是否此类已经加载，如果已经加载则直接返回原来已经加载的类。

<blockquote><p>每个类加载器都有自己的加载缓存，当一个类被加载了以后就会放入缓存，等下次加载的时候就可以直接返回了。</p></blockquote></li>
<li>当前classLoader的缓存中没有找到被加载的类的时候，委托父类加载器去加载，父类加载器采用同样的策略，首先查看自己的缓存，然后委托父类的父类去加载，一直到bootstrp ClassLoader.</li>
<li>当所有的父类加载器都没有加载的时候，再由当前的类加载器加载，并将其放入它自己的缓存中，以便下次有加载请求的时候直接返回。</li>
</ol>


<p>说到这里大家可能会想，Java为什么要采用这样的委托机制？理解这个问题，我们引入另外一个关于Classloader的概念<strong>“命名空间”</strong>，它是指要确定某一个类，需要类的全限定名以及加载此类的ClassLoader来共同确定。也就是说即使两个类的全限定名是相同的，但是因为不同的ClassLoader加载了此类，那么在JVM中它是不同的类。明白了命名空间以后，我们再来看看委托模型。采用了委托模型以后加大了不同的ClassLoader的交互能力，比如上面说的，我们JDK本生提供的类库，比如hashmap,linkedlist等等，这些类由bootstrp类加载器加载了以后，无论你程序中有多少个类加载器，那么这些类其实都是可以共享的，这样就避免了不同的类加载器加载了同样名字的不同类以后造成混乱。</p>

<h1>如何自定义ClassLoader</h1>

<p>Java除了上面所说的默认提供的classloader以外，它还容许应用程序可以自定义classloader，那么要想自定义classloader我们需要通过继承<code>java.lang.ClassLoader</code>来实现,接下来我们就来看看再自定义Classloader的时候，我们需要注意的几个重要的方法：</p>

<h2>1.loadClass 方法</h2>

<figure class='code'><figcaption><span>loadClass method declare</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">loadClass</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span>
</span><span class='line'>                   <span class="kd">throws</span> <span class="n">ClassNotFoundException</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面是loadClass方法的原型声明，上面所说的双亲委托机制的实现其实就实在此方法中实现的。下面我们就来看看此方法的代码来看看它到底如何实现双亲委托的。</p>

<figure class='code'><figcaption><span>loadClass method implement</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">loadClass</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">ClassNotFoundException</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="nf">loadClass</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>从上面可以看出loadClass方法调用了loadcClass(name,false)方法，那么接下来我们再来看看另外一个loadClass方法的实现。</p>

<figure class='code'><figcaption><span>Class<?> loadClass(String name, boolean resolve)</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">protected</span> <span class="kd">synchronized</span> <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">loadClass</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">resolve</span><span class="o">)</span>
</span><span class='line'>  <span class="kd">throws</span> <span class="n">ClassNotFoundException</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>  <span class="c1">// First, check if the class has already been loaded</span>
</span><span class='line'>  <span class="n">Class</span> <span class="n">c</span> <span class="o">=</span> <span class="n">findLoadedClass</span><span class="o">(</span><span class="n">name</span><span class="o">);</span><span class="c1">//检查class是否已经被加载过了</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="o">(</span><span class="n">parent</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">c</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="na">loadClass</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span> <span class="c1">//如果没有被加载，且指定了父类加载器，则委托父加载器加载。</span>
</span><span class='line'>      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">c</span> <span class="o">=</span> <span class="n">findBootstrapClass0</span><span class="o">(</span><span class="n">name</span><span class="o">);</span><span class="c1">//如果没有父类加载器，则委托bootstrap加载器加载</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>      <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ClassNotFoundException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="c1">// If still not found, then invoke findClass in order</span>
</span><span class='line'>          <span class="c1">// to find the class.</span>
</span><span class='line'>          <span class="n">c</span> <span class="o">=</span> <span class="n">findClass</span><span class="o">(</span><span class="n">name</span><span class="o">);</span><span class="c1">//如果父类加载没有加载到，则通过自己的findClass来加载。</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">resolve</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">resolveClass</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">c</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码，我加了注释通过注释可以清晰看出loadClass的双亲委托机制是如何工作的。
这里我们需要注意一点就是<code>public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException</code>没有被标记为final，也就意味着我们是可以override这个方法的，也就是说双亲委托机制是可以打破的。另外上面注意到有个findClass方法，接下来我们就来说说这个方法到底是搞末子的。</p>

<h2>2.findClass</h2>

<p>我们查看<code>java.lang.ClassLoader</code>的源代码，我们发现findClass的实现如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'> <span class="kd">protected</span> <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">findClass</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">ClassNotFoundException</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">throw</span> <span class="k">new</span> <span class="nf">ClassNotFoundException</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们可以看出此方法默认的实现是直接抛出异常，其实这个方法就是留给我们应用程序来override的。那么具体的实现就看你的实现逻辑了，你可以从磁盘读取，也可以从网络上获取class文件的字节流，获取class二进制了以后就可以交给<code>defineClass</code>来实现进一步的加载。defineClass我们再下面再来描述。
ok，通过上面的分析，我们可以得出如下结论：</p>

<blockquote><p>我们在写自己的ClassLoader的时候，如果想遵循双亲委托机制，则只需要override <code>findClass</code>.</p></blockquote>

<h2>3.defineClass</h2>

<p>我们首先还是来看看defineClass的源码：</p>

<figure class='code'><figcaption><span>defineClass</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">protected</span> <span class="kd">final</span> <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">defineClass</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">b</span><span class="o">,</span> <span class="kt">int</span> <span class="n">off</span><span class="o">,</span> <span class="kt">int</span> <span class="n">len</span><span class="o">)</span>
</span><span class='line'>  <span class="kd">throws</span> <span class="n">ClassFormatError</span><span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="nf">defineClass</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">off</span><span class="o">,</span> <span class="n">len</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>从上面的代码我们看出此方法被定义为了final，这也就意味着此方法不能被Override，其实这也是jvm留给我们的唯一的入口，通过这个唯一的入口，jvm保证了类文件必须符合Java虚拟机规范规定的类的定义。此方法最后会调用native的方法来实现真正的类的加载工作。</p>

<blockquote><p>Ok,通过上面的描述，我们来思考下面一个问题：<br/>
假如我们自己写了一个<code>java.lang.String</code>的类，我们是否可以替换调JDK本身的类？</p>

<blockquote><p>答案是否定的。我们不能实现。为什么呢？我看很多网上解释是说双亲委托机制解决这个问题，其实不是非常的准确。因为双亲委托机制是可以打破的，你完全可以自己写一个classLoader来加载自己写的<code>java.lang.String</code>类，但是你会发现也不会加载成功，具体就是因为针对java.*开头的类，jvm的实现中已经保证了必须由bootstrp来加载。</p></blockquote></blockquote>

<h1>不遵循“双亲委托机制”的场景</h1>

<p>上面说了双亲委托机制主要是为了实现不同的ClassLoader之间加载的类的交互问题，被大家公用的类就交由父加载器去加载，但是Java中确实也存在父类加载器加载的类需要用到子加载器加载的类的情况。下面我们就来说说这种情况的发生。</p>

<p>Java中有一个SPI(Service Provider Interface)标准,使用了SPI的库，比如JDBC，JNDI等，我们都知道JDBC需要第三方提供的驱动才可以，而驱动的jar包是放在我们应用程序本身的classpath的，而jdbc 本身的api是jdk提供的一部分，它已经被bootstrp加载了，那第三方厂商提供的实现类怎么加载呢？这里面JAVA引入了线程上下文类加载的概念，线程类加载器默认会从父线程继承，如果没有指定的话，默认就是系统类加载器（AppClassLoader）,这样的话当加载第三方驱动的时候，就可以通过线程的上下文类加载器来加载。<br/>
另外为了实现更灵活的类加载器OSGI以及一些Java app server也打破了双亲委托机制。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java常见内存溢出异常分析]]></title>
    <link href="http://imtiger.github.io/blog/2009/10/02/java-oom-summary/"/>
    <updated>2009-10-02T16:28:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2009/10/02/java-oom-summary</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://ww3.sinaimg.cn/bmiddle/a43155b1gw1e32ay9f202g.gif">
Java虚拟机规范规定JVM的内存分为了好几块，比如堆，栈，程序计数器，方法区等，而Hotspot jvm的实现中，将堆内存分为了三部分，新生代，老年代，持久带，其中持久带实现了规范中规定的方法区，而内存模型中不同的部分都会出现相应的OOM错误，接下来我们就分开来讨论一下。</p>

<h1>栈溢出(StackOverflowError)</h1>

<p>栈溢出抛出<code>java.lang.StackOverflowError</code>错误，出现此种情况是因为方法运行的时候栈的深度超过了虚拟机容许的最大深度所致。</p>

<p>出现这种情况，一般情况下是程序错误所致的，比如写了一个死递归，就有可能造成此种情况。
下面我们通过一段代码来模拟一下此种情况的内存溢出。</p>

<!-- more -->


<figure class='code'><figcaption><span>OOMTest.java</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">java.lang.*</span><span class="o">;</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">OOMTest</span><span class="o">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">stackOverFlowMethod</span><span class="o">(){</span>
</span><span class='line'>      <span class="n">stackOverFlowMethod</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">...</span> <span class="n">args</span><span class="o">){</span>
</span><span class='line'>      <span class="n">OOMTest</span> <span class="n">oom</span> <span class="o">=</span> <span class="k">new</span> <span class="n">OOMTest</span><span class="o">();</span>
</span><span class='line'>      <span class="n">oom</span><span class="o">.</span><span class="na">stackOverFlowMethod</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>运行上面的代码，会抛出如下的异常：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Exception</span> <span class="n">in</span> <span class="n">thread</span> <span class="s">&quot;main&quot;</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">StackOverflowError</span>
</span><span class='line'>        <span class="n">at</span> <span class="n">OOMTest</span><span class="o">.</span><span class="na">stackOverFlowMethod</span><span class="o">(</span><span class="n">OOMTest</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">6</span><span class="o">)</span>    
</span></code></pre></td></tr></table></div></figure>


<h1>堆溢出(OutOfMemoryError:java heap space)</h1>

<p>堆内存溢出的时候，虚拟机会抛出<code>java.lang.OutOfMemoryError:java heap space</code>,出现此种情况的时候，我们需要根据内存溢出的时候产生的dump文件来具体分析（需要增加<code>-XX:+HeapDumpOnOutOfMemoryError</code>jvm启动参数）。出现此种问题的时候有可能是内存泄露，也有可能是内存溢出了。<br/>
如果内存泄露，我们要找出泄露的对象是怎么被GC ROOT引用起来，然后通过引用链来具体分析泄露的原因。<br/>
如果出现了内存溢出问题，这往往是程序本生需要的内存大于了我们给虚拟机配置的内存，这种情况下，我们可以采用调大-Xmx来解决这种问题。</p>

<p>下面我们通过如下的代码来演示一下此种情况的溢出：</p>

<figure class='code'><figcaption><span>OOMTest.java</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">java.lang.*</span><span class="o">;</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">OOMTest</span><span class="o">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">...</span> <span class="n">args</span><span class="o">){</span>
</span><span class='line'>                <span class="n">List</span><span class="o">&lt;</span><span class="kt">byte</span><span class="o">[]&gt;</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="kt">byte</span><span class="o">[]&gt;();</span>
</span><span class='line'>                <span class="n">buffer</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">10</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="o">]);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">}</span>  
</span></code></pre></td></tr></table></div></figure>


<p>我们通过如下的命令运行上面的代码：</p>

<p><code>java -verbose:gc -Xmn10M -Xms20M -Xmx20M -XX:+PrintGC OOMTest</code></p>

<p>程序输入如下的信息：</p>

<figure class='code'><figcaption><span>Terminal output</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="o">[</span><span class="n">GC</span> <span class="mi">1180</span><span class="n">K</span><span class="o">-&gt;</span><span class="mi">366</span><span class="n">K</span><span class="o">(</span><span class="mi">19456</span><span class="n">K</span><span class="o">),</span> <span class="mf">0.0037311</span> <span class="n">secs</span><span class="o">]</span>
</span><span class='line'><span class="o">[</span><span class="n">Full</span> <span class="n">GC</span> <span class="mi">366</span><span class="n">K</span><span class="o">-&gt;</span><span class="mi">330</span><span class="n">K</span><span class="o">(</span><span class="mi">19456</span><span class="n">K</span><span class="o">),</span> <span class="mf">0.0098740</span> <span class="n">secs</span><span class="o">]</span>
</span><span class='line'><span class="o">[</span><span class="n">Full</span> <span class="n">GC</span> <span class="mi">330</span><span class="n">K</span><span class="o">-&gt;</span><span class="mi">292</span><span class="n">K</span><span class="o">(</span><span class="mi">19456</span><span class="n">K</span><span class="o">),</span> <span class="mf">0.0090244</span> <span class="n">secs</span><span class="o">]</span>
</span><span class='line'><span class="n">Exception</span> <span class="n">in</span> <span class="n">thread</span> <span class="s">&quot;main&quot;</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">OutOfMemoryError</span><span class="o">:</span> <span class="n">Java</span> <span class="n">heap</span> <span class="n">space</span>
</span><span class='line'>        <span class="n">at</span> <span class="n">OOMTest</span><span class="o">.</span><span class="na">main</span><span class="o">(</span><span class="n">OOMTest</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">7</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>从运行结果可以看出，JVM进行了一次Minor gc和两次的Major gc，从Major gc的输出可以看出，gc以后old区使用率为134K，而字节数组为10M，加起来大于了old generation的空间，所以抛出了异常，如果调整-Xms21M,-Xmx21M,那么就不会触发gc操作也不会出现异常了。</p>

<blockquote><p>通过上面的实验其实也从侧面验证了一个结论：<strong>当对象大于新生代剩余内存的时候，将直接放入老年代，当老年代剩余内存还是无法放下的时候，出发垃圾收集，收集后还是不能放下就会抛出内存溢出异常了</strong></p></blockquote>

<h1>持久带溢出(OutOfMemoryError: PermGen space)</h1>

<p>我们知道Hotspot jvm通过持久带实现了Java虚拟机规范中的方法区，而运行时的常量池就是保存在方法区中的，因此持久带溢出有可能是运行时常量池溢出，也有可能是方法区中保存的class对象没有被及时回收掉或者class信息占用的内存超过了我们配置。当持久带溢出的时候抛出<code>java.lang.OutOfMemoryError: PermGen space</code>。 <br/>
我在工作可能在如下几种场景下出现此问题。</p>

<ol>
<li>使用一些应用服务器的热部署的时候，我们就会遇到热部署几次以后发现内存溢出了，这种情况就是因为每次热部署的后，原来的class没有被卸载掉。</li>
<li>如果应用程序本身比较大，涉及的类库比较多，但是我们分配给持久带的内存（通过-XX:PermSize和-XX:MaxPermSize来设置）比较小的时候也可能出现此种问题。</li>
<li>一些第三方框架，比如spring,hibernate都通过字节码生成技术（比如CGLib）来实现一些增强的功能，这种情况可能需要更大的方法区来存储动态生成的Class文件。</li>
</ol>


<p>我们知道Java中字符串常量是放在常量池中的，String.intern()这个方法运行的时候，会检查常量池中是否存和本字符串相等的对象，如果存在直接返回对常量池中对象的引用，不存在的话，先把此字符串加入常量池，然后再返回字符串的引用。那么我们就可以通过String.intern方法来模拟一下运行时常量区的溢出.下面我们通过如下的代码来模拟此种情况：</p>

<figure class='code'><figcaption><span>OOMTest.java</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">java.lang.*</span><span class="o">;</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">OOMTest</span><span class="o">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">...</span> <span class="n">args</span><span class="o">){</span>
</span><span class='line'>                <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span>
</span><span class='line'>                <span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">){</span>
</span><span class='line'>                        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">UUID</span><span class="o">.</span><span class="na">randomUUID</span><span class="o">().</span><span class="na">toString</span><span class="o">().</span><span class="na">intern</span><span class="o">());</span>
</span><span class='line'>                <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">}</span>  
</span></code></pre></td></tr></table></div></figure>


<p>我们通过如下的命令运行上面代码：</p>

<p><code>java -verbose:gc -Xmn5M -Xms10M -Xmx10M -XX:MaxPermSize=1M -XX:+PrintGC OOMTest</code></p>

<p>运行后的输入如下图所示:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Exception</span> <span class="n">in</span> <span class="n">thread</span> <span class="s">&quot;main&quot;</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">OutOfMemoryError</span><span class="o">:</span> <span class="n">PermGen</span> <span class="n">space</span>
</span><span class='line'>        <span class="n">at</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span><span class="o">.</span><span class="na">intern</span><span class="o">(</span><span class="n">Native</span> <span class="n">Method</span><span class="o">)</span>
</span><span class='line'>        <span class="n">at</span> <span class="n">OOMTest</span><span class="o">.</span><span class="na">main</span><span class="o">(</span><span class="n">OOMTest</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">8</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过上面的代码，我们成功模拟了运行时常量池溢出的情况，从输出中的<strong>PermGen space</strong>可以看出确实是持久带发生了溢出，这也验证了，我们前面说的Hotspot jvm通过持久带来实现方法区的说法。</p>

<h1>OutOfMemoryError:unable to create native thread</h1>

<p>最后我们在来看看<code>java.lang.OutOfMemoryError:unable to create natvie thread</code>这种错误。
出现这种情况的时候，一般是下面两种情况导致的：</p>

<ol>
<li>程序创建的线程数超过了操作系统的限制。对于Linux系统，我们可以通过ulimit -u来查看此限制。</li>
<li>给虚拟机分配的内存过大，导致创建线程的时候需要的native内存太少。我们都知道操作系统对每个进程的内存是有限制的，我们启动Jvm,相当于启动了一个进程，假如我们一个进程占用了4G的内存，那么通过下面的公式计算出来的剩余内存就是建立线程栈的时候可以用的内存。
<code>线程栈总可用内存=4G-（-Xmx的值）- （-XX:MaxPermSize的值）- 程序计数器占用的内存</code>
通过上面的公式我们可以看出，-Xmx 和 MaxPermSize的值越大，那么留给线程栈可用的空间就越小，在-Xss参数配置的栈容量不变的情况下，可以创建的线程数也就越小。因此如果是因为这种情况导致的<code>unable to create native thread</code>,那么要么我们增大进程所占用的总内存，或者减少-Xmx或者-Xss来达到创建更多线程的目的。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ JavaEE资源管理常见策略总结]]></title>
    <link href="http://imtiger.github.io/blog/2008/12/07/javaee-resource-manager-strategy-summary/"/>
    <updated>2008-12-07T20:40:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2008/12/07/javaee-resource-manager-strategy-summary</id>
    <content type="html"><![CDATA[<p>公所周知JavaEE是多线程的，同时资源管理的策略都是与线程相关的，因此通过合理的资源管理来应对多线程的环境是非常关键的。下面我们就来总结一下JavaEE中常见的资源管理策略。</p>

<h1>第一种：实例池</h1>

<p>实例池管理策略就是通过将我们的业务组件的实例保存到池中，这样可以达到重用的目的。说到实例池，需要明确一下单线程模型的概念，所谓单线程模型就是一个实例在某一时间只能服务于同一个线程，单线程模型使得无状态的业务组件不需要关注复杂的线程问题（通俗点讲，单线程模型使得业务开发人员可以采用不需要显示的同步机制来编写业务组件代码，但是业务组件可以安全的运行与多线程环境之下）。如果采用实例池将有助于实现单线程模型。比如EJB对于无状态的会话bean的管理就采取的是实例池的管理策略，这样以来我们的SLSB中是不需要同步的（这也是为什么EJB组件中不能有显示的同步代码的原因，因为EJB本来就是单线程的模型），从而减轻了业务开发人员的负担。</p>

<!-- more -->


<p>下面总结一下这种方法的优缺点：</p>

<h2>优点：</h2>

<ol>
<li>采用实例池可以使得无状态的业务组件不需要同步，这样就减轻了业务开发人员的负担。</li>
<li>采用实例池可以限制并发执行的线程的数量，当实例池没有可用的实例可用时，线程就需要挂起，这样防止大的并发对服务器造成的压力。</li>
</ol>


<h2>缺点：</h2>

<ol>
<li>因为采用了实例池，增加了管理实例池的开销，增加了系统的复杂性。</li>
<li>采用实例池还是没有从根本上解决线程的问题，因为虽然实例池的实例不用同步，但是实例池的实例需要其它的组件来协作，这样其它组件的实例还是需要同步的。</li>
</ol>


<h2>具体的应用：</h2>

<p>EJB的无状态会话bean<br/>
数据库连接池技术<br/>
TCP连接技术<br/>
web容器和ejb容器的线程池等</p>

<blockquote><p><a href="http://book.douban.com/subject/1444890/">&lt;&lt;面向模式的软件体系结构-卷3>></a>对<code>“实例池”</code>有详细的描述。</p></blockquote>

<h1>第二种：容器管理的单例</h1>

<p>目前各种IOC容器一般都采取了此种概念，系统只维护一个无状态业务组件的实例。比如目前流行的IOC容器（spring,Picocontainer等)，它们都有将业务组件设置为单例的功能。这样以来减轻了维护实例池的开销，并且通过容器可以管理组件的生命周期，不是像以前那样用完了就丢给垃圾收集器，同时还减轻了一些复杂的初始化的开销。</p>

<p>下面是此种方式的优缺点：</p>

<h2>优点：</h2>

<ol>
<li>减轻了一些需要复杂初始化的实例创建开销，从而提高了系统性能。</li>
<li>通过IOC进行了组件的生命周期管理，减低了开发人员的负担。</li>
</ol>


<h2>缺点：</h2>

<ol>
<li>需要我们业务人员确保每个实例是无状态的，如果业务组件是有状态的，那么就要进行显示的同步，而多线程编程不是每个业务开发人员都能胜任的。</li>
<li>任意多的线程都可以进行并发调用，这样以来服务器也许无法应对巨大的负载而崩溃。</li>
</ol>


<h2>具体的应用：</h2>

<p>目前的Servlet规范就采用一个实例（抛弃了以前的servlet单线程模型）来服务于多线程调用，这样我们必须确保servlet内部的线程安全性。
各种IOC容器（spring,Picocontainer等)</p>

<h1>第三种：每个session一个实例</h1>

<p>在开发过程中，我们的业务状态如何保存？这就涉及到了业务状态管理的问题，那么我们就可以采取每个session一个实例来进行，比如httpsession，但是在当今的分层架构下，用httpsession来保存业务状态是有缺点的，首先导致了业务状态泄露到了表现层，不利于层的内聚性，并且httpsession中保存的状态太大的话，会造成内存浪费太多。另外还有就是EJB中的statefull session bean，也采取了这种模式，每个有状态的会话bean只为一个客户服务，并且好的一点是statefull session bean支持钝化技术，并且它还支持完整的事务语义，所以它将业务状态的管理和事务结合了起来，这一点是比较好的，唯一不好的地方就是因为EJB是组件，要想运行必须要结合容器才行。</p>

<h1>具体的应用：</h1>

<p>Web中的httpsession<br/>
EJB中statefull session bean</p>

<h1>第四种：每个请求一个实例</h1>

<p>每个请求一个实例也是一种比较常用的方式，对于一些初始化不是很复杂的实例，我们就可以采用这种方法。采用这种方式得力与JVM性能的改进，在以前垃圾收集器算法还不成熟的时候，如果采用这种方式将会对系统性能产生很大的影响。但是现在垃圾收集器算法优化已经抵消了一定的开销。比如表现层框架webwork、struts2，它们的xwork内核就是在每个请求过来，都新建一个命令实例（action），目前也没有出现严重的性能问题。</p>

<p>下面总结一下此种方式的优缺点：</p>

<h2>优点：</h2>

<p>因为是每个请求（也就是每个线程）一个实例，那么业务开发人员就不需要对业务对象进行显示的同步，这样减轻了业务开发人员的负担。</p>

<h2>缺点：</h2>

<p>对于一些需要复杂初始化的实例，这样会给系统性能带来负面的影响。</p>

<h2>具体的应用：</h2>

<p>Webwork以及struts2的action都采取如此的策略 <br/>
Spring框架的prototype方式。</p>

<h1>第五种：ThreadLocal策略</h1>

<p>此种策略在J2EE中也是比较常用的。它是以线程管理来驱动资源管理的方式，每个线程都独自保存面向自己的变量，这样以来就可以避免多线程访问造成对共享变量的破坏。比如hibernate中，当我们采用JDBC事务的时候，配置hibernate.current_session_context_class=thread,内部就将当前的session与线程绑定，这样以来在同一个线程中操作将是当前绑定的session。还比如webwork中对于ActionContext的管理也采取了Treadlocal的策略，这样以来ActionContext（action的执行上下文）就与当前线程绑定（具体实现是采用一个ActionContext内部类来实现，以前看的源代码，记得不是很清楚了。。），避免多线程访问带来的复杂性。</p>

<p>以上的各种策略看起来是资源管理的策略，但是它们都是与多线程环境有密切关系的，每一种都有自己的优点和缺点，虽然目前框架已经为我们做好了资源管理工作，但是理解它们管理的方式对于业务开发人员还是大有裨益的。以上这些策略也是目前J2EE中常用的，不能确定那个方案比较好，具体的问题具体分析才是上上策。</p>
]]></content>
  </entry>
  
</feed>
