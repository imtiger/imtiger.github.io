<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 技术 | I'm Tiger,一个有理想爱折腾的程序员!]]></title>
  <link href="http://imtiger.github.io/blog/categories/ji-zhu/atom.xml" rel="self"/>
  <link href="http://imtiger.github.io/"/>
  <updated>2013-11-04T22:11:43+08:00</updated>
  <id>http://imtiger.github.io/</id>
  <author>
    <name><![CDATA[imtiger]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Tomcat类加载器机制（Tomcat源代码阅读系列之六）]]></title>
    <link href="http://imtiger.github.io/blog/2013/10/28/tomcat-class-loader/"/>
    <updated>2013-10-28T14:06:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2013/10/28/tomcat-class-loader</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/10/14/apache_tomcat_bag.jpg">
本文是<a href="/blog/2013/10/08/tomcat-source-code-study/">Tomcat源代码阅读系列</a>的第六篇文章，本系列前五篇文章如下：  <br/>
<a href="/blog/2013/10/14/run-tomcat-in-idea-or-eclipse/">在IntelliJ IDEA 和 Eclipse运行tomcat 7源代码（Tomcat源代码阅读系列之一）</a>   <br/>
<a href="/blog/2013/10/16/tomcat-architecture/">Tomcat总体结构                             （Tomcat源代码阅读系列之二）</a>  <br/>
<a href="/blog/2013/10/17/tomcat-start-process/">Tomcat启动过程（Tomcat源代码阅读系列之三）</a> <br/>
<a href="/blog/2013/10/21/tomcat-shutdown/">Tomcat关闭过程（Tomcat源代码阅读系列之四）</a><br/>
<a href="/blog/2013/10/24/tomcat-request-process/">Tomcat请求处理流程（Tomcat源代码阅读系列之五）</a></p>

<p>前面几篇我们分析了Tomcat的启动，关闭以及请求处理的流程，本篇将接着分析Tomcat的类加载器机制，如果大家对Java的类加载器机制不熟悉的话，建议首先熟悉一下Java的类加载器机制后再来查看本篇文章，对于Java的类加载器机制，大家可以参考自行Google或者参考笔者的另外一篇文章：<a href="/blog/2009/11/09/java-classloader/">Java Classloader机制解析</a>.</p>

<!-- more -->


<p>要说Tomcat的Classloader机制，我们还得从Bootstrap开始。在BootStrap初始化的时候，调用了<code>org.apache.catalina.startup.Bootstrap#initClassLoaders</code>方法，这个方法里面创建了3个ClassLoader,它们分别是commonLoader,catalinaLoader,sharedLoader，其中catalinaLoader,sharedLoader的父亲加载器是commonLoader，initClassLoaders执行的过程中会执行createClassLoader，而createClassLoader是根据conf/catalina.properties文件中common.loader，server.loader，shared.loader的值来初始化，它的代码如下：
```java org.apache.catalina.startup.Bootstrap#createClassLoader
private ClassLoader createClassLoader(String name, ClassLoader parent)</p>

<pre><code>throws Exception {

String value = CatalinaProperties.getProperty(name + ".loader");
// 1 
if ((value == null) || (value.equals("")))
    return parent;

// 2
value = replace(value);

List&lt;Repository&gt; repositories = new ArrayList&lt;Repository&gt;();

StringTokenizer tokenizer = new StringTokenizer(value, ",");
while (tokenizer.hasMoreElements()) {
    String repository = tokenizer.nextToken().trim();
    if (repository.length() == 0) {
        continue;
    }

    // Check for a JAR URL repository
    try {
        @SuppressWarnings("unused")
        URL url = new URL(repository);
        repositories.add(
                new Repository(repository, RepositoryType.URL));
        continue;
    } catch (MalformedURLException e) {
        // Ignore
    }

    // Local repository
    if (repository.endsWith("*.jar")) {
        repository = repository.substring
            (0, repository.length() - "*.jar".length());
        repositories.add(
                new Repository(repository, RepositoryType.GLOB));
    } else if (repository.endsWith(".jar")) {
        repositories.add(
                new Repository(repository, RepositoryType.JAR));
    } else {
        repositories.add(
                new Repository(repository, RepositoryType.DIR));
    }
}
// 3
ClassLoader classLoader = ClassLoaderFactory.createClassLoader
    (repositories, parent);


return classLoader;
</code></pre>

<p>}
```</p>

<p>以上代码删除了与本篇无关的代码，下面我们分别来分析一下标注的地方：</p>

<ol>
<li>标注1的代码（第5行）判断如果catalina.properties中没有配置对应的loader属性的话，直接返回父加载器，而默认情况下，server.loader,shared.loader为空，那么此时的catalinaLoader,sharedLoader其实是同一个ClassLoader.</li>
<li>标注2（第9行）的地方根据环境变量的配置替换字符串中的值.默认情况下，common.loader的值为common.loader=${catalina.base}/lib,${catalina.base}/lib/<em>.jar,${catalina.home}/lib,${catalina.home}/lib/</em>.jar,这里会将catalina.base和catalina.home用环境变量的值替换。</li>
<li>标注3（第46行）的代码最终调用<code>org.apache.catalina.startup.ClassLoaderFactory#createClassLoader</code>静态工厂方法创建了URLClassloader的实例，而具体的URL其实就是*.loader属性配置的内容，此外如果parent为null的话，则直接用系统类加载器。</li>
</ol>


<p>上面分析了Tomcat在启动的时候，初始化的几个ClassLoader，接下来我们再来继续看看，这些ClassLoader具体都用在什么地方。</p>

<p>我们接着来看org.apache.catalina.startup.Bootstrap#init方法，在初始化完3个classLoader以后，接下来首先通过catalinaLoader加载了<code>org.apache.catalina.startup.Catalina</code>l类，然后通过放射调用了org.apache.catalina.startup.Catalina#setParentClassLoader,具体代码片段如下：
```java org.apache.catalina.startup.Bootstrap#init
Class&lt;?> startupClass =</p>

<pre><code>catalinaLoader.loadClass
("org.apache.catalina.startup.Catalina");
</code></pre>

<p>Object startupInstance = startupClass.newInstance();</p>

<p>String methodName = &ldquo;setParentClassLoader&rdquo;;
Class&lt;?> paramTypes[] = new Class[1];
paramTypes[0] = Class.forName(&ldquo;java.lang.ClassLoader&rdquo;);
Object paramValues[] = new Object[1];
paramValues[0] = sharedLoader;
Method method =</p>

<pre><code>startupInstance.getClass().getMethod(methodName, paramTypes);
</code></pre>

<p>method.invoke(startupInstance, paramValues);
<code>
通过上面的代码，我们可以清楚的看到调用了Catalina的setParentClassLoader放，那么到这里我们可能又要想知道，设置了parentClassLoader以后，sharedLoader又是在哪里使用的呢？这就需要我们接着来分析容器启动的代码。我们通过查看`org.apache.catalina.startup.Catalina#getParentClassLoader`调用栈，我们看到在StandardContext的startInternal方法中调用了它，那么我们查看一下它的代码，包含了如下代码片段：
</code>java org.apache.catalina.core.StandardContext#startInternal
if (getLoader() == null) {</p>

<pre><code>        WebappLoader webappLoader = new WebappLoader(getParentClassLoader());
        webappLoader.setDelegate(getDelegate());
        setLoader(webappLoader);
</code></pre>

<p>}
try {</p>

<pre><code>if (ok) {

    // Start our subordinate components, if any
    if ((loader != null) &amp;&amp; (loader instanceof Lifecycle))
        ((Lifecycle) loader).start();
    //other code    
}
</code></pre>

<p>catch(Exception e){
}
```
通过查看上面的代码，我们看到在StandardContext启动的时候，会创建webapploader，创建webapploader的时候会将getParentClassLoader方法返回的结果（这里返回的其实就是sharedLoader）赋值给自己的parentClassLoader变量,接着又会调用到Webapploader的start方法，因为WebappLoader符合Tomcat组件生命周期管理的模板方法模式，因此会调用到它的startInternal方法。我们接下来就来看看WebappLoader的startInternal，我们摘取一部分与本篇相关的代码片段如下：</p>

<p>```java org.apache.catalina.loader.WebappLoader#startInternal
classLoader = createClassLoader();
classLoader.setResources(container.getResources());
classLoader.setDelegate(this.delegate);
classLoader.setSearchExternalFirst(searchExternalFirst);</p>

<p><code>
从上的代码可以看到调用了createClassLoader方法创建一个classLoader，那么我们再看来看看createClassLoader的代码：
</code>java org.apache.catalina.loader.WebappLoader#createClassLoader
private WebappClassLoader createClassLoader()</p>

<pre><code>throws Exception {

Class&lt;?&gt; clazz = Class.forName(loaderClass);
WebappClassLoader classLoader = null;

if (parentClassLoader == null) {
    parentClassLoader = container.getParentClassLoader();
}
Class&lt;?&gt;[] argTypes = { ClassLoader.class };
Object[] args = { parentClassLoader };
Constructor&lt;?&gt; constr = clazz.getConstructor(argTypes);
classLoader = (WebappClassLoader) constr.newInstance(args);

return classLoader;
</code></pre>

<p>}
<code>``
在上面的代码里面，loaderClass是WebappLoader的实例变量，其值为</code>org.apache.catalina.loader.WebappClassLoader`，那么上面的代码其实就是通过反射调用了WebappClassLoader的构造函数，然后传递了sharedLoader作为其父亲加载器。</p>

<p>代码阅读到这里，我们已经基本清楚了Tomcat中ClassLoader的总体结构，总结如下：
在Tomcat存在common,cataina,shared三个公共的classloader,默认情况下，这三个classloader其实是同一个，都是common classloader,而针对每个webapp，也就是context（对应代码中的StandardContext类），都有自己的WebappClassLoader来加载每个应用自己的类。上面的描述，我们可以通过下图形象化的描述：
<img class="center" src="/images/2013/10/30/tomcat-classloader.png"></p>

<p>清楚了Tomcat总体的ClassLoader结构以后，咋们就来进一步来分析一下WebAppClassLoader的代码，我们知道Java的ClassLoader机制有parent-first的机制，而这种机制是在loadClass方法保证的，一般情况下，我们只需要重写findClass方法就好了，而对于WebAppClassLoader，通过查看源代码，我们发现loadClass和findClass方法都进行了重写，那么我们首先就来看看它的loadClass方法,它的代码如下：
```java org.apache.catalina.loader.WebappClassLoader#loadClass
public synchronized Class&lt;?> loadClass(String name, boolean resolve)</p>

<pre><code>throws ClassNotFoundException {

if (log.isDebugEnabled())
    log.debug("loadClass(" + name + ", " + resolve + ")");
Class&lt;?&gt; clazz = null;

// Log access to stopped classloader
if (!started) {
    try {
        throw new IllegalStateException();
    } catch (IllegalStateException e) {
        log.info(sm.getString("webappClassLoader.stopped", name), e);
    }
}

// (0) Check our previously loaded local class cache
// 1 
clazz = findLoadedClass0(name);
if (clazz != null) {
    if (log.isDebugEnabled())
        log.debug("  Returning class from cache");
    if (resolve)
        resolveClass(clazz);
    return (clazz);
}

// (0.1) Check our previously loaded class cache
// 2
clazz = findLoadedClass(name);
if (clazz != null) {
    if (log.isDebugEnabled())
        log.debug("  Returning class from cache");
    if (resolve)
        resolveClass(clazz);
    return (clazz);
}

// (0.2) Try loading the class with the system class loader, to prevent
//       the webapp from overriding J2SE classes
// 3 
try {
    clazz = system.loadClass(name);
    if (clazz != null) {
        if (resolve)
            resolveClass(clazz);
        return (clazz);
    }
} catch (ClassNotFoundException e) {
    // Ignore
}

// (0.5) Permission to access this class when using a SecurityManager
if (securityManager != null) {
    int i = name.lastIndexOf('.');
    if (i &gt;= 0) {
        try {
            securityManager.checkPackageAccess(name.substring(0,i));
        } catch (SecurityException se) {
            String error = "Security Violation, attempt to use " +
                "Restricted Class: " + name;
            log.info(error, se);
            throw new ClassNotFoundException(error, se);
        }
    }
}

//4 
boolean delegateLoad = delegate || filter(name);

// (1) Delegate to our parent if requested
// 5 
if (delegateLoad) {
    if (log.isDebugEnabled())
        log.debug("  Delegating to parent classloader1 " + parent);
    ClassLoader loader = parent;
    if (loader == null)
        loader = system;
    try {
        clazz = Class.forName(name, false, loader);
        if (clazz != null) {
            if (log.isDebugEnabled())
                log.debug("  Loading class from parent");
            if (resolve)
                resolveClass(clazz);
            return (clazz);
        }
    } catch (ClassNotFoundException e) {
        // Ignore
    }
}

// (2) Search local repositories
if (log.isDebugEnabled())
    log.debug("  Searching local repositories");
// 6 
try {
    clazz = findClass(name);
    if (clazz != null) {
        if (log.isDebugEnabled())
            log.debug("  Loading class from local repository");
        if (resolve)
            resolveClass(clazz);
        return (clazz);
    }
} catch (ClassNotFoundException e) {
    // Ignore
}

// (3) Delegate to parent unconditionally
// 7
if (!delegateLoad) {
    if (log.isDebugEnabled())
        log.debug("  Delegating to parent classloader at end: " + parent);
    ClassLoader loader = parent;
    if (loader == null)
        loader = system;
    try {
        clazz = Class.forName(name, false, loader);
        if (clazz != null) {
            if (log.isDebugEnabled())
                log.debug("  Loading class from parent");
            if (resolve)
                resolveClass(clazz);
            return (clazz);
        }
    } catch (ClassNotFoundException e) {
        // Ignore
    }
}

throw new ClassNotFoundException(name);
</code></pre>

<p>}</p>

<p>```
我们一步步的来分析一下上面的代码做了什么事情。</p>

<ol>
<li>标注1(第18行)代码，首先从当前ClassLoader的本地缓存中加载类，如果找到则返回。</li>
<li>标注2(第29行)代码，在本地缓存没有的情况下，调用ClassLoader的findLoadedClass方法查看jvm是否已经加载过此类，如果已经加载则直接返回。</li>
<li>标注3(第41行)代码，通过系统的来加载器加载此类，这里防止应用写的类覆盖了J2SE的类,这句代码非常关键，如果不写的话，就会造成你自己写的类有可能会把J2SE的类给替换调，另外假如你写了一个javax.servlet.Servlet类，放在当前应用的WEB-INF/class中，如果没有此句代码的保证，那么你自己写的类就会替换到Tomcat容器Lib中包含的类。</li>
<li>标注4(第68行)代码，判断是否需要委托给父类加载器进行加载，delegate属性默认为false，那么delegatedLoad的值就取决于filter的返回值了，filter方法中根据包名来判断是否需要进行委托加载，默认情况下会返回false.因此delegatedLoad为false</li>
<li>标注5(第72行)代码，因为delegatedLoad为false,那么此时不会委托父加载器去加载，这里其实是没有遵循parent-first的加载机制。</li>
<li>标注6(第96行)调用findClass方法在webapp级别进行加载</li>
<li>标注7(第111行)如果还是没有加载到类，并且不采用委托机制的话，则通过父类加载器去加载。</li>
</ol>


<p>通过上面的描述，我们可以知道Tomcat在加载webapp级别的类的时候，默认是不遵守parent-first的，这样做的好处是更好的实现了应用的隔离，但是坏处就是加大了内存浪费，同样的类库要在不同的app中都要加载一份。</p>

<p>上面分析完了loadClass，我们接着在来分析一下findClass，通过分析findClass的代码，最终会调用<code>org.apache.catalina.loader.WebappClassLoader#findClassInternal</code>方法，那我们就来分析一下它的代码：
```java org.apache.catalina.loader.WebappClassLoader#findClassInternal
protected Class&lt;?> findClassInternal(String name)</p>

<pre><code>throws ClassNotFoundException {

//
if (!validate(name))
    throw new ClassNotFoundException(name);

String tempPath = name.replace('.', '/');
String classPath = tempPath + ".class";

ResourceEntry entry = null;

if (securityManager != null) {
    PrivilegedAction&lt;ResourceEntry&gt; dp =
        new PrivilegedFindResourceByName(name, classPath);
    entry = AccessController.doPrivileged(dp);
} else {
    // 1 
    entry = findResourceInternal(name, classPath);
}

if (entry == null)
    throw new ClassNotFoundException(name);

Class&lt;?&gt; clazz = entry.loadedClass;
if (clazz != null)
    return clazz;

synchronized (this) {
    clazz = entry.loadedClass;
    if (clazz != null)
        return clazz;

    if (entry.binaryContent == null)
        throw new ClassNotFoundException(name);

    try {
        // 2
        clazz = defineClass(name, entry.binaryContent, 0,
                entry.binaryContent.length,
                new CodeSource(entry.codeBase, entry.certificates));
    } catch (UnsupportedClassVersionError ucve) {
        throw new UnsupportedClassVersionError(
                ucve.getLocalizedMessage() + " " +
                sm.getString("webappClassLoader.wrongVersion",
                        name));
    }
    entry.loadedClass = clazz;
    entry.binaryContent = null;
    entry.source = null;
    entry.codeBase = null;
    entry.manifest = null;
    entry.certificates = null;
}

return clazz;
</code></pre>

<p>}
```
上面的代码标注1（第19行）的地方通过名称去当前webappClassLoader的仓库中查找对应的类文件，标注2(第38行)的代码，将找到的类文件通过defineClass转变为Jvm可以识别的Class对象返回。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tomcat请求处理流程（Tomcat源代码阅读系列之五）]]></title>
    <link href="http://imtiger.github.io/blog/2013/10/24/tomcat-request-process/"/>
    <updated>2013-10-24T09:54:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2013/10/24/tomcat-request-process</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/10/14/apache_tomcat_bag.jpg">
本文是<a href="/blog/2013/10/08/tomcat-source-code-study/">Tomcat源代码阅读系列</a>的第五篇文章，本系列前四篇文章如下：<br/>
<a href="/blog/2013/10/14/run-tomcat-in-idea-or-eclipse/">在IntelliJ IDEA 和 Eclipse运行tomcat 7源代码（Tomcat源代码阅读系列之一）</a> <br/>
<a href="/blog/2013/10/16/tomcat-architecture/">Tomcat总体结构                             （Tomcat源代码阅读系列之二）</a><br/>
<a href="/blog/2013/10/17/tomcat-start-process/">Tomcat启动过程（Tomcat源代码阅读系列之三）</a>
<a href="/blog/2013/10/21/tomcat-shutdown/">Tomcat关闭过程（Tomcat源代码阅读系列之四）</a></p>

<p>前面已经分析完了Tomcat的启动和关闭过程，本篇就来接着分析一下Tomcat中请求的处理过程。</p>

<!-- more -->


<p>在开始本文之前，咋们首先来看看一个Http请求处理的过程，一般情况下是<code>浏览器发送http请求-&gt;建立Socket连接-&gt;通过Socket读取数据-&gt;根据http协议解析数据-&gt;调用后台服务完成响应</code>,而Tomcat既是一个HttpServer也是一个Servlet 容器，那么这里必然也涉及到如上过程，首先根据HTTP协议规范解析请求数据，然后将请求转发给Servlet进行处理，因此顺应这样的思路，本文也将从<strong>Http协议请求解析</strong>，<strong>请求如何转发给Servlet</strong>两个方面来进行分析。首先来看Http协议请求解析。</p>

<h1>Http协议请求解析</h1>

<p>在<a href="/blog/2013/10/17/tomcat-start-process/">Tomcat启动过程（Tomcat源代码阅读系列之三）</a>一文中，我们已经知道Tomcat启动以后，默认情况下会通过<code>org.apache.tomcat.util.net.JIoEndpoint.Acceptor</code>监听Socket连接，当监听到有Socket连接的时候，就会调用<code>org.apache.tomcat.util.net.JIoEndpoint#processSocket</code>方法进行处理，下面我们就来看看此方法的代码，为了节省版面，只保留与本文相关的代码。
```java org.apache.tomcat.util.net.JIoEndpoint#processSocket
protected boolean processSocket(Socket socket) {</p>

<pre><code>    // Process the request from this socket
    try {
        SocketWrapper&lt;Socket&gt; wrapper = new SocketWrapper&lt;Socket&gt;(socket);
        wrapper.setKeepAliveLeft(getMaxKeepAliveRequests());
        // During shutdown, executor may be null - avoid NPE
        if (!running) {
            return false;
        }
        getExecutor().execute(new SocketProcessor(wrapper));
    } catch (RejectedExecutionException x) {
       //exception handler ...
       return false;
    }
    return true;
</code></pre>

<p>}
<code>
通过上面的代码，我们可以看出首先将Socket封装为SocketWrapper，然后通过SocketProcessor来进行处理，因为Tomcat必然面对用户并发请求，因此这里Socket的处理通过新的线程池来处理。接下来我们再来看看SocketProcess的代码，同样省略了一些非核心的代码，代码如下：
</code>java org.apache.tomcat.util.net.JIoEndpoint.SocketProcessor#run
public void run() {</p>

<pre><code>    boolean launch = false;
    synchronized (socket) {
        try {
            SocketState state = SocketState.OPEN;

            try {
                // SSL handshake
                serverSocketFactory.handshake(socket.getSocket());
            } catch (Throwable t) {
                ExceptionUtils.handleThrowable(t);
                if (log.isDebugEnabled()) {
                    log.debug(sm.getString("endpoint.err.handshake"), t);
                }
                // Tell to close the socket
                state = SocketState.CLOSED;
            }

            if ((state != SocketState.CLOSED)) {
                if (status == null) {
                    // 1 
                    state = handler.process(socket, SocketStatus.OPEN);
                } else {
                    state = handler.process(socket,status);
                }
            }
            if (state == SocketState.CLOSED) {
                // Close socket
                if (log.isTraceEnabled()) {
                    log.trace("Closing socket:"+socket);
                }
                countDownConnection();
                try {
                    socket.getSocket().close();
                } catch (IOException e) {
                    // Ignore
                }
            } else if (state == SocketState.OPEN ||
                    state == SocketState.UPGRADING  ||
                    state == SocketState.UPGRADED){
                socket.setKeptAlive(true);
                socket.access();
                launch = true;
            } else if (state == SocketState.LONG) {
                socket.access();
                waitingRequests.add(socket);
            }
        } finally {
           //other code
        }
    }
    socket = null;
    // Finish up this request
}
</code></pre>

<p>}
<code>
默认情况下，代码会运行到标注1的地方，标注1的地方又通过`org.apache.tomcat.util.net.JIoEndpoint.Handler#process`的方法进行处理，而通过前面Tomcat启动的文章，我们已经知道handler属性是在`org.apache.coyote.http11.Http11Protocol`的构造方法中初始化的，构造方法如下：
</code>java org.apache.coyote.http11.Http11Protocol#Http11Protocol
public Http11Protocol() {</p>

<pre><code>endpoint = new JIoEndpoint();
cHandler = new Http11ConnectionHandler(this);
((JIoEndpoint) endpoint).setHandler(cHandler);
setSoLinger(Constants.DEFAULT_CONNECTION_LINGER);
setSoTimeout(Constants.DEFAULT_CONNECTION_TIMEOUT);
setTcpNoDelay(Constants.DEFAULT_TCP_NO_DELAY);
</code></pre>

<p>}
<code>``
从构造方法中，我们可以清楚的看到，其实初始化了</code>org.apache.coyote.http11.Http11Protocol.Http11ConnectionHandler<code>的实例，那么接下来我们就来看看它的process方法，因为Http11ConnectionHandler继承了</code>org.apache.coyote.AbstractProtocol.AbstractConnectionHandler`，而自己没有实现process方法，因此会调用到父类的process方法，那么接下来我们就来看看AbstractConnectionHandler的process方法，代码如下：</p>

<p>```java org.apache.coyote.AbstractProtocol.AbstractConnectionHandler#process
public SocketState process(SocketWrapper<S> socket,</p>

<pre><code>    SocketStatus status) {
Processor&lt;S&gt; processor = connections.remove(socket.getSocket());

if (status == SocketStatus.DISCONNECT &amp;&amp; processor == null) {
    //nothing more to be done endpoint requested a close
    //and there are no object associated with this connection
    return SocketState.CLOSED;
}

socket.setAsync(false);

try {
    if (processor == null) {
        processor = recycledProcessors.poll();
    }
    if (processor == null) {
        processor = createProcessor();
    }

    initSsl(socket, processor);

    SocketState state = SocketState.CLOSED;
    do {
        if (status == SocketStatus.DISCONNECT &amp;&amp;
                !processor.isComet()) {
            // Do nothing here, just wait for it to get recycled
            // Don't do this for Comet we need to generate an end
            // event (see BZ 54022)
        } else if (processor.isAsync() ||
                state == SocketState.ASYNC_END) {
            state = processor.asyncDispatch(status);
        } else if (processor.isComet()) {
            state = processor.event(status);
        } else if (processor.isUpgrade()) {
            state = processor.upgradeDispatch();
        } else {
            state = processor.process(socket);
        }

        if (state != SocketState.CLOSED &amp;&amp; processor.isAsync()) {
            state = processor.asyncPostProcess();
        }

        if (state == SocketState.UPGRADING) {
            // Get the UpgradeInbound handler
            UpgradeInbound inbound = processor.getUpgradeInbound();
            // Release the Http11 processor to be re-used
            release(socket, processor, false, false);
            // Create the light-weight upgrade processor
            processor = createUpgradeProcessor(socket, inbound);
            inbound.onUpgradeComplete();
        }
    } while (state == SocketState.ASYNC_END ||
            state == SocketState.UPGRADING);

    return state;
} catch(java.net.SocketException e) {
            // exception handler   
}

return SocketState.CLOSED;
</code></pre>

<p>}
```</p>

<p>通过查看上面的代码，默认一个新连接的情况下，会调用<code>org.apache.coyote.Processor#process</code>方法,而Processor的实例实在<code>org.apache.coyote.AbstractProtocol.AbstractConnectionHandler#createProcessor</code>中创建的，通过查看createProcessor代码，我们发现是创建了一个org.apache.coyote.http11.Http11Processor的实例，那么接下来，我们就来看看它的process方法，因为Http11Processor继承了AbstractHttp11Processor，最终其实调用的是AbstractHttp11Processor的process方法，代码如下：</p>

<p>```java org.apache.coyote.http11.AbstractHttp11Processor#process
public SocketState process(SocketWrapper<S> socketWrapper)</p>

<pre><code>throws IOException {
RequestInfo rp = request.getRequestProcessor();
rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);

// Setting up the I/O
// 1 
setSocketWrapper(socketWrapper);
getInputBuffer().init(socketWrapper, endpoint);
getOutputBuffer().init(socketWrapper, endpoint);

// Flags
error = false;
keepAlive = true;
comet = false;
openSocket = false;
sendfileInProgress = false;
readComplete = true;
if (endpoint.getUsePolling()) {
    keptAlive = false;
} else {
    keptAlive = socketWrapper.isKeptAlive();
}

if (disableKeepAlive()) {
    socketWrapper.setKeepAliveLeft(0);
}

while (!error &amp;&amp; keepAlive &amp;&amp; !comet &amp;&amp; !isAsync() &amp;&amp;
        upgradeInbound == null &amp;&amp; !endpoint.isPaused()) {

    // Parsing the request header
    try {
        setRequestLineReadTimeout();
        //2 
        if (!getInputBuffer().parseRequestLine(keptAlive)) {
            if (handleIncompleteRequestLineRead()) {
                break;
            }
        }

        if (endpoint.isPaused()) {
            // 503 - Service unavailable
            response.setStatus(503);
            error = true;
        } else {
            // Make sure that connectors that are non-blocking during
            // header processing (NIO) only set the start time the first
            // time a request is processed.
            if (request.getStartTime() &lt; 0) {
                request.setStartTime(System.currentTimeMillis());
            }
            keptAlive = true;
            // Set this every time in case limit has been changed via JMX
            request.getMimeHeaders().setLimit(endpoint.getMaxHeaderCount());
            // Currently only NIO will ever return false here
            // 3
            if (!getInputBuffer().parseHeaders()) {
                // We've read part of the request, don't recycle it
                // instead associate it with the socket
                openSocket = true;
                readComplete = false;
                break;
            }
            if (!disableUploadTimeout) {
                setSocketTimeout(connectionUploadTimeout);
            }
        }
    } catch (IOException e) {
        if (getLog().isDebugEnabled()) {
            getLog().debug(
                    sm.getString("http11processor.header.parse"), e);
        }
        error = true;
        break;
    } catch (Throwable t) {
        ExceptionUtils.handleThrowable(t);
        UserDataHelper.Mode logMode = userDataHelper.getNextMode();
        if (logMode != null) {
            String message = sm.getString(
                    "http11processor.header.parse");
            switch (logMode) {
                case INFO_THEN_DEBUG:
                    message += sm.getString(
                            "http11processor.fallToDebug");
                    //$FALL-THROUGH$
                case INFO:
                    getLog().info(message);
                    break;
                case DEBUG:
                    getLog().debug(message);
            }
        }
        // 400 - Bad Request
        response.setStatus(400);
        adapter.log(request, response, 0);
        error = true;
    }

    if (!error) {
        // Setting up filters, and parse some request headers
        rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);
        try {
            prepareRequest();
        } catch (Throwable t) {
            ExceptionUtils.handleThrowable(t);
            if (getLog().isDebugEnabled()) {
                getLog().debug(sm.getString(
                        "http11processor.request.prepare"), t);
            }
            // 400 - Internal Server Error
            response.setStatus(400);
            adapter.log(request, response, 0);
            error = true;
        }
    }

    if (maxKeepAliveRequests == 1) {
        keepAlive = false;
    } else if (maxKeepAliveRequests &gt; 0 &amp;&amp;
            socketWrapper.decrementKeepAlive() &lt;= 0) {
        keepAlive = false;
    }

    // Process the request in the adapter
    if (!error) {
        try {
            // 4
            rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);
            adapter.service(request, response);
            // Handle when the response was committed before a serious
            // error occurred.  Throwing a ServletException should both
            // set the status to 500 and set the errorException.
            // If we fail here, then the response is likely already
            // committed, so we can't try and set headers.
            if(keepAlive &amp;&amp; !error) { // Avoid checking twice.
                error = response.getErrorException() != null ||
                        (!isAsync() &amp;&amp;
                        statusDropsConnection(response.getStatus()));
            }
            setCometTimeouts(socketWrapper);
        } catch (InterruptedIOException e) {
            error = true;
        } catch (HeadersTooLargeException e) {
            error = true;
            // The response should not have been committed but check it
            // anyway to be safe
            if (!response.isCommitted()) {
                response.reset();
                response.setStatus(500);
                response.setHeader("Connection", "close");
            }
        } catch (Throwable t) {
            ExceptionUtils.handleThrowable(t);
            getLog().error(sm.getString(
                    "http11processor.request.process"), t);
            // 500 - Internal Server Error
            response.setStatus(500);
            adapter.log(request, response, 0);
            error = true;
        }
    }

    // Finish the handling of the request
    rp.setStage(org.apache.coyote.Constants.STAGE_ENDINPUT);

    if (!isAsync() &amp;&amp; !comet) {
        if (error) {
            // If we know we are closing the connection, don't drain
            // input. This way uploading a 100GB file doesn't tie up the
            // thread if the servlet has rejected it.
            getInputBuffer().setSwallowInput(false);
        }
        endRequest();
    }

    rp.setStage(org.apache.coyote.Constants.STAGE_ENDOUTPUT);

    // If there was an error, make sure the request is counted as
    // and error, and update the statistics counter
    if (error) {
        response.setStatus(500);
    }
    request.updateCounters();

    if (!isAsync() &amp;&amp; !comet || error) {
        getInputBuffer().nextRequest();
        getOutputBuffer().nextRequest();
    }

    if (!disableUploadTimeout) {
        if(endpoint.getSoTimeout() &gt; 0) {
            setSocketTimeout(endpoint.getSoTimeout());
        } else {
            setSocketTimeout(0);
        }
    }

    rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);

    if (breakKeepAliveLoop(socketWrapper)) {
        break;
    }
}

rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);

if (error || endpoint.isPaused()) {
    return SocketState.CLOSED;
} else if (isAsync() || comet) {
    return SocketState.LONG;
} else if (isUpgrade()) {
    return SocketState.UPGRADING;
} else {
    if (sendfileInProgress) {
        return SocketState.SENDFILE;
    } else {
        if (openSocket) {
            if (readComplete) {
                return SocketState.OPEN;
            } else {
                return SocketState.LONG;
            }
        } else {
            return SocketState.CLOSED;
        }
    }
}
</code></pre>

<p>}</p>

<p>```
上面的代码有点长，但是经过分析，我们还是可以看出起主干，我已经在代码中将主流程通过数字标注了，我们就来一一看看标注了数字的地方：</p>

<ol>
<li>标注1的地方（第7行）将Socket的输入流和输出流通过InternalInputBuffer进行了包装，InternalInputBuffer是在Http11Processor的构造函数中初始化的。</li>
<li>标注2的地方（第35行）调用了InternalInputBuffer的parseRequesLine方法解析http请求的请求行。(关于http请求行和请求头请看下文解释)</li>
<li>标注3的地方（第57行）调用了InternalInputBuffer的prarseHeaders方法解析http请求的请求头。解析完了以后，会将http header保存在<code>org.apache.tomcat.util.http.MimeHeaders</code></li>
<li>标注4的地方（第128行）调用了org.apache.coyote.Adapter#service方法，次方法就会最终调用到具体的Servlet.</li>
</ol>


<p>对于Http请求行和请求头，大家可以看下面的例子：
```js Http get request
GET /contextpath/querystring HTTP/1.1</p>

<p>Host: 127.0.0.1:8080</p>

<p>User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:23.0) Gecko/20100101 Firefox/23.0</p>

<p>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8</p>

<p>Accept-Language: en-US,en;q=0.5</p>

<p>Accept-Encoding: gzip, deflate</p>

<p>Cookie: JSESSIONID=9F5897FEF3CDBCB234C050C132DCAE52; <strong>atuvc=384%7C39; </strong>utma=96992031.358732763.1380383869.1381468490.1381554710.38; __utmz=96992031.1380383869.1.1.utmcsr=(direct)|utmccn=(direct)|utmcmd=(none); Hm_lvt_21e144d0df165d6556d664e2836dadfe=1381330561,1381368826,1381395666,1381554711</p>

<p>Connection: keep-alive</p>

<p>Cache-Control: max-age=0
<code>``
在上面的Http协议get请求中，其中请求行就是第一行，</code>GET /contextpath/querystring HTTP/1.1`,余下的都是请求头。这里面需要注意根据Http协议的要求，请求行末尾必须是CRLF，而请求行与请求头，以及请求头之间必须用空行隔开，而空行也必须只包含CRLF。对于Http协议请求头的规范可以参考<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html">这里</a>。</p>

<p>通过上面的描述，我们可以整理出如下的一个请求解析流程：
<code>java Request http header parse
org.apache.tomcat.util.net.JIoEndpoint.Acceptor#run
-&gt;org.apache.tomcat.util.net.JIoEndpoint.SocketProcessor#run(请求处理线程池中运行)
--&gt;org.apache.coyote.AbstractProtocol.AbstractConnectionHandler#process
---&gt;org.apache.coyote.http11.AbstractHttp11Processor#process
----&gt;org.apache.coyote.http11.InternalInputBuffer#parseRequestLine
----&gt;org.apache.coyote.http11.InternalInputBuffer#parseHeaders
----&gt;org.apache.catalina.connector.CoyoteAdapter#service
</code></p>

<h1>如何转发到Servlet</h1>

<p>上面我们说了一个请求过来是如何根据http协议解析Socket的数据，最终将生成<code>org.apache.coyote.Request</code>和<code>org.apache.coyote.Response</code>，接下来我们就来看看request,reponse是如何一步步的进入最终的Servlet进行处理的。这一步的入口就是CoyoteAdapter的service方法。
接下来我们就来看看它的代码：
```java org.apache.catalina.connector.CoyoteAdapter#service
public void service(org.apache.coyote.Request req,</p>

<pre><code>                org.apache.coyote.Response res)
throws Exception {


Request request = (Request) req.getNote(ADAPTER_NOTES);
Response response = (Response) res.getNote(ADAPTER_NOTES);

//1 
if (request == null) {

    // Create objects
    request = connector.createRequest();
    request.setCoyoteRequest(req);
    response = connector.createResponse();
    response.setCoyoteResponse(res);

    // Link objects
    request.setResponse(response);
    response.setRequest(request);

    // Set as notes
    req.setNote(ADAPTER_NOTES, request);
    res.setNote(ADAPTER_NOTES, response);

    // Set query string encoding
    req.getParameters().setQueryStringEncoding
        (connector.getURIEncoding());

}

if (connector.getXpoweredBy()) {
    response.addHeader("X-Powered-By", POWERED_BY);
}

boolean comet = false;
boolean async = false;

try {

    // Parse and set Catalina and configuration specific
    // request parameters
    req.getRequestProcessor().setWorkerThreadName(Thread.currentThread().getName());
    //2
    boolean postParseSuccess = postParseRequest(req, request, res, response);
    if (postParseSuccess) {
        //check valves if we support async
        request.setAsyncSupported(connector.getService().getContainer().getPipeline().isAsyncSupported());
        // Calling the container
        //3
        connector.getService().getContainer().getPipeline().getFirst().invoke(request, response);

        // other code

    }
    // other code

} catch (IOException e) {
    // Ignore
} finally {
    req.getRequestProcessor().setWorkerThreadName(null);
    // Recycle the wrapper request and response
    if (!comet &amp;&amp; !async) {
        request.recycle();
        response.recycle();
    } else {
        // Clear converters so that the minimum amount of memory
        // is used by this processor
        request.clearEncoders();
        response.clearEncoders();
    }
}
</code></pre>

<p>}
```
为了可以清楚的看到主流程，上面删除了一部分非主流程的代码，接下来我们逐一分析一下标注了数字的地方：</p>

<ol>
<li>标注1的代码(第9行)将<code>org.apache.coyote.Request</code>和<code>org.apache.coyote.Response</code>对象转变为<code>org.apache.catalina.connector.Request</code>,<code>org.apache.catalina.connector.Response</code>类型的对象。其中coyote包中的Request仅仅只是包含了解析出来的http协议的数据，而connector包中的Request才是真正Servlet容器中的HttpServletRequest，它里面包含了完成请求需要的host,context和wrapper信息,在这里每一个wrapper其实都对应web.xml配置的一个Servlet。</li>
<li>标注2（第44行）的代码调用了postParseRequest方法，这个方法里面做的事情非常多，但是最终都是为了根据Request对象找到对应的Host,Conext和Wrapper对象，也就是说最终要清楚这个请求应该由哪个Servlet来处理。</li>
<li>标注3（第50）的代码将已经设置好了Host,Context,Wrapper对象的Request通过Pipeline机制链式传递给最终的Servlet。</li>
</ol>


<p>上面只是从整体上告诉了读者<code>org.apache.catalina.connector.CoyoteAdapter#service</code>方法做的事情，接下来我们进一步分解每一个步骤都具体做了哪些工作。第一步比较简单，大家可以自己阅读，我们关键来看2，3步。首先我们来看看postParseRequest方法。
通过分析org.apache.catalina.connector.CoyoteAdapter#postParseRequest的代码，我们会发现它最终是通过<code>org.apache.tomcat.util.http.mapper.Mapper#map</code>方法来达到匹配请求到对应的Context和Wrapper(Servlet包装类)目的。具体代码如下：
```java org.apache.catalina.connector.CoyoteAdapter#postParseRequest
connector.getMapper().map(serverName, decodedURI, version,</p>

<pre><code>                                  request.getMappingData());
        request.setContext((Context) request.getMappingData().context);
        request.setWrapper((Wrapper) request.getMappingData().wrapper);
</code></pre>

<p><code>``
那我们再来看看此方法。通过分析它的代码，我们发现最终其实是调用了几个</code>internalMap**`方法将找到的Context,Wrapper设置到org.apache.catalina.connector.Request对象的org.apache.tomcat.util.http.mapper.MappingData类型的属性中,map方法执行完以后，然后接下来就从MappingData中获取已经找到的Context和Wrapper，再设置到Request的context和wrapper中。</p>

<p>接下来我们再来分析第3步，第3步通过pipeline链式调用机制最终调用了Servlet对象，而对于pipeline其实是运用了责任链模式，它将各个阀门链接起来，然后一步步的调用，而至于有多少个阀门（Valve）对象，主要来源于两个地方，一个是conf/server.xml中配置的valve，我们知道所有的容器都是支持pipeline机制的，另外一个就是每一个容器的构造其中自己初始化的阀门对象。接下来一一看一下。对已StandardEngine来说有一个与之对应的StandardEngineValve，对于StandardHost有一个StandardHostValve与之对应，StandardContext有一个StandardContextValve与之对应，StandardWrapper与StandardWrapperValve对应,通过分析代码，我们可以得到如下的一个调用链。
<code>java
-&gt;org.apache.catalina.core.StandardEngineValve#invoke
--&gt;org.apache.catalina.valves.AccessLogValve#invoke
---&gt;org.apache.catalina.valves.ErrorReportValve#invoke
----&gt;org.apache.catalina.core.StandardHostValve#invoke
-----&gt;org.apache.catalina.authenticator.AuthenticatorBase#invoke
------&gt;org.apache.catalina.core.StandardContextValve#invoke
-------&gt;org.apache.catalina.core.StandardWrapperValve#invoke
</code>
上述的调用栈中，最后会调用到StandardWrapperValve，它其实也是最终调用Servlet的地方，接下来我们就来看看它的代码：
```java
public final void invoke(Request request, Response response)</p>

<pre><code>throws IOException, ServletException {

// Initialize local variables we may need
boolean unavailable = false;
Throwable throwable = null;
// This should be a Request attribute...
long t1=System.currentTimeMillis();
requestCount++;
StandardWrapper wrapper = (StandardWrapper) getContainer();
Servlet servlet = null;
Context context = (Context) wrapper.getParent();


// Allocate a servlet instance to process this request
try {
    //1
    if (!unavailable) {
        servlet = wrapper.allocate();
    }
} catch (UnavailableException e) {
    container.getLogger().error(
            sm.getString("standardWrapper.allocateException",
                    wrapper.getName()), e);
    long available = wrapper.getAvailable();
    if ((available &gt; 0L) &amp;&amp; (available &lt; Long.MAX_VALUE)) {
        response.setDateHeader("Retry-After", available);
        response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,
                   sm.getString("standardWrapper.isUnavailable",
                                wrapper.getName()));
    } else if (available == Long.MAX_VALUE) {
        response.sendError(HttpServletResponse.SC_NOT_FOUND,
                   sm.getString("standardWrapper.notFound",
                                wrapper.getName()));
    }
} // other code

MessageBytes requestPathMB = request.getRequestPathMB();
DispatcherType dispatcherType = DispatcherType.REQUEST;
if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC; 
request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);
request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,
        requestPathMB);
// Create the filter chain for this request
ApplicationFilterFactory factory =
    ApplicationFilterFactory.getInstance();
ApplicationFilterChain filterChain =
    factory.createFilterChain(request, wrapper, servlet);

// Reset comet flag value after creating the filter chain
request.setComet(false);

// Call the filter chain for this request
// NOTE: This also calls the servlet's service() method
// 2 
try {
    if ((servlet != null) &amp;&amp; (filterChain != null)) {
        // Swallow output if needed
        if (context.getSwallowOutput()) {
            try {
                SystemLogHandler.startCapture();
                if (request.isAsyncDispatching()) {
                    //TODO SERVLET3 - async
                    ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch(); 
                } else if (comet) {
                    filterChain.doFilterEvent(request.getEvent());
                    request.setComet(true);
                } else {
                    filterChain.doFilter(request.getRequest(), 
                            response.getResponse());
                }
            } finally {
                String log = SystemLogHandler.stopCapture();
                if (log != null &amp;&amp; log.length() &gt; 0) {
                    context.getLogger().info(log);
                }
            }
        } else {
            if (request.isAsyncDispatching()) {
                //TODO SERVLET3 - async
                ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();
            } else if (comet) {
                request.setComet(true);
                filterChain.doFilterEvent(request.getEvent());
            } else {
                filterChain.doFilter
                    (request.getRequest(), response.getResponse());
            }
        }

    }
} catch(Exception e){
// other code
}
</code></pre>

<p>}
```
为了节省版面，上面的代码已经删除非主流程的代码。接下来我们逐一分析一下标注了数字的地方：</p>

<ol>
<li>标注1（第17行）的代码实例化了Servlet对象，在实例化的过程中使用了Java双检查锁的机制来实例化Servlet，有兴趣的童鞋可以去看看org.apache.catalina.core.StandardWrapper#allocate的代码。这里需要注意的是在Servlet2.4规范之前，有一个singleThreadMode模型，这个机制类似与之前EJB的无状态会话Bean机制，每个线程过来会通过实例池中取出一个实例来完成响应。在Servlet规范2.4之后，单线程模型已经被废除了。具体细节可以参考<a href="http://docs.oracle.com/javaee/5/api/javax/servlet/SingleThreadModel.html">这里</a> .</li>
<li>标注2（第55行）的代码其实调用了大家熟悉的Servlet的过滤器链，过滤器链最终就会调用到Servlet.</li>
</ol>


<p>最后，咋们再来看看过滤器滤链的处理，来看看<code>org.apache.catalina.core.ApplicationFilterChain#doFilter</code>，doFilter方法中会根据filterConfig中取的web.xml配置的过滤器，然后一个个调用，等每个过滤器执行完了以后，最终就会调用到Servlet的Service方法。</p>

<p>通过上面的分析，其实我们已经清楚了一个请求过来以后，Tomcat是如何一步步处理的。我们再来做一个总体的总结：</p>

<ol>
<li>用户浏览器发送请求，请求会发送到对应的Connector监听的Socket端口。</li>
<li>Connector从Socket流中获取数据，然后根据Http协议将其解析为Request和Reponse对象</li>
<li>找到Request对象对应的Host,Context,Wrapper</li>
<li>调用最终的Servelt的service进行处理。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tomcat关闭过程（Tomcat源代码阅读系列之四）]]></title>
    <link href="http://imtiger.github.io/blog/2013/10/21/tomcat-shutdown/"/>
    <updated>2013-10-21T14:45:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2013/10/21/tomcat-shutdown</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/10/14/apache_tomcat_bag.jpg">
本文是<a href="/blog/2013/10/08/tomcat-source-code-study/">Tomcat源代码阅读系列</a>的第四篇文章，在阅读此文之前，建议先读前三篇：<br/>
<a href="/blog/2013/10/14/run-tomcat-in-idea-or-eclipse/">在IntelliJ IDEA 和 Eclipse运行tomcat 7源代码（Tomcat源代码阅读系列之一）</a> <br/>
<a href="/blog/2013/10/16/tomcat-architecture/">Tomcat总体结构                             （Tomcat源代码阅读系列之二）</a><br/>
<a href="/blog/2013/10/17/tomcat-start-process/">Tomcat启动过程（Tomcat源代码阅读系列之三）</a></p>

<p>我们在<a href="/blog/2013/10/17/tomcat-start-process/">Tomcat启动过程（Tomcat源代码阅读系列之三）</a>一文中已经知道Tomcat启动以后，会启动6条线程，他们分别如下：</p>

<!-- more -->


<p>```java Tomcat threads
&ldquo;ajp-bio-8009-AsyncTimeout&rdquo; daemon prio=5 tid=7f8738afe000 nid=0x115ad6000 waiting on condition [115ad5000]</p>

<p>&ldquo;ajp-bio-8009-Acceptor-0&rdquo; daemon prio=5 tid=7f8738b05800 nid=0x1159d3000 runnable [1159d2000]</p>

<p>&ldquo;http-bio-8080-AsyncTimeout&rdquo; daemon prio=5 tid=7f8735acb800 nid=0x1158d0000 waiting on condition [1158cf000]</p>

<p>&ldquo;http-bio-8080-Acceptor-0&rdquo; daemon prio=5 tid=7f8735acd000 nid=0x1157cd000 runnable [1157cc000]</p>

<p>&ldquo;ContainerBackgroundProcessor[StandardEngine[Catalina]]&rdquo; daemon prio=5 tid=7f8732850800 nid=0x111203000 waiting on condition [111202000]</p>

<p>&ldquo;main&rdquo; prio=5 tid=7f8735000800 nid=0x10843e000 runnable [10843c000]
```</p>

<p>其中5条是Dameon线程，而对于Java程序来说，当所有非Dameon程序都终止的时候，Jvm就会退出，因此要想终止Tomcat就只需要将main这一条非Dameon线程终止了即可。</p>

<blockquote><p>Dameon线程又叫后台或者守护线程，它负责在程序运行期提供一种通用服务的线程，比如垃圾收集线程，非Dameon线程和Dameon线程的区别就在于当程序中所有的非Daemon线程都终止的时候，Jvm会杀死余下的Dameon线程，然后退出。</p></blockquote>

<p>接下来，我们就来一步步的分析如何来让main线程终止，要想终止它，我们还是得从Tomcat的启动中来寻找答案，我们在分析Tomcat容器启动的时候，在Catalina#start中有一段代码，我们没有关注，接下来就来看看这段代码：
```java org.apache.catalina.startup.Catalina#start
public void start() {</p>

<pre><code>// ignore other code 

// Register shutdown hook
// 1 
if (useShutdownHook) {
    if (shutdownHook == null) {
        shutdownHook = new CatalinaShutdownHook();
    }
    Runtime.getRuntime().addShutdownHook(shutdownHook);

    // If JULI is being used, disable JULI's shutdown hook since
    // shutdown hooks run in parallel and log messages may be lost
    // if JULI's hook completes before the CatalinaShutdownHook()
    LogManager logManager = LogManager.getLogManager();
    if (logManager instanceof ClassLoaderLogManager) {
        ((ClassLoaderLogManager) logManager).setUseShutdownHook(
                false);
    }
}

// 2
if (await) {
    await();
    stop();
}
</code></pre>

<p>}</p>

<p>```</p>

<p>这里就是Tomcat关闭流程的入口代码了。我在代码中标注了两处，我们首先来看标注1的地方。标注1的代码，我们用到了Jvm的shutdownHook机制。对于shutdownHook大家可以参考<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Runtime.html#addShutdownHook%28java.lang.Thread%29">这个连接</a>,我这里做一个简单的介绍，shutdown hook是一个已经初始化但是还没有启动的线程，当Jvm关闭的时候，它会启动并并发的运行所有已经注册过的shutdown hooks，知道了这点，我们就来看看<code>CatalinaShutdownHook</code>线程做了什么事情？它的代码如下：
```java org.apache.catalina.startup.Catalina.CatalinaShutdownHook#run</p>

<p>public void run() {</p>

<pre><code>try {
    if (getServer() != null) {
        Catalina.this.stop();
    }
} catch (Throwable ex) {
    ExceptionUtils.handleThrowable(ex);
    log.error(sm.getString("catalina.shutdownHookFail"), ex);
} finally {
    // If JULI is used, shut JULI down *after* the server shuts down
    // so log messages aren't lost
    LogManager logManager = LogManager.getLogManager();
    if (logManager instanceof ClassLoaderLogManager) {
        ((ClassLoaderLogManager) logManager).shutdown();
    }
}
</code></pre>

<p>}
```
通过上面的代码，我们可以清楚的看到调用了Catalina的stop方法。而Catalina#stop方法最终又是调用了StandardServer#stop方法和destroy方法。通过这里，我们知道Tomcat利用了shutdown hook机制来在Jvm关闭的时候关闭各个组件。但是Jvm又是何时退出的呢？这就要来看标注为2的代码了。</p>

<p>接下来我们再来看看标注2的地方：在标注为2的代码中，首先判断了await属性是否为true,如果为true就调用await()，调用完以后，再调用stop方法，接下来我们就来看await()方法,而catalina的awit方法又调用了StandardServer#awit方法，它的代码如下：
```java org.apache.catalina.core.StandardServer#await
public void await() {</p>

<pre><code>// Set up a server socket to wait on
try {
    awaitSocket = new ServerSocket(port, 1,
            InetAddress.getByName(address));
} catch (IOException e) {
    log.error("StandardServer.await: create[" + address
                       + ":" + port
                       + "]: ", e);
    return;
}

try {
    awaitThread = Thread.currentThread();

    // Loop waiting for a connection and a valid command
    while (!stopAwait) {
        ServerSocket serverSocket = awaitSocket;
        if (serverSocket == null) {
            break;
        }

        // Wait for the next connection
        Socket socket = null;
        StringBuilder command = new StringBuilder();
        try {
            InputStream stream;
            try {
                socket = serverSocket.accept();
                socket.setSoTimeout(10 * 1000);  // Ten seconds
                stream = socket.getInputStream();
            } catch (AccessControlException ace) {
                log.warn("StandardServer.accept security exception: "
                        + ace.getMessage(), ace);
                continue;
            } catch (IOException e) {
                if (stopAwait) {
                    // Wait was aborted with socket.close()
                    break;
                }
                log.error("StandardServer.await: accept: ", e);
                break;
            }

            // Read a set of characters from the socket
            int expected = 1024; // Cut off to avoid DoS attack
            while (expected &lt; shutdown.length()) {
                if (random == null)
                    random = new Random();
                expected += (random.nextInt() % 1024);
            }
            while (expected &gt; 0) {
                int ch = -1;
                try {
                    ch = stream.read();
                } catch (IOException e) {
                    log.warn("StandardServer.await: read: ", e);
                    ch = -1;
                }
                if (ch &lt; 32)  // Control character or EOF terminates loop
                    break;
                command.append((char) ch);
                expected--;
            }
        } finally {
            // Close the socket now that we are done with it
            try {
                if (socket != null) {
                    socket.close();
                }
            } catch (IOException e) {
                // Ignore
            }
        }

        // Match against our command string
        boolean match = command.toString().equals(shutdown);
        if (match) {
            log.info(sm.getString("standardServer.shutdownViaPort"));
            break;
        } else
            log.warn("StandardServer.await: Invalid command '"
                    + command.toString() + "' received");
    }
} finally {
    ServerSocket serverSocket = awaitSocket;
    awaitThread = null;
    awaitSocket = null;

    // Close the server socket and return
    if (serverSocket != null) {
        try {
            serverSocket.close();
        } catch (IOException e) {
            // Ignore
        }
    }
}
</code></pre>

<p>}
```</p>

<p>通过上面的代码，我们可以看出在配置的端口上通过ServerSocket来监听一个请求的到来，如果请求的字符串和配置的字符串相同的话即跳出循环，这样的话就会运行stop方法，运行完了以后，main线程就退出了。</p>

<blockquote><p>这里ServerSocket监听的端口，以及对比的字符串都是在conf/server.xml中配置的，缺省情况下，配置如下：<Server port="8005" shutdown="SHUTDOWN"></Server>,从这里可以看出监听端口为8005,关闭请求发送的字符串为SHUTDOWN.</p></blockquote>

<p>看到这里，我们基本上已经清楚了Tomcat的关闭就是通过在8005端口，发送一个SHUTDOWN字符串。那么我们就来实验一下。首先启动Tomcat，然后在终端运行如下指令：
<code>bash telnet
telnet 127.0.0.1 8005
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
SHUTDOWN
Connection closed by foreign host.
</code>
运行telnet命令，并发送SHUTDOWN字符串以后，我们发现Tomcat就会退出await方法，然后执行stop方法最终停止。</p>

<p>但是一般情况下，我们停止tomcat都不会像上面那种方式来关闭，我们一般有两种方式来关闭：</p>

<ol>
<li>ps aux | grep java ,kill -9 <pid><br/>
对于这种方式，比较简单粗暴会直接干掉进程，不过这种简单粗暴的方式我也经常用。</li>
<li>运行shutdown.sh<br/>
这种方式其实最终也是向server发送了一个SHUTDOWN字符串，我们接下来分析下第二种情况。<br/>
查看shutdown.sh最终是调用了 catalina.sh，并传递了stop参数。查看catalina.sh脚本，最终其实是调用了 <code>org.apache.catalina.startup.Bootstrap#main</code>,并传递参数stop.我们查看Bootstrap#main方法，发现会调用<code>org.apache.catalina.startup.Bootstrap#stopServer</code>,而Bootstrap#stopServer通过反射调用了<code>org.apache.catalina.startup.Catalina#stopServer</code>,我们来看看Catalina#stopServer方法，代码如下：
```java org.apache.catalina.startup.Catalina#stopServer</li>
</ol>


<p>public void stopServer(String[] arguments) {</p>

<pre><code>if (arguments != null) {
    arguments(arguments);
}

Server s = getServer();
// 1 
if( s == null ) {
    // Create and execute our Digester
    Digester digester = createStopDigester();
    digester.setClassLoader(Thread.currentThread().getContextClassLoader());
    File file = configFile();
    FileInputStream fis = null;
    try {
        InputSource is =
            new InputSource(file.toURI().toURL().toString());
        fis = new FileInputStream(file);
        is.setByteStream(fis);
        digester.push(this);
        digester.parse(is);
    } catch (Exception e) {
        log.error("Catalina.stop: ", e);
        System.exit(1);
    } finally {
        if (fis != null) {
            try {
                fis.close();
            } catch (IOException e) {
                // Ignore
            }
        }
    }
} else {
    // Server object already present. Must be running as a service
    try {
        s.stop();
    } catch (LifecycleException e) {
        log.error("Catalina.stop: ", e);
    }
    return;
}

// Stop the existing server
s = getServer();
// 2
if (s.getPort()&gt;0) {
    Socket socket = null;
    OutputStream stream = null;
    try {
        socket = new Socket(s.getAddress(), s.getPort());
        stream = socket.getOutputStream();
        String shutdown = s.getShutdown();
        for (int i = 0; i &lt; shutdown.length(); i++) {
            stream.write(shutdown.charAt(i));
        }
        stream.flush();
    } catch (ConnectException ce) {
        log.error(sm.getString("catalina.stopServer.connectException",
                               s.getAddress(),
                               String.valueOf(s.getPort())));
        log.error("Catalina.stop: ", ce);
        System.exit(1);
    } catch (IOException e) {
        log.error("Catalina.stop: ", e);
        System.exit(1);
    } finally {
        if (stream != null) {
            try {
                stream.close();
            } catch (IOException e) {
                // Ignore
            }
        }
        if (socket != null) {
            try {
                socket.close();
            } catch (IOException e) {
                // Ignore
            }
        }
    }
} else {
    log.error(sm.getString("catalina.stopServer"));
    System.exit(1);
}
</code></pre>

<p>}
```
我们来分析一下标注的地方：</p>

<ol>
<li>标注1的代码，此时因为是新开了一个进程,并且conf/server.xml还没有解析，因此s是NULL，通过Digester解析conf/server.xml，最终生成了未初始化的StandardServer对象。</li>
<li>标注2的代码，向standardServer.getPort返回的端口（其实这里面返回即是conf/server.xml中Server根节点配置的port和shutdown属性）发送了standardServer.getShutdown()返回的字符串，而默认情况下这个字符串就是SHUTDOWN.</li>
</ol>


<p>分析到这里，我想大家已经清楚了Tomcat的关闭流程，我们再来总结一下：
Tomcat启动的时候的主线程会在8005端口（默认配置，可以更改）上建立socket监听，当关闭的时候，最终其实就是新起了一个进程然后向Tomcat主线程监听的8005端口发送了一个SHUTDOWN字符串，这样主线程就会结束了，主线程结束了以后，因为其它的线程都是dameon线程，这样依赖Jvm就会退出了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tomcat启动过程（Tomcat源代码阅读系列之三）]]></title>
    <link href="http://imtiger.github.io/blog/2013/10/17/tomcat-start-process/"/>
    <updated>2013-10-17T11:03:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2013/10/17/tomcat-start-process</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/10/14/apache_tomcat_bag.jpg">
本文是<a href="/blog/2013/10/08/tomcat-source-code-study/">Tomcat源代码阅读系列</a>的第三篇文章，在阅读此文之前，建议先读前面的两篇：<br/>
<a href="/blog/2013/10/14/run-tomcat-in-idea-or-eclipse/">在IntelliJ IDEA 和 Eclipse运行tomcat 7源代码（Tomcat源代码阅读系列之一）</a> <br/>
<a href="/blog/2013/10/16/tomcat-architecture/">Tomcat总体结构                             （Tomcat源代码阅读系列之二）</a></p>

<p>本篇我们来一起分析一下Tomcat的启动过程，启动过程涉及到了Tomcat组件的生命周期管理，本文将从<strong>Tomcat组件生命周期管理</strong>,<strong>Tomcat启动的总过程</strong>，<strong>Tomcat启动过程关键步骤分析</strong>三个方面来进行描述。</p>

<!-- more -->


<h1>Tomcat组件生命周期管理</h1>

<p>在<a href="/blog/2013/10/16/tomcat-architecture/">Tomcat总体结构                             （Tomcat源代码阅读系列之二）</a>中，我们列出了Tomcat中Server,Service,Connector,Engine,Host,Context的继承关系图，你会发现它们都实现了<code>org.apache.catalina.Lifecycle</code>接口，而<code>org.apache.catalina.util.LifecycleBase</code>采用了<code>模板方法模式</code>来对所有支持生命周期管理的组件的生命周期各个阶段进行了总体管理，每个需要生命周期管理的组件只需要继承这个基类，然后覆盖对应的钩子方法即可完成相应的生命周期阶段性的管理工作。
下面我们首先来看看<code>org.apache.catalina.Lifecycle</code>接口的定义，它的类图如下图所示：
<img class="center" src="/images/2013/10/17/LifeCycle.png">
从上图我们可以清楚的看到LifeCycle中主要有四个生命周期阶段，它们分别是init(初始化)，start(启动),stop(停止)，destory(销毁)。知道了这四个生命周期阶段以后，咋们就来看看<code>org.apache.catalina.util.LifecycleBase</code>是如何实现<code>模板方法模式</code>的。
那接下来我们就来看看<code>org.apache.catalina.util.LifecycleBase</code>类的定义，它的类图如下所示：
<img class="center" src="/images/2013/10/17/LifeCycleBase.png">
上图中用红色标注的四个方法就是<code>模板方法模式</code>中的钩子方法，子类可以通过实现钩子方法来纳入到基类已经流程化好的生命周期管理中。<br/>
上面我们对LifeCycle和LifeCycleBase有了一个总体的认识，接下来，我们通过查看<code>org.apache.catalina.util.LifecycleBase</code>的源代码来具体的分析一下。
咋们首先来看<code>org.apache.catalina.util.LifecycleBase</code>的init方法的实现。
```java org.apache.catalina.util.LifecycleBase#init
@Override
public final synchronized void init() throws LifecycleException {</p>

<pre><code>    // 1
    if (!state.equals(LifecycleState.NEW)) {
        invalidTransition(Lifecycle.BEFORE_INIT_EVENT);
    }
    setStateInternal(LifecycleState.INITIALIZING, null, false);

    try {
        // 2 
        initInternal();
    } catch (Throwable t) {
        ExceptionUtils.handleThrowable(t);
        setStateInternal(LifecycleState.FAILED, null, false);
        throw new LifecycleException(
                sm.getString("lifecycleBase.initFail",toString()), t);
    }
    // 3 
    setStateInternal(LifecycleState.INITIALIZED, null, false);
</code></pre>

<p>}
```
下面我们逐一来分析一下上述代码中标注了数字的地方：</p>

<ol>
<li>标注1的代码首先检测当前组件的状态是不是<code>NEW</code>(新建)，如果不是就调用<code>org.apache.catalina.util.LifecycleBase#invalidTransition</code>方法来将当前的状态转换过程终止，而<code>invalidTransition</code>的实现是抛出了<code>org.apache.catalina.LifecycleException</code>异常。接着调用了<code>setStateInternal</code>方法将状态设置为INITIALIZING（正在初始化）</li>
<li>标注2的代码就是init模板方法的钩子，子类可以通过实现<code>protected abstract void initInternal() throws LifecycleException;</code>方法来纳入初始化的流程。</li>
<li>标注3的代码将组件的状态改为<code>INITIALIZED</code>(已初始化)。</li>
</ol>


<p>上面我们分析了init模板方法，接下来我们再看看start方法具体做了什么事情。start的代码如下：
```java org.apache.catalina.util.LifecycleBase#start</p>

<pre><code>public final synchronized void start() throws LifecycleException {
    // 1
    if (LifecycleState.STARTING_PREP.equals(state) ||
            LifecycleState.STARTING.equals(state) ||
            LifecycleState.STARTED.equals(state)) {

        if (log.isDebugEnabled()) {
            Exception e = new LifecycleException();
            log.debug(sm.getString("lifecycleBase.alreadyStarted",
                    toString()), e);
        } else if (log.isInfoEnabled()) {
            log.info(sm.getString("lifecycleBase.alreadyStarted",
                    toString()));
        }

        return;
    }

    // 2
    if (state.equals(LifecycleState.NEW)) {
        init();
    } else if (state.equals(LifecycleState.FAILED)){
        stop();
    } else if (!state.equals(LifecycleState.INITIALIZED) &amp;&amp;
            !state.equals(LifecycleState.STOPPED)) {
        invalidTransition(Lifecycle.BEFORE_START_EVENT);
    }
    // 3
    setStateInternal(LifecycleState.STARTING_PREP, null, false);

    try {
    //4   
        startInternal();
    } catch (Throwable t) {
        ExceptionUtils.handleThrowable(t);
        setStateInternal(LifecycleState.FAILED, null, false);
        throw new LifecycleException(
                sm.getString("lifecycleBase.startFail",toString()), t);
    }

    // 5
    if (state.equals(LifecycleState.FAILED) ||
            state.equals(LifecycleState.MUST_STOP)) {
        stop();
    } else {
        // Shouldn't be necessary but acts as a check that sub-classes are
        // doing what they are supposed to.
        if (!state.equals(LifecycleState.STARTING)) {
            invalidTransition(Lifecycle.AFTER_START_EVENT);
        }

        setStateInternal(LifecycleState.STARTED, null, false);
    }
}
</code></pre>

<p>```
下面我们逐一来分析一下上述代码中标注了数字的地方：</p>

<ol>
<li>标注1的代码检测当前组件的状态是不是<code>STARTING_PREP</code>(准备启动),<code>STARTING</code>（正在启动）,<code>STARTED</code>（已启动）.如果是这三个状态中的任何一个，则抛出<code>LifecycleException</code>。</li>
<li>标注2的代码的检查其实主要是为了保证组件状态的完整性，在正常启动的流程中，应该是不会出现没有初始化就启动，或者还没启动就已经失败的情况。</li>
<li>标注3的代码设置组件的状态为<code>STARTING_PREP</code>（准备启动状态）</li>
<li>标注4的代码是start模板方法的钩子方法，子类通过实现<code>org.apache.catalina.util.LifecycleBase#startInternal</code>这个方法来纳入到组件启动的流程中来。</li>
<li>标注5的代码做了一些状态检查，然后最终将组件的状态设置为<code>STARTED</code>(已启动)</li>
</ol>


<p>上面我们分析了init和start方法的流程，对于stop和destroy方法的总体过程是类似的，大家可以自己阅读一下，但是通过上面的分析，我们可以得出生命周期方法的总体的骨架，如果用伪代码来表示可以简化为如下：
```java org.apache.catalina.util.LifecycleBase#lifeCycleMethod</p>

<pre><code>public final synchronized void lfieCycleMethod() throws LifecycleException {
    stateCheck();//状态检查
    //设置为进入相应的生命周期之前的状态
    setStateInternal(LifecycleState.BEFORE_STATE, null, false);
    lfieCycleMethodInternal();//钩子方法
    //进入相应的生命周期之后的状态
    setStateInternal(LifecycleState.AFTER_STATE, null, false);
}
</code></pre>

<p>```</p>

<h1>Tomcat启动的总过程</h1>

<p>通过上面的介绍，我们总体上清楚了各个组件的生命周期的各个阶段具体都是如何运作的。接下来我们就来看看，Tomcat具体是如何一步步启动起来的。我们都知道任何Java程序都有一个main函数入口，Tomcat中的main入口是<code>org.apache.catalina.startup.Bootstrap#main</code>,下面我们就来分析一下它的代码：
```java org.apache.catalina.startup.Bootstrap#main
public static void main(String args[]) {</p>

<pre><code>if (daemon == null) {
    // Don't set daemon until init() has completed
    // 1 
    Bootstrap bootstrap = new Bootstrap();
    try {
        // 2
        bootstrap.init();
    } catch (Throwable t) {
        handleThrowable(t);
        t.printStackTrace();
        return;
    }
    // 3
    daemon = bootstrap;
} else {
    // When running as a service the call to stop will be on a new
    // thread so make sure the correct class loader is used to prevent
    // a range of class not found exceptions.
    Thread.currentThread().setContextClassLoader(daemon.catalinaLoader);
}

try {
    String command = "start";
    if (args.length &gt; 0) {
        command = args[args.length - 1];
    }

    if (command.equals("startd")) {
        args[args.length - 1] = "start";
        daemon.load(args);
        daemon.start();
    } else if (command.equals("stopd")) {
        args[args.length - 1] = "stop";
        daemon.stop();
    } else if (command.equals("start")) {
        // 4
        daemon.setAwait(true);
        daemon.load(args);
        daemon.start();
    } else if (command.equals("stop")) {
        daemon.stopServer(args);
    } else if (command.equals("configtest")) {
        daemon.load(args);
        if (null==daemon.getServer()) {
            System.exit(1);
        }
        System.exit(0);
    } else {
        log.warn("Bootstrap: command \"" + command + "\" does not exist.");
    }
} catch (Throwable t) {
    // Unwrap the Exception for clearer error reporting
    if (t instanceof InvocationTargetException &amp;&amp;
            t.getCause() != null) {
        t = t.getCause();
    }
    handleThrowable(t);
    t.printStackTrace();
    System.exit(1);
}
</code></pre>

<p>}</p>

<p>```</p>

<p>下面我们逐一来分析一下上述代码中标注了数字的地方：</p>

<ol>
<li>标注1的代码初始化了自举类的实例，标注2的代码对BootStrap实例进行了初始化，标注3的代码将实例赋值给了daemon。</li>
<li>标注4的代码首先调用了BootStrap的load方法，然后调用了start方法。</li>
</ol>


<p>接下来我们分别分析一下BootStrap的init,load，start方法具体做了哪些工作。</p>

<h2>BootStrap#init方法</h2>

<p>首先来看<code>org.apache.catalina.startup.Bootstrap#init</code>方法，它的代码如下：
```java org.apache.catalina.startup.Bootstrap#init
public void init()throws Exception{</p>

<pre><code>// Set Catalina path
setCatalinaHome();
setCatalinaBase();

initClassLoaders();

Thread.currentThread().setContextClassLoader(catalinaLoader);

SecurityClassLoad.securityClassLoad(catalinaLoader);

// Load our startup class and call its process() method
if (log.isDebugEnabled())
    log.debug("Loading startup class");
// 1
Class&lt;?&gt; startupClass =
    catalinaLoader.loadClass
    ("org.apache.catalina.startup.Catalina");
Object startupInstance = startupClass.newInstance();

// Set the shared extensions class loader
if (log.isDebugEnabled())
    log.debug("Setting startup class properties");
String methodName = "setParentClassLoader";
Class&lt;?&gt; paramTypes[] = new Class[1];
paramTypes[0] = Class.forName("java.lang.ClassLoader");
Object paramValues[] = new Object[1];
paramValues[0] = sharedLoader;
Method method =
    startupInstance.getClass().getMethod(methodName, paramTypes);
// 2
method.invoke(startupInstance, paramValues);
// 3
catalinaDaemon = startupInstance;
</code></pre>

<p>}</p>

<p>```
下面我们重点逐一来分析一下上述代码中标注了数字的地方：</p>

<ol>
<li>标注1的代码通过反射实例化了<code>org.apache.catalina.startup.Catalina</code>类的实例;</li>
<li>标注2的代码调用了Catalina实例的setParentClassLoader方法设置了父亲ClassLoader，对于ClassLoader方面的内容，我们在本系列的后续文章再来看看。标注3的代码将Catalina实例赋值给了Bootstrap实例的catalinaDaemon.</li>
</ol>


<h2>BootStrap#load</h2>

<p>接下来我们再来看看<code>org.apache.catalina.startup.Bootstrap#load</code>方法，通过查看源代码，我们知道此方法通过反射调用了<code>org.apache.catalina.startup.Catalina#load</code>方法，那我们就来看看Catalina的load方法，Catalina#load方法代码如下：
```java org.apache.catalina.startup.Catalina#load
public void load() {</p>

<pre><code>// 1 
Digester digester = createStartDigester();

InputSource inputSource = null;
InputStream inputStream = null;
File file = null;
try {
    file = configFile();
    inputStream = new FileInputStream(file);
    inputSource = new InputSource(file.toURI().toURL().toString());
} catch (Exception e) {
    if (log.isDebugEnabled()) {
        log.debug(sm.getString("catalina.configFail", file), e);
    }
}



try {
    inputSource.setByteStream(inputStream);
    digester.push(this);
    digester.parse(inputSource);
} catch (SAXParseException spe) {
    log.warn("Catalina.start using " + getConfigFile() + ": " +
            spe.getMessage());
    return;
} catch (Exception e) {
    log.warn("Catalina.start using " + getConfigFile() + ": " , e);
    return;
} finally {
    try {
        inputStream.close();
    } catch (IOException e) {
        // Ignore
    }
}


getServer().setCatalina(this);

// Stream redirection
initStreams();

// Start the new server
try {
    // 2
    getServer().init();
} catch (LifecycleException e) {
    if (Boolean.getBoolean("org.apache.catalina.startup.EXIT_ON_INIT_FAILURE")) {
        throw new java.lang.Error(e);
    } else {
        log.error("Catalina.start", e);
    }

}
</code></pre>

<p>}
```
上面的代码，我只保留了主流程核心的代码，下面我们重点逐一来分析一下上述代码中标注了数字的地方：</p>

<ol>
<li>标注1的代码创建Digester实例解析"conf/server.xml"文件</li>
<li>标注2的代码最终调用了StandardServer的init方法。</li>
</ol>


<p>大家可以自行查看下源代码，我们会发现如下的一个调用流程：
<code>java init call stack  
org.apache.catalina.core.StandardServer#init   
-&gt;org.apache.catalina.core.StandardService#init  
--&gt;org.apache.catalina.connector.Connector#init  
--&gt;org.apache.catalina.core.StandardEngine#init  
</code></p>

<blockquote><p>因为StandardService，Connector，StandardEngine实现了LifeCycle接口，因此符合我们上文所获的生命周期的管理，最终都是通过他们自己实现的initInternal方法进行初始化</p></blockquote>

<p>读到这里的时候，我想大家应该和我一样，以为StandardEngine#init方法会调用StandardHost#init方法，但是当我们查看StandardEngine#init方法的时候，发现并没有进行StandardHost的初始化，它到底做了什么呢？让我们来具体分析一下,我们首先拿StanderEngine的继承关系图来看下：
<img class="center" src="/images/2013/10/16/StandardEngine.png">
通过上图以及前面说的LifeCyecle的模板方法模式，我们知道StandardEngine的初始化钩子方法initInternal方法最终调用了ContainerBase的initInternal方法，那我们拿ContainerBase#initInternal方法的代码看看：<br/>
```java org.apache.catalina.core.ContainerBase#initInternal
protected void initInternal() throws LifecycleException {</p>

<pre><code>BlockingQueue&lt;Runnable&gt; startStopQueue =
    new LinkedBlockingQueue&lt;Runnable&gt;();
startStopExecutor = new ThreadPoolExecutor(
        getStartStopThreadsInternal(),
        getStartStopThreadsInternal(), 10, TimeUnit.SECONDS,
        startStopQueue,
        new StartStopThreadFactory(getName() + "-startStop-"));
startStopExecutor.allowCoreThreadTimeOut(true);
super.initInternal();
</code></pre>

<p>}
<code>
我们可以看到StandardEngine的初始化仅仅是创建了一个ThreadPoolExecutor，当看到这里的时候，笔者当时也纳闷了，StandardEngine#init竟然没有调用StandardHost#init方法，那么StandardHost的init方法是什么时候被调用的呢？遇到这种不知道到底方法怎么调用的时候怎么办呢？笔者介绍个方法给大家。我们现在需要知道StandardHost#init方法何时被调用的，而我们知道init最终会调用钩子的initInternal方法，因此这个时候，我们可以在StandardHost中override initInternal方法，增加了实现方法以后，有两种方法可以用，一种就是设置个断点debug一下就可以看出线程调用栈了，另外一种就是在新增的方法中打印出调用栈。笔者这里采用第二种方法，我们增加如下的initInternal方法到StandardHost中：
</code>java org.apache.catalina.core.StandardHost#initInternal
protected void initInternal() throws LifecycleException {</p>

<pre><code>Throwable ex = new Throwable();
StackTraceElement[] stackElements = ex.getStackTrace();
if (stackElements != null) {
    for (int i = stackElements.length - 1; i &gt;= 0; i--) {
        System.out.print(stackElements[i].getClassName() + "\t");
        System.out.print(stackElements[i].getMethodName() + "\t");
        System.out.print(stackElements[i].getFileName() + "\t");
        System.out.println(stackElements[i].getLineNumber());
    }
}
super.initInternal();   
</code></pre>

<p>}
<code>
上面的代码将会打印出方法调用堆栈，对于调试非常有用，上面的方法运行以后在控制台打印出了如下的堆栈信息：
</code>java stack info
java.lang.Thread    run Thread.java 680
java.util.concurrent.ThreadPoolExecutor$Worker  run ThreadPoolExecutor.java 918
java.util.concurrent.ThreadPoolExecutor$Worker  runTask ThreadPoolExecutor.java 895
java.util.concurrent.FutureTask run FutureTask.java 138
java.util.concurrent.FutureTask$Sync    innerRun    FutureTask.java 303
org.apache.catalina.core.ContainerBase$StartChild   call    ContainerBase.java  1549
org.apache.catalina.core.ContainerBase$StartChild   call    ContainerBase.java  1559
org.apache.catalina.util.LifecycleBase  start   LifecycleBase.java  139
org.apache.catalina.util.LifecycleBase  init    LifecycleBase.java  102
org.apache.catalina.core.StandardHost   initInternal    StandardHost.java   794
```
通过控制台的信息，我们看到是StartChild#call方法调用的，而我们查看StartChild#call方法其实是在StandardEngine的startInternal方法中通过异步线程池去初始化子容器。因此到这里我们就理清楚了，StarndardHost的init方法是在调用start方法的时候被初始化。那么接下来我们就来看看，start方法的整体调用流程。</p>

<h2>BootStrap#start</h2>

<p>采用分析load方法一样的方法，经过对BootStrap#start的分析，我们最终可以得到得到如下的调用链：
<code>java org.apache.catalina.startup.Bootstrap#start call stack
org.apache.catalina.startup.Bootstrap#start
-&gt;org.apache.catalina.startup.Catalina#start 通过反射调用
--&gt;org.apache.catalina.core.StandardServer#start
---&gt;org.apache.catalina.core.StandardService#start
----&gt;org.apache.catalina.core.StandardEngine#start
----&gt;org.apache.catalina.Executor#start
----&gt;org.apache.catalina.connector.Connector#start
</code></p>

<p>综合上文的描述我们总体得到如下的调用链：
```java org.apache.catalina.startup.Bootstrap#main call stack
org.apache.catalina.startup.Bootstrap#main
&ndash;>org.apache.catalina.startup.Bootstrap#init
&ndash;>org.apache.catalina.startup.Bootstrap#load
&mdash;>org.apache.catalina.startup.Catalina#load
&mdash;&ndash;>org.apache.catalina.core.StandardServer#init
&mdash;&mdash;>org.apache.catalina.core.StandardService#init
&mdash;&mdash;&ndash;>org.apache.catalina.connector.Connector#init
&mdash;&mdash;&ndash;>org.apache.catalina.core.StandardEngine#init
&ndash;>org.apache.catalina.startup.Bootstrap#start
&mdash;>org.apache.catalina.startup.Catalina#start 通过反射调用
&mdash;&ndash;>org.apache.catalina.core.StandardServer#start
&mdash;&mdash;>org.apache.catalina.core.StandardService#start
&mdash;&mdash;&ndash;>org.apache.catalina.core.StandardEngine#start
&mdash;&mdash;&ndash;>org.apache.catalina.Executor#start
&mdash;&mdash;&ndash;>org.apache.catalina.connector.Connector#start</p>

<p>```
通过上面的分析我们已经搞清楚了Tomcat启动的总体的过程，但是有一些关键的步骤，我们还需要进行进一步的深入探究。let&rsquo;s do it.</p>

<h1>Tomcat启动过程关键步骤分析</h1>

<h2>Connector#init</h2>

<p>我们首先来看一下<strong>org.apache.catalina.connector.Connector#init</strong>,我们知道Connector的生命周期也是通过LifeCycle的模板方法模式来管理的，那么我们只需要查看一下它的initInternal方法即可知道它是如何初始化的。接下来我们就来看一下initInternal方法，代码如下：</p>

<p>```java org.apache.catalina.connector.Connector#initInternal
protected void initInternal() throws LifecycleException {</p>

<pre><code>    super.initInternal();

    // Initialize adapter
    adapter = new CoyoteAdapter(this);
    protocolHandler.setAdapter(adapter);

    // Make sure parseBodyMethodsSet has a default
    if( null == parseBodyMethodsSet ) {
        setParseBodyMethods(getParseBodyMethods());
    }

    if (protocolHandler.isAprRequired() &amp;&amp;
            !AprLifecycleListener.isAprAvailable()) {
        throw new LifecycleException(
                sm.getString("coyoteConnector.protocolHandlerNoApr",
                        getProtocolHandlerClassName()));
    }

    try {
        // 1 
        protocolHandler.init();
    } catch (Exception e) {
        throw new LifecycleException
            (sm.getString
             ("coyoteConnector.protocolHandlerInitializationFailed"), e);
    }

    // Initialize mapper listener
    mapperListener.init();
}
</code></pre>

<p>```</p>

<p>上面代码中，本文最关心的是标注了1的地方，这个地方调用了<code>org.apache.coyote.ProtocolHandler#init</code>方法，而ProtocolHandler是在Connector的构造函数中初始化，而Connector的构造函数又是Digester类解析conf/server.xml的时候调用的，明白了这点，我们在来具体看看Connector构造函数中调用的一个核心的方法setProtocol方法，下面是其代码：</p>

<p>```java org.apache.catalina.connector.Connector#setProtocol
public void setProtocol(String protocol) {</p>

<pre><code>    if (AprLifecycleListener.isAprAvailable()) {
        //这里统一使用AprEndpoint
        if ("HTTP/1.1".equals(protocol)) {
            setProtocolHandlerClassName
                ("org.apache.coyote.http11.Http11AprProtocol");   //Http11AprProtocol$Http11ConnectionHandler
        } else if ("AJP/1.3".equals(protocol)) {
            setProtocolHandlerClassName
                ("org.apache.coyote.ajp.AjpAprProtocol");     //AjpAprProtocol$AjpConnectionHandler
        } else if (protocol != null) {
            setProtocolHandlerClassName(protocol);
        } else {
            setProtocolHandlerClassName
                ("org.apache.coyote.http11.Http11AprProtocol");
        }
    } else {
        // 1 
        if ("HTTP/1.1".equals(protocol)) {
            setProtocolHandlerClassName
                ("org.apache.coyote.http11.Http11Protocol");  //Http11Protocol$Http11ConnectionHandler
        } else if ("AJP/1.3".equals(protocol)) {
            setProtocolHandlerClassName
                ("org.apache.coyote.ajp.AjpProtocol");    //AjpProtocol$AjpConnectionHandler
        } else if (protocol != null) {
            setProtocolHandlerClassName(protocol);
        }
    }
</code></pre>

<p>}</p>

<p>```</p>

<p>从setProtocol的代码中，我们可以看出主要逻辑分为了两块，一种情况是使用<a href="http://tomcat.apache.org/tomcat-7.0-doc/apr.html">APR(Apache Portable Runtime)</a>，另外一种是不使用APR的情况。缺省情况下不采用APR库，这样的话，代码会走到标注1的代码分支，这里通过协议的不同，最终初始化了不同的类。如果是http1.1协议就采用<code>org.apache.coyote.http11.Http11Protocol</code>,如果是AJP(Apache Jserv Protocol)协议，就采用<code>org.apache.coyote.ajp.AjpProtocol</code>类，下面我们来看一下Http11Protocol和AjpProtocol的继承关系图如下：
<img class="center" src="/images/2013/10/17/Http11Protocol.png"><br/>
<img class="center" src="/images/2013/10/17/AJPProtocol.png">
通过上图我们可以看到它们都继承了公共的基类<code>org.apache.coyote.AbstractProtocol</code>,而它们自己的init方法最终其实都是调用了AbstractProtocol的init方法，通过查看AbstractProtocol#init代码，我们可以看到最终是调用了<code>org.apache.tomcat.util.net.AbstractEndpoint#init</code>,而AbstractEndpoint的实例化操作是在实例化AjpProtocol和Http11Protocol的时候在其构造函数中实例化的，而AjpProtocol和Http11Protocol构造函数中，其实都是初始化了<code>org.apache.tomcat.util.net.JIoEndpoint</code>类，只不过根据是http协议还是AJP协议，它们具有不同的连接处理类。其中Http11Protocol的连接处理类为<code>org.apache.coyote.http11.Http11Protocol.Http11ConnectionHandler</code>,而连接处理类为<code>org.apache.coyote.ajp.AjpProtocol.AjpConnectionHandler</code>，因此到这里我们基本清楚了Connector的初始化流程，总结如下：
```java Connect init 采用APR的情况
//1 HTTP/1.1协议连接器
org.apache.catalina.connector.Connector#init
&ndash;>org.apache.coyote.http11.Http11AprProtocol#init
&mdash;>org.apache.tomcat.util.net.AprEndpoint#init
(org.apache.coyote.http11.Http11AprProtocol.Http11ConnectionHandler)</p>

<p>// 2 AJP/1.3协议连接器
org.apache.catalina.connector.Connector#init
&ndash;>org.apache.coyote.ajp.AjpAprProtocol#init
&mdash;>org.apache.tomcat.util.net.AprEndpoint#init
(org.apache.coyote.ajp.AjpAprProtocol.AjpConnectionHandler)</p>

<p><code>
</code>java Connector init 不采用APR的情况
// 1 HTTP/1.1协议连接器
org.apache.catalina.connector.Connector#init
&ndash;>org.apache.coyote.http11.Http11Protocol#init
&mdash;>org.apache.tomcat.util.net.JIoEndpoint#init
(org.apache.coyote.http11.Http11Protocol.Http11ConnectionHandler)</p>

<p>// 2 AJP/1.3协议连接器
org.apache.catalina.connector.Connector#init
&ndash;>org.apache.coyote.ajp.AjpProtocol#init
&mdash;>org.apache.tomcat.util.net.JIoEndpoint#init
(org.apache.coyote.ajp.AjpProtocol.AjpConnectionHandler)</p>

<p>```</p>

<blockquote><p>这里需要注意，除了JIoEndpoint外，还有NIoEndpoint，对于Tomcat7.0.24的代码，并没有采用NIOEndPoint，NIOEndpoint采用了NIO的方式进行Socket的处理。</p></blockquote>

<p>最后，咋们再来看看org.apache.tomcat.util.net.JIoEndpoint#init的初始化过程，我们首先来看一下JIoEndpoint的继承关系图如下：
<img class="center" src="/images/2013/10/17/JIoEndpoint.png">
通过上图我们知道JIoEndpoint继承了AbstractEndpoint，而通过查看源码可知，JIoEndpoint没有实现自己的init方法，它默认采用了父类的init方法，那么我们就来看看AbstractEndpoint的init，它的代码如下：
```java org.apache.tomcat.util.net.AbstractEndpoint#init
 public final void init() throws Exception {</p>

<pre><code>    if (bindOnInit) {
        bind();
        bindState = BindState.BOUND_ON_INIT;
    }
</code></pre>

<p>}
<code>
通过查看上面的代码可知，因为bindOnInit默认是true,所以init调用了bind方法，而bind方法是抽象方法，最终由JIoEndpoint来实现，代码如下：
</code>java org.apache.tomcat.util.net.JIoEndpoint#bind
@Override
public void bind() throws Exception {</p>

<pre><code>    // Initialize thread count defaults for acceptor
    if (acceptorThreadCount == 0) {
        acceptorThreadCount = 1;
    }
    // Initialize maxConnections
    if (getMaxConnections() == 0) {
        // User hasn't set a value - use the default
        setMaxConnections(getMaxThreadsExecutor(true));
    }

    if (serverSocketFactory == null) {
        if (isSSLEnabled()) {
            serverSocketFactory =
                handler.getSslImplementation().getServerSocketFactory(this);
        } else {
            serverSocketFactory = new DefaultServerSocketFactory(this);
        }
    }

    if (serverSocket == null) {
        try {
            if (getAddress() == null) {
                serverSocket = serverSocketFactory.createSocket(getPort(),
                        getBacklog());
            } else {
                serverSocket = serverSocketFactory.createSocket(getPort(),
                        getBacklog(), getAddress());
            }
        } catch (BindException orig) {
            String msg;
            if (getAddress() == null)
                msg = orig.getMessage() + " &lt;null&gt;:" + getPort();
            else
                msg = orig.getMessage() + " " +
                        getAddress().toString() + ":" + getPort();
            BindException be = new BindException(msg);
            be.initCause(orig);
            throw be;
        }
    }
</code></pre>

<p>}
<code>``
通过上面代码可以看出，最终是调用了</code>org.apache.tomcat.util.net.ServerSocketFactory#createSocket<code>方法创建一个</code>java.net.ServerSocket`，并绑定在conf/server.xml中Connector中配置的端口。</p>

<p>综上我们可以得出如下结论：</p>

<blockquote><p>Connector#init的时候，无论是AJP还是HTTP最终其实是调用了JioEndpoint的初始化，默认情况在初始化的时候就会创建java.net.ServerSocket绑到到配置的端口上。</p></blockquote>

<h2>Connector#start</h2>

<p>接着我们再来分析一下Connector#start，因为Connector符合LifeCycle模板方法生命周期管理的机制，因此它的start最终会调用startInternal,org.apache.catalina.connector.Connector#startInternal代码如下：
```java org.apache.catalina.connector.Connector#startInternal</p>

<pre><code>protected void startInternal() throws LifecycleException {

    // Validate settings before starting
    if (getPort() &lt; 0) {
        throw new LifecycleException(sm.getString(
                "coyoteConnector.invalidPort", Integer.valueOf(getPort())));
    }

    setState(LifecycleState.STARTING);

    try {
        protocolHandler.start();
    } catch (Exception e) {
        String errPrefix = "";
        if(this.service != null) {
            errPrefix += "service.getName(): \"" + this.service.getName() + "\"; ";
        }

        throw new LifecycleException
            (errPrefix + " " + sm.getString
             ("coyoteConnector.protocolHandlerStartFailed"), e);
    }

    mapperListener.start();
}
</code></pre>

<p>```
通过上面的代码，我们可以清晰的看到最终调用了protocolHandler.start()，而根据Connector#init流程的分析，这里会分是否采用APR，默认是不采用APR的，这里会根据不同的协议（AJP，HTTP）来调用对应的org.apache.coyote.ProtocolHandler#start.
其中AJP会采用org.apache.coyote.ajp.AjpProtocol，HTTP协议采用org.apache.coyote.http11.Http11Protocol,而无论是AjpProtocol还是Http11Protocol都会调用JIoEndpoint的方法，那么接下来我们就来看看JioEndpoint的start方法，它的代码如下：</p>

<p>```java org.apache.tomcat.util.net.JIoEndpoint#startInternal
public void startInternal() throws Exception {</p>

<pre><code>    if (!running) {
        running = true;
        paused = false;

        // Create worker collection
        if (getExecutor() == null) {
            createExecutor();
        }

        initializeConnectionLatch();

        startAcceptorThreads();

        // Start async timeout thread
        Thread timeoutThread = new Thread(new AsyncTimeout(),
                getName() + "-AsyncTimeout");
        timeoutThread.setPriority(threadPriority);
        timeoutThread.setDaemon(true);
        timeoutThread.start();
    }
</code></pre>

<p>}
```
从上面的代码可以看出，启动了Acceptor线程和AsyncTimeout线程，首先来看看Acceptor线程，我们再来看看startAcceptorThreads方法，代码如下：</p>

<p>```java  org.apache.tomcat.util.net.AbstractEndpoint#startAcceptorThreads
protected final void startAcceptorThreads() {</p>

<pre><code>    int count = getAcceptorThreadCount();
    acceptors = new Acceptor[count];

    for (int i = 0; i &lt; count; i++) {
        acceptors[i] = createAcceptor();
        String threadName = getName() + "-Acceptor-" + i;
        acceptors[i].setThreadName(threadName);
        Thread t = new Thread(acceptors[i], threadName);
        t.setPriority(getAcceptorThreadPriority());
        t.setDaemon(getDaemon());
        t.start();
    }
</code></pre>

<p>}
<code>``
通过上面的代码，我们可以看出其实是通过</code>org.apache.tomcat.util.net.AbstractEndpoint.Acceptor<code>这个Runable接口的实现类来启动线程，接下来我们就来看看Acceptor#run方法，通过查看run方法，它里面其实就是调用了</code>java.net.ServerSocket#accept`的方法来接受一个Socket连接。</p>

<p>启动完了Acceptor线程以后，接着就会启动AsyncTimeout线程，而这里面需要注意的时候，无论是Acceptor还是AsyncTimeout线程，它们都是Daemon线程，而设置为Daemon的原因，我们会在下篇<a href="">Tomcat的关闭</a>中进行说明。</p>

<h2>StandardEngine#start</h2>

<p>从本文上面的分析中，我们得知StandardEngine继承了ContainerBase，而StandardEngine的startInternal钩子方法也仅仅是调用了父类ContainerBase的startInternal方法，那接下来我们分析一下ContainerBase的startInternal方法，代码如下：</p>

<p>```java org.apache.catalina.core.ContainerBase#startInternal
protected synchronized void startInternal() throws LifecycleException {</p>

<pre><code>// Start our child containers, if any
Container children[] = findChildren();
List&lt;Future&lt;Void&gt;&gt; results = new ArrayList&lt;Future&lt;Void&gt;&gt;();
for (int i = 0; i &lt; children.length; i++) {
    results.add(startStopExecutor.submit(new StartChild(children[i])));
}

boolean fail = false;
for (Future&lt;Void&gt; result : results) {
    try {
        result.get();
    } catch (Exception e) {
        log.error(sm.getString("containerBase.threadedStartFailed"), e);
        fail = true;
    }

}
if (fail) {
    throw new LifecycleException(
            sm.getString("containerBase.threadedStartFailed"));
}


setState(LifecycleState.STARTING);
</code></pre>

<p>}
```</p>

<p>我们删除了对本文的分析不相关的代码，只留下一些核心的代码，我们可以看到通过startStopExecutor异步的对子容器进行了启动，然后设置状态为<code>STARTING</code>的状态。而startStopExecutor是在容器的initInternal方法中进行初始化好的，接下来我们就来看看StartChild,StardChild的代码如下：
``` java org.apache.catalina.core.ContainerBase.StartChild
private static class StartChild implements Callable<Void> {</p>

<pre><code>    private Container child;

    public StartChild(Container child) {
        this.child = child;
    }

    @Override
    public Void call() throws LifecycleException {
        child.start();
        return null;
    }
</code></pre>

<p>}
```</p>

<p>通过上面的代码，我们可以看到StartChild实现了Callable接口，实现这个接口的类可以将其放到对应的executor中执行（对于executor不熟悉的童鞋可以去看一下相关的文章，本文不做介绍），StartChild在运行的时候就会调用到子容器的start方法，而此时的父容器是StandardEngine，子容器就是StandardHost,接下来我们就来看看StandardHost的启动过程。通过前面对于init流程的分析，我们知道StandardHost不是在StandardEngine#init的时候初始化，因此在执行StandardHost#start的时候，要首先进行init方法的调用，具体的代码如下：
```java org.apache.catalina.util.LifecycleBase#start
public final synchronized void start() throws LifecycleException {</p>

<pre><code>if (state.equals(LifecycleState.NEW)) {
    init(); //因为此时的StandardHost还没有初始化，因此会走到这一步代码
} else if (state.equals(LifecycleState.FAILED)){
    stop();
} else if (!state.equals(LifecycleState.INITIALIZED) &amp;&amp;
        !state.equals(LifecycleState.STOPPED)) {
    invalidTransition(Lifecycle.BEFORE_START_EVENT);
}

setStateInternal(LifecycleState.STARTING_PREP, null, false);

try {
    startInternal();
} catch (Throwable t) {
    ExceptionUtils.handleThrowable(t);
    setStateInternal(LifecycleState.FAILED, null, false);
    throw new LifecycleException(
            sm.getString("lifecycleBase.startFail",toString()), t);
}  
</code></pre>

<p>   setStateInternal(LifecycleState.STARTED, null, false);</p>

<p>}
```
上面省略了部分不相关的代码，在调用中我们可以清楚的看到，对于StandardHost的初始化，是在start的时候进行的。那接下来我们在来看一下StandardHost的init方法，通过查看代码，我们发现StandardHost本身没有实现initInternal的钩子方法，也就意味着最终初始化会调用ContainerBase#initInternal方法，而通过上文的描述，我们已经清楚ContainerBase#initInternal主要是初始化了一个startStopExecutor，这个线程池主要是为了异步的初始化子容器来用的。</p>

<blockquote><p>我们知道StandardEngine初始化的时候，也是初始化了一个线程池，而StandardHost也初始化了一个线程池，他们的不同点在与创建线程的工厂方法不同，在采用缺省配置的情况下，StandardEngine的线程池中的线程是以<code>Catalina-startStop</code>的形式命名的，而StandardHost是以<code>localhost-startStop</code>的方式进行命名的。大家注意区分。</p></blockquote>

<p>StandardHost#start调用init方法初始化完StandardHost以后，会调用钩子的startInternal方法，而startInternal方法又是调用了ContainerBased#startInternal方法，而ContainerBase#startInternal方法最终又会去启动子容器的，对于StandardHost来说，子容器就是StandardContext。
因此分析到这里我们可以得出如下结论：</p>

<blockquote><p>对于StandardEngine，StandardHost的启动，父容器在init的时候创建一个启动和停止子容器的线程池，然后父容器启动的时候首先通过异步的方式将子容器的启动通过<code>org.apache.catalina.core.ContainerBase.StartChild</code>提交到父容器中对应的线程池中进行启动，而子容器启动的时候首先会初始化，然后再启动。</p></blockquote>

<p>另外这里还需要注意一点就是，StandEngine#start的时候，最终调用了ContainerBase#startInternal方法，而ContainerBase#startInternal的最后，调用了threadStart(),我们来看看它的代码如下：
```java org.apache.catalina.core.ContainerBase#threadStart
protected void threadStart() {</p>

<pre><code>    if (thread != null)
        return;
    if (backgroundProcessorDelay &lt;= 0)
        return;

    threadDone = false;
    String threadName = "ContainerBackgroundProcessor[" + toString() + "]";
    thread = new Thread(new ContainerBackgroundProcessor(), threadName);
    thread.setDaemon(true);
    thread.start();
</code></pre>

<p>}
```
上面的代码，首先会判断backgroundProcessorDelay是否小于0，而这个值默认情况下是-1，也就意味这后面的代码不会运行，而对于StandardEngine来说，它将backgroundProcessorDelay的值在构造函数中赋值为了10，这样的话，当StandardEngine启动的时候，就会启动名称为“ContainerBackgroundProcessor[StandardEngine[Catalina]]”的线程。</p>

<p>经过上面的分析，我们已经清楚了StandardEngine启动的过程了，但是我们还有一个地方需要进一步的分析。因为上面的分析我们仅仅只是分析了容器通过conf/server.xml配置文件的配置结构进行的启动，而我们都知道<code>CATALINA-HOME/webapps/</code>中的应用也是需要启动的，那么webapps目录的应用又是如何启动的呢？我们下面来分析一下，通过<a href="/blog/2013/10/16/tomcat-architecture/">Tomcat总体结构</a>的描述，我们已经知道，webapps目录下面的应用其实是属于Context的，而Context对应Tomcat中的StandardContext类，因此我们就知道应该对谁下手了，知道了目标以后，咋们还是采用之前的那种方式，要么debug,要么打印调用栈，这里我们还是通过打印调用栈的方式进行，我们在<code>org.apache.catalina.core.StandardContext#initInternal</code>中增加打印调用栈的方法，具体代码如下：
```java org.apache.catalina.core.StandardContext#initInternal
protected void initInternal() throws LifecycleException {</p>

<pre><code>    super.initInternal();
    Throwable ex = new Throwable();
    StackTraceElement[] stackElements = ex.getStackTrace();
    if (stackElements != null) {
        for (int i = stackElements.length - 1; i &gt;= 0; i--) {
            System.out.print(stackElements[i].getClassName() + "\t");
            System.out.print(stackElements[i].getMethodName() + "\t");
            System.out.print(stackElements[i].getFileName() + "\t");
            System.out.println(stackElements[i].getLineNumber());
        }
    }
    if (processTlds) {
        this.addLifecycleListener(new TldConfig());
    }

    // Register the naming resources
    if (namingResources != null) {
        namingResources.init();
    }

    // Send j2ee.object.created notification 
    if (this.getObjectName() != null) {
        Notification notification = new Notification("j2ee.object.created",
                this.getObjectName(), sequenceNumber.getAndIncrement());
        broadcaster.sendNotification(notification);
    }
</code></pre>

<p>}
<code>
运行代码，可以看到控制台有如下的输出：
</code>java terminal info
java.util.concurrent.ThreadPoolExecutor$Worker  run ThreadPoolExecutor.java 918
java.util.concurrent.ThreadPoolExecutor$Worker  runTask ThreadPoolExecutor.java 895
java.util.concurrent.FutureTask run FutureTask.java 138
java.util.concurrent.FutureTask$Sync    innerRun    FutureTask.java 303
java.util.concurrent.Executors$RunnableAdapter  call    Executors.java  439
org.apache.catalina.startup.HostConfig$DeployDirectory  run HostConfig.java 1671
org.apache.catalina.startup.HostConfig  deployDirectory HostConfig.java 1113
org.apache.catalina.core.StandardHost   addChild    StandardHost.java   622
org.apache.catalina.core.ContainerBase  addChild    ContainerBase.java  877
org.apache.catalina.core.ContainerBase  addChildInternal    ContainerBase.java  901
org.apache.catalina.util.LifecycleBase  start   LifecycleBase.java  139
org.apache.catalina.util.LifecycleBase  init    LifecycleBase.java  102
org.apache.catalina.core.StandardContext    initInternal    StandardContext.java    6449
```</p>

<p>通过查看控制台的输出，我们可以看到有一个<code>org.apache.catalina.startup.HostConfig$DeployDirectory</code>类，于是乎找到这个类去看看呗。打开一看它是一个Runable接口的实现类，因此我们推断它也是放到某个线程池中进行异步运行的，最终通过IntellIJ IDEA提供的类调用栈分析工具（ctrl+alt+h）得到DeployDirectory构造器方法的调用栈如下图所示：
<img class="center" src="/images/2013/10/17/DeployDirectory-call-stack.png">
通过上图我们可以清楚的看到，最终的调用方是<code>org.apache.catalina.startup.HostConfig#lifecycleEvent</code>,到这里我们就知道了Context的启动是通过某个组件的生命周期事件的监听器来启动的，而HostConfig到底是谁的监听器呢？通过名称我们应该可以猜测出它是StandardHost的监听器,那么它到底监听哪个事件呢？我们查看下org.apache.catalina.startup.HostConfig#lifecycleEvent的代码如下：
```java org.apache.catalina.startup.HostConfig#lifecycleEvent
public void lifecycleEvent(LifecycleEvent event) {</p>

<pre><code>    // Identify the host we are associated with
    try {
        host = (Host) event.getLifecycle();
        if (host instanceof StandardHost) {
            setCopyXML(((StandardHost) host).isCopyXML());
            setDeployXML(((StandardHost) host).isDeployXML());
            setUnpackWARs(((StandardHost) host).isUnpackWARs());
        }
    } catch (ClassCastException e) {
        log.error(sm.getString("hostConfig.cce", event.getLifecycle()), e);
        return;
    }

    // Process the event that has occurred
    if (event.getType().equals(Lifecycle.PERIODIC_EVENT)) {
        check();
    } else if (event.getType().equals(Lifecycle.START_EVENT)) {
        start();
    } else if (event.getType().equals(Lifecycle.STOP_EVENT)) {
        stop();
    }
</code></pre>

<p>}
```</p>

<p>通过上面的代码，我们可以看出监听的事件是<code>Lifecycle.START_EVENT</code>,而通过查看<code>org.apache.catalina.LifecycleState</code>的代码<code>STARTING(true,Lifecycle.START_EVENT)</code>就可以得知，此时生命周期状态应该是STARTING,到这里我们应该已经猜到了，HostConfig是在StandardHost#start的时候通过监听器调用，为了验证我们的猜测，我们debug一下代码，我们可以在HostConfig#start方法中打个断点，运行以后得到如下内存结构：
<img class="center" src="/images/2013/10/17/HostConfig.png">
通过上图也就验证了我们刚才的猜测。</p>

<p>通过上面的分析我们清楚了webapps目录中context的启动，总结如下：</p>

<blockquote><p>webapps目录中应用的启动在StandardHost#start的时候，通过<code>Lifecycle.START_EVENT</code>这个事件的监听器HostConfig进行进一步的启动。</p></blockquote>

<p>综合上面的文章所述,最后我们再来一下总结，我们知道Java程序启动以后，最终会以进程的形式存在，而Java进程中又会有很多条线程存在，因此最后我们就来看看Tomcat启动以后，到底启动了哪些线程，通过这些我们可以反过来验证我们对源代码的理解是否正确。接下来我们启动Tomcat，然后运行<code>jstack -l &lt;pid&gt;</code>来看看，在笔者的机器上面，jstack的输入如下所示：
```java Tomcat threads
Full thread dump Java HotSpot&trade; 64-Bit Server VM (20.51-b01-457 mixed mode):</p>

<p>&ldquo;ajp-bio-8009-AsyncTimeout&rdquo; daemon prio=5 tid=7f8738afe000 nid=0x115ad6000 waiting on condition [115ad5000]
   java.lang.Thread.State: TIMED_WAITING (sleeping)</p>

<pre><code>    at java.lang.Thread.sleep(Native Method)
    at org.apache.tomcat.util.net.JIoEndpoint$AsyncTimeout.run(JIoEndpoint.java:148)
    at java.lang.Thread.run(Thread.java:680)
</code></pre>

<p>   Locked ownable synchronizers:</p>

<pre><code>    - None
</code></pre>

<p>&ldquo;ajp-bio-8009-Acceptor-0&rdquo; daemon prio=5 tid=7f8738b05800 nid=0x1159d3000 runnable [1159d2000]
   java.lang.Thread.State: RUNNABLE</p>

<pre><code>    at java.net.PlainSocketImpl.socketAccept(Native Method)
    at java.net.PlainSocketImpl.accept(PlainSocketImpl.java:439)
    - locked &lt;7f46a8710&gt; (a java.net.SocksSocketImpl)
    at java.net.ServerSocket.implAccept(ServerSocket.java:468)
    at java.net.ServerSocket.accept(ServerSocket.java:436)
    at org.apache.tomcat.util.net.DefaultServerSocketFactory.acceptSocket(DefaultServerSocketFactory.java:60)
    at org.apache.tomcat.util.net.JIoEndpoint$Acceptor.run(JIoEndpoint.java:216)
    at java.lang.Thread.run(Thread.java:680)
</code></pre>

<p>   Locked ownable synchronizers:</p>

<pre><code>    - None
</code></pre>

<p>&ldquo;http-bio-8080-AsyncTimeout&rdquo; daemon prio=5 tid=7f8735acb800 nid=0x1158d0000 waiting on condition [1158cf000]
   java.lang.Thread.State: TIMED_WAITING (sleeping)</p>

<pre><code>    at java.lang.Thread.sleep(Native Method)
    at org.apache.tomcat.util.net.JIoEndpoint$AsyncTimeout.run(JIoEndpoint.java:148)
    at java.lang.Thread.run(Thread.java:680)
</code></pre>

<p>   Locked ownable synchronizers:</p>

<pre><code>    - None
</code></pre>

<p>&ldquo;http-bio-8080-Acceptor-0&rdquo; daemon prio=5 tid=7f8735acd000 nid=0x1157cd000 runnable [1157cc000]
   java.lang.Thread.State: RUNNABLE</p>

<pre><code>    at java.net.PlainSocketImpl.socketAccept(Native Method)
    at java.net.PlainSocketImpl.accept(PlainSocketImpl.java:439)
    - locked &lt;7f46a8690&gt; (a java.net.SocksSocketImpl)
    at java.net.ServerSocket.implAccept(ServerSocket.java:468)
    at java.net.ServerSocket.accept(ServerSocket.java:436)
    at org.apache.tomcat.util.net.DefaultServerSocketFactory.acceptSocket(DefaultServerSocketFactory.java:60)
    at org.apache.tomcat.util.net.JIoEndpoint$Acceptor.run(JIoEndpoint.java:216)
    at java.lang.Thread.run(Thread.java:680)
</code></pre>

<p>   Locked ownable synchronizers:</p>

<pre><code>    - None
</code></pre>

<p>&ldquo;ContainerBackgroundProcessor[StandardEngine[Catalina]]&rdquo; daemon prio=5 tid=7f8732850800 nid=0x111203000 waiting on condition [111202000]
   java.lang.Thread.State: TIMED_WAITING (sleeping)</p>

<pre><code>    at java.lang.Thread.sleep(Native Method)
    at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.run(ContainerBase.java:1508)
    at java.lang.Thread.run(Thread.java:680)
</code></pre>

<p>   Locked ownable synchronizers:</p>

<pre><code>    - None
</code></pre>

<p>&ldquo;main&rdquo; prio=5 tid=7f8735000800 nid=0x10843e000 runnable [10843c000]
   java.lang.Thread.State: RUNNABLE</p>

<pre><code>    at java.net.PlainSocketImpl.socketAccept(Native Method)
    at java.net.PlainSocketImpl.accept(PlainSocketImpl.java:439)
    - locked &lt;7f32ea7c8&gt; (a java.net.SocksSocketImpl)
    at java.net.ServerSocket.implAccept(ServerSocket.java:468)
    at java.net.ServerSocket.accept(ServerSocket.java:436)
    at org.apache.catalina.core.StandardServer.await(StandardServer.java:452)
    at org.apache.catalina.startup.Catalina.await(Catalina.java:779)
    at org.apache.catalina.startup.Catalina.start(Catalina.java:725)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
    at java.lang.reflect.Method.invoke(Method.java:597)
    at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:322)
    at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:456)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
    at java.lang.reflect.Method.invoke(Method.java:597)
    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:120)
</code></pre>

<p>```</p>

<p>上面的截图我已经取消了JVM自己本生的线程，从上图中我们可以清楚的看到，有6条线程，其中<code>ajp-bio-8009-AsyncTimeout</code>和<code>ajp-bio-8009-Acceptor-0</code>是在Ajp的Connector启动的时候启动的，<code>http-bio-8080-AsyncTimeout</code>和<code>http-bio-8080-Acceptor-0</code>是http的Connector启动的时候启动的，<code>ContainerBackgroundProcessor[StandardEngine[Catalina]]</code>是在StandardEngine启动的时候启动的，而main线程就是我们的主线程。这里还需要注意一点就是除了Main线程以外，其它的线程都是Dameon线程，相关的内容在下篇<a href="">Tomcat的关闭</a>我们再来详细说明。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tomcat总体结构（Tomcat源代码阅读系列之二）]]></title>
    <link href="http://imtiger.github.io/blog/2013/10/16/tomcat-architecture/"/>
    <updated>2013-10-16T14:33:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2013/10/16/tomcat-architecture</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/10/14/apache_tomcat_bag.jpg">
本文是<a href="/blog/2013/10/08/tomcat-source-code-study/">Tomcat源代码阅读系列</a>的第二篇文章，我们在本系列的第一篇文章：<a href="/blog/2013/10/14/run-tomcat-in-idea-or-eclipse/">在IntelliJ IDEA 和 Eclipse运行tomcat 7源代码</a>一文中介绍了如何在intelliJ IDEA 和 Eclipse中运行Tomcat源代码，本文介绍一下Tomcat的总体结构。</p>

<blockquote><p>本文没有特别指明的地方，源代码都是针对tomcat7.0.42来说。</p></blockquote>

<h1>Tomcat的总体结构</h1>

<p>Tomcat即是一个Http服务器也是一个Servlet容器，它的总体结构我们可以用下图来描述：</p>

<!-- more -->


<p><img class="center" src="/images/2013/10/16/TomcatArchitecture.png">
通过上图我们可以看出Tomcat中主要涉及Server,Service,Engine,Connector,Host,Context组件，之前用过Tomcat的童鞋是不是觉得这些组件的名称有点似曾相识的赶脚，没赶脚？！您再想想。好吧，不用你想了，我来告诉你吧。其实在Tomcat二进制分发包解压后,在conf目录中有一个server.xml文件，你打开它瞄两眼看看，是不是发现server.xml文件中已经包含了上述的几个名称。我拿我本地Tomcat7.0.42分发包中的server.xml来具体分析一下，它的内容如下：
```xml conf/server.xml(Tomcat 7.0.42)
&lt;?xml version=&lsquo;1.0&rsquo; encoding=&lsquo;utf-8&rsquo;?></p>

<!--
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->


<!-- Note:  A "Server" is not itself a "Container", so you may not
     define subcomponents such as "Valves" at this level.
     Documentation at /docs/config/server.html
 -->


<p><Server port="8005" shutdown="SHUTDOWN">
  <!-- Security listener. Documentation at /docs/config/listeners.html
  <Listener className="org.apache.catalina.security.SecurityListener" />
  &mdash;>
  <!--APR library loader. Documentation at /docs/apr.html -->
  <Listener className="org.apache.catalina.core.AprLifecycleListener" SSLEngine="on" />
  <!--Initialize Jasper prior to webapps are loaded. Documentation at /docs/jasper-howto.html -->
  <Listener className="org.apache.catalina.core.JasperListener" />
  <!-- Prevent memory leaks due to use of particular java/javax APIs-->
  <Listener className="org.apache.catalina.core.JreMemoryLeakPreventionListener" />
  <Listener className="org.apache.catalina.mbeans.GlobalResourcesLifecycleListener" />
  <Listener className="org.apache.catalina.core.ThreadLocalLeakPreventionListener" /></p>

<p>  &lt;!&mdash; Global JNDI resources</p>

<pre><code>   Documentation at /docs/jndi-resources-howto.html
</code></pre>

<p>  &mdash;>
  <GlobalNamingResources></p>

<pre><code>&lt;!-- Editable user database that can also be used by
     UserDatabaseRealm to authenticate users
--&gt;
&lt;Resource name="UserDatabase" auth="Container"
          type="org.apache.catalina.UserDatabase"
          description="User database that can be updated and saved"
          factory="org.apache.catalina.users.MemoryUserDatabaseFactory"
          pathname="conf/tomcat-users.xml" /&gt;
</code></pre>

<p>  </GlobalNamingResources></p>

<p>  &lt;!&mdash; A &ldquo;Service&rdquo; is a collection of one or more &ldquo;Connectors&rdquo; that share</p>

<pre><code>   a single "Container" Note:  A "Service" is not itself a "Container",
   so you may not define subcomponents such as "Valves" at this level.
   Documentation at /docs/config/service.html
</code></pre>

<p>   &mdash;>
  <Service name="Catalina"></p>

<pre><code>&lt;!--The connectors can use a shared executor, you can define one or more named thread pools--&gt;
&lt;!--
&lt;Executor name="tomcatThreadPool" namePrefix="catalina-exec-"
    maxThreads="150" minSpareThreads="4"/&gt;
--&gt;


&lt;!-- A "Connector" represents an endpoint by which requests are received
     and responses are returned. Documentation at :
     Java HTTP Connector: /docs/config/http.html (blocking &amp; non-blocking)
     Java AJP  Connector: /docs/config/ajp.html
     APR (HTTP/AJP) Connector: /docs/apr.html
     Define a non-SSL HTTP/1.1 Connector on port 8080
--&gt;
&lt;Connector port="8080" protocol="HTTP/1.1"
           connectionTimeout="20000"
           redirectPort="8443" /&gt;
&lt;!-- A "Connector" using the shared thread pool--&gt;
&lt;!--
&lt;Connector executor="tomcatThreadPool"
           port="8080" protocol="HTTP/1.1"
           connectionTimeout="20000"
           redirectPort="8443" /&gt;
--&gt;
&lt;!-- Define a SSL HTTP/1.1 Connector on port 8443
     This connector uses the JSSE configuration, when using APR, the
     connector should be using the OpenSSL style configuration
     described in the APR documentation --&gt;
&lt;!--
&lt;Connector port="8443" protocol="HTTP/1.1" SSLEnabled="true"
           maxThreads="150" scheme="https" secure="true"
           clientAuth="false" sslProtocol="TLS" /&gt;
--&gt;

&lt;!-- Define an AJP 1.3 Connector on port 8009 --&gt;
&lt;Connector port="8009" protocol="AJP/1.3" redirectPort="8443" /&gt;


&lt;!-- An Engine represents the entry point (within Catalina) that processes
     every request.  The Engine implementation for Tomcat stand alone
     analyzes the HTTP headers included with the request, and passes them
     on to the appropriate Host (virtual host).
     Documentation at /docs/config/engine.html --&gt;

&lt;!-- You should set jvmRoute to support load-balancing via AJP ie :
&lt;Engine name="Catalina" defaultHost="localhost" jvmRoute="jvm1"&gt;
--&gt;
&lt;Engine name="Catalina" defaultHost="localhost"&gt;

  &lt;!--For clustering, please take a look at documentation at:
      /docs/cluster-howto.html  (simple how to)
      /docs/config/cluster.html (reference documentation) --&gt;
  &lt;!--
  &lt;Cluster className="org.apache.catalina.ha.tcp.SimpleTcpCluster"/&gt;
  --&gt;

  &lt;!-- Use the LockOutRealm to prevent attempts to guess user passwords
       via a brute-force attack --&gt;
  &lt;Realm className="org.apache.catalina.realm.LockOutRealm"&gt;
    &lt;!-- This Realm uses the UserDatabase configured in the global JNDI
         resources under the key "UserDatabase".  Any edits
         that are performed against this UserDatabase are immediately
         available for use by the Realm.  --&gt;
    &lt;Realm className="org.apache.catalina.realm.UserDatabaseRealm"
           resourceName="UserDatabase"/&gt;
  &lt;/Realm&gt;

  &lt;Host name="localhost"  appBase="webapps"
        unpackWARs="true" autoDeploy="true"&gt;

    &lt;!-- SingleSignOn valve, share authentication between web applications
         Documentation at: /docs/config/valve.html --&gt;
    &lt;!--
    &lt;Valve className="org.apache.catalina.authenticator.SingleSignOn" /&gt;
    --&gt;

    &lt;!-- Access log processes all example.
         Documentation at: /docs/config/valve.html
         Note: The pattern used is equivalent to using pattern="common" --&gt;
    &lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"
           prefix="localhost_access_log." suffix=".txt"
           pattern="%h %l %u %t &amp;quot;%r&amp;quot; %s %b" /&gt;

  &lt;/Host&gt;
&lt;/Engine&gt;
</code></pre>

<p>  </Service>
</Server></p>

<p>```
接下来我们就根据上图以及conf/server.xml的内容来一步步描述一下上面所说的各种组件吧。</p>

<h2>Server</h2>

<p>首先闪联登场的是咋们的Server大哥（大家能给点掌声吗？），Server是Tomcat中最顶层的组件，它可以包含多个Service组件。在Tomcat源代码中Server组件对应源码中的<code>org.apache.catalina.core.StandardServer</code>类。StandardServer的继承关系图如下图所示：
<img class="center" src="/images/2013/10/16/StandardServer.jpg"></p>

<h2>Service</h2>

<p>接下来咋们来看看Service组件，Service组件相当于Connetor和Engine组件的包装器，它将一个或者多个Connector组件和一个Engine建立关联。缺省的的配置文件中，定义一个叫<code>Catalina</code>的服务，并将Http,AJP这两个Connector关联到了一个名为<code>Catalina</code>的Engine.Service组件对应Tomcat源代码中的<code>org.apache.catalina.core.StandardService</code>,StandardService的继承关系图如下图所示：
<img class="center" src="/images/2013/10/16/StandardService.png"></p>

<h2>Connector</h2>

<p>既然Tomcat需要提供http服务，而我们知道http应用层协议最终都是需要通过TCP层的协议进行包传递的，而Connector正是Tomcat中监听TCP网络连接的组件，一个Connector会监听一个独立的端口来处理来自客户端的连接。缺省的情况下Tomcat提供了如下两个Connector。我们分别描述一下：</p>

<ol>
<li>HTTP/1.1<br/>
<code>&lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt;</code>
上面定义了一个Connector，它缺省监听端口8080,这个端口我们可以根据具体情况进行改动。<code>connectionTimeout</code>定义了连接超时时间，单位是毫秒，<code>redirectPort</code>定义了ssl的重定向接口，根据缺省的配置，Connector会将ssl请求重定向到8443端口。</li>
<li>AJP/1.3<br/>
AJP表示<code>Apache Jserv Protocol</code>,此连接器将处理Tomcat和Aapache http服务器之间的交互，这个连机器是用来处理我们将Tomcat和Apache http服务器结合使用的情况。假如在同样的一台物理Server上面部署了一台Apache http服务器和多台Tomcat服务器，通过Apache服务器来处理静态资源以及负载均衡的时候，针对不同的Tomcat实例需要AJP监听不同的端口。</li>
</ol>


<p>Connector对应源代码中的<code>org.apache.catalina.connector.Connector</code>,它的继承关系图如下所示：
<img class="center" src="/images/2013/10/16/Connector.png"></p>

<h2>Engine</h2>

<p>Tomcat中有一个容器的概念，而Engine,Host,Context都属于Contanier，我们先来说说最顶层的容器Engine.<br/>
一个Engine可以包含一个或者多个Host,也就是说我们一个Tomcat的实例可以配置多个虚拟主机。<br/>
缺省的情况下<code>&lt;Engine name="Catalina" defaultHost="localhost"&gt;</code>定义了一个名称为Cataline的Engine.Engine对应源代码中的<code>org.apache.catalina.core.StandardEngine</code>，它的继承关系图如下图所示：
<img class="center" src="/images/2013/10/16/StandardEngine.png"></p>

<h2>Host</h2>

<p>Host定义了一个虚拟主机，一个虚拟主机可以有多个Context，缺省的配置如下：<br/>
<code>&lt;Host name="localhost"  appBase="webapps" unpackWARs="true" autoDeploy="true"&gt;….&lt;/Host&gt;</code> 其中<code>appBase</code>为webapps，也就是<code>&lt;CATALINA_HOME&gt;\webapps</code>目录，<code>unpackingWARS</code>属性指定在appBase指定的目录中的war包都自动的解压，缺省配置为true,<code>autoDeploy</code>属性指定是否对加入到appBase目录的war包进行自动的部署，缺省为true.<br/>
Host对应源代码中的<code>org.apache.catalina.core.StandardHost</code>,它的继承关系图如下所示：
<img class="center" src="/images/2013/10/16/StandardHost.png"></p>

<h2>Context</h2>

<p>在Tomcat中，每一个运行的webapp其实最终都是以Context的形成存在，每个Context都有一个根路径和请求URL路径，Context对应源代码中的<code>org.apache.catalina.core.StandardContext</code>,它的继承关系图如下图所示：
<img class="center" src="/images/2013/10/16/StandardContext.png">
在Tomcat中我们通常采用如下的两种方式创建一个Context.下面分别描述一下：</p>

<ol>
<li>在<code>&lt;CATALINA-HOME&gt;\webapps</code>目录中创建一个目录，这个时候将自动创建一个context，默认context的访问url为<code>http://host:port/dirname</code>,你也可以通过在<code>ContextRoot\META-INF</code>中创建一个context.xml的文件，其中包含如下的内容来指定应用的访问路径。
<code>&lt;Context path="/yourUrlPath" /&gt;</code></li>
<li>conf\server.xml文件中增加context元素。
第二种创建context的方法，我们可以选择在server.xml文件的<code>&lt;Host&gt;</code>元素，比如我们在server.xml文件中增加如下内容：
<code>xml server.xml
     ......
     ......
     &lt;Context path="/mypath" docBase="/Users/tiger/develop/xxx" reloadable="true"&gt;
     &lt;/Context&gt;
   &lt;/Host&gt;
 &lt;/Engine&gt;
&lt;/Service&gt;
&lt;/Server&gt;
</code>
这样的话，我们就可以通过<code>http://host:port/mypath</code>访问上面配置的context了。</li>
</ol>


<h2>Valve</h2>

<p>Valve中文意思是阀门，Valve是Tomcat中责任链模式的实现，通过链接多个Valve对请求进行处理。其中Valve可以定义在任何的Container中，上面说的Engine,Host,Context都属于容器。tomcat 默认定义了一个名为<code>org.apache.catalina.valves.AccessLogValve</code>的Valve,这个Valve负责拦截每个请求，然后记录一条访问日志。</p>

<p>通过上面的分析，我们发现Server,Service,Engine,Host,Context都实现了<code>org.apache.catalina.Lifecycle</code>接口，通过这个接口管理了这些核心组件的生命周期，关于这些组件的生命周期，我们在下一篇文章描述。</p>

<p>下篇：<br/>
<a href="/blog/2013/10/17/tomcat-start-process/">Tomcat启动过程（Tomcat源代码阅读系列之三）</a></p>
]]></content>
  </entry>
  
</feed>
