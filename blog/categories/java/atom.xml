<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | I'm Tiger,一个有理想爱折腾的程序员!]]></title>
  <link href="http://imtiger.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://imtiger.github.io/"/>
  <updated>2013-11-09T12:22:34+08:00</updated>
  <id>http://imtiger.github.io/</id>
  <author>
    <name><![CDATA[imtiger]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Tomcat 设计模式总结(Tomcat源代码阅读系列之八)]]></title>
    <link href="http://imtiger.github.io/blog/2013/11/08/tomcat-design-pattern/"/>
    <updated>2013-11-08T10:38:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2013/11/08/tomcat-design-pattern</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/10/14/apache_tomcat_bag.jpg">
本文是<a href="/blog/2013/10/08/tomcat-source-code-study/">Tomcat源代码阅读系列</a>的第八篇文章，本系列前七篇文章如下：<br/>
<a href="/blog/2013/10/14/run-tomcat-in-idea-or-eclipse/">在IntelliJ IDEA 和 Eclipse运行tomcat 7源代码（Tomcat源代码阅读系列之一）</a>     <br/>
<a href="/blog/2013/10/16/tomcat-architecture/">Tomcat总体结构                             （Tomcat源代码阅读系列之二）</a>    <br/>
<a href="/blog/2013/10/17/tomcat-start-process/">Tomcat启动过程（Tomcat源代码阅读系列之三）</a> <br/>
<a href="/blog/2013/10/21/tomcat-shutdown/">Tomcat关闭过程（Tomcat源代码阅读系列之四）</a><br/>
<a href="/blog/2013/10/24/tomcat-request-process/">Tomcat请求处理流程（Tomcat源代码阅读系列之五）</a><br/>
<a href="/blog/2013/10/28/tomcat-class-loader/">Tomcat类加载器机制（Tomcat源代码阅读系列之六）</a> <br/>
<a href="/blog/2013/11/05/tomcat-session-manage/">Tomcat Session管理机制（Tomcat源代码阅读系列之七）</a></p>

<p>本篇我们将来分析一下Tomcat中所涉及到设计模式，本文我们将主要来分析<code>外观模式</code>，<code>观察者模式</code>，<code>责任链模式</code>，<code>模板方法模式</code>,<code>命令模式</code>。  <br/>
在开始本文之前，笔者先说明一下对于设计模式的一点看法。笔者曾经经常看到网上有人讨论设计模式，也偶尔会遇到有人非要严格按照GOF设计模式的类图以及其中的角色去套用别人的设计，只要类图不一样，或者角色多了或者少了就会觉得怎么和官方定义的模式不一样，其实这都是对设计模式的误解。设计模式其实不仅仅存在软件行业，各行各业其实都有模式，它是所在行业对一些通用问题解决方案的总结和抽象，是一种对常见问题的抽象的解决方案，不是一种具体的实现，所以我们在讨论设计模式的时候，千万别一个劲的套用GOF设计模式中的类图以及其中所涉及到的角色，而是要理解设计模式的思维，理解设计模式的使用场景，只有理解了设计模式中所蕴含的思维以及具体的使用场景以后，你才算是真正的掌握了它。ok,小扯了一下淡，接下来我们进入主题吧。</p>

<!-- more -->


<h1>外观模式</h1>

<h2>定义</h2>

<p>外观模式封装了子系统的具体实现，提供统一的外观类给外部系统，这样当子系统内部实现发生变化的时候，不会影响到外部系统。</p>

<h2>外观模式在Tomcat的应用</h2>

<p>在Tomcat中对于Request,Response,StandardSession,ApplicationContext,StandardWrapper都采用了外观模式，它的类图如下：
<img class="center" src="/images/2013/11/08/tomcat-facade.png"></p>

<p>通过上图，我们可以看到RequestFacade包装了Request，它们都实现了HttpServletRequest，当传递Request对象给应用的时候，其实是返回了RequestFacade对象，而RequestFacade内部可以根据是否自定义了安全管理器来进行相应的操作。</p>

<p>对于Response,StandardSession等处理是类似的，这里就不赘述了。</p>

<h1>观察者模式</h1>

<h2>定义</h2>

<p>观察者模式是一种非常常用的模式，比如大家熟悉的发布-订阅模式，客户端应用中的事件监听器，以及通知等其实都属于观察者模式。观察者模式主要是在当系统中发生某个状态变更或者事件的时候，有另外一些组件或者对象对此次变化有兴趣，这个时候那些对变化感兴趣的对象就可以做为观察者对象来监听变化，而被观察对象要负责发生变化的时候触发通知操作。</p>

<h2>观察者模式在Tomcat的应用</h2>

<p>Tomcat中需要对很多组件进行生命周期管理，为此Tomcat抽象了统一的生命周期管理骨架，通过这个骨架将所有需要进行生命周期管理的类都纳入进来管理，而这里的骨架的类图如下：
<img class="center" src="/images/2013/11/08/tomcat-observer.png"></p>

<p>通过上图我们可以看出Tomcat抽象了一个LifecycleSupport的类，而所有需要生命周期管理的组件通过LifecycleSupport类通知对某个生命周期事件感兴趣的观察者，而所有的观察者都需要实现LifecycleListener。<br/>
另外我们需要关注一下EventObject对象，它里面定义了一个事件源对象，所谓事件源就是事件发生的地方，而在Tomcat的设计中，事件源就是实现了LifeCycle接口的各个需要管理生命周期的组件，这里LifecycleSupport和LifeCycleBase之间是双向的关联，LifeCycleSupport关联LifeCycle对象就是为了实现事件源的传递，这样在LifeCycleSupport触发事件的时候，可以通过事件源构建EventObject.这样以来LifecycleListener就可以通过事件对象获取到事件源，从而做一些与事件源相关的操作。</p>

<h1>责任链模式</h1>

<h2>定义</h2>

<p>通过名称我们应该就能知道责任链模式是解决啥问题的？当我们系统在处理某个请求的时候，请求需要经过很多个节点进行处理，每个节点只关注自己的应该做的工作，做完自己的工作以后，将工作转给下一个节点进行处理，直到所有节点都处理完毕。责任链模式在日常生活中例子挺多，比如快递，当你发一个从深圳到北京的快递的时候，你的包裹会从一个分拨中心传递到下一个分拨中心，直到目的地，这里面每个分拨中心都是链路上的一个节点，它做完自己的工作，然后将工作传递到下一个节点，还比如路由器中传递某个数据包其实也是同样的思路。</p>

<h2>责任链模式在Tomcat的应用</h2>

<p>Tomcat中请求的处理流程其实就是采用了责任链模式，关于Tomcat请求处理，大家可以参考下<a href="/blog/2013/10/24/tomcat-request-process/">Tomcat请求处理流程（Tomcat源代码阅读系列之五）</a>,Tomcat中责任链模式的实现的类图如下图所示：
<img class="center" src="/images/2013/11/08/tomcat-chain-of-responsiblity.png"></p>

<p>从上图中，我们可以看到每一个容器都会有一个Pipeline，而一个Pipeline又会具有多个Valve阀门，其中StandardEngine对应的阀门是StandardEngineValve，StandardHost对应的阀门是StandardHostValve，StandardContext对应的阀门是StandardContextValve，StandardWrapper对应的阀门是StandardWrapperValve。这里每一Pipeline就好比一个管道，而每一Valve就相当于一个阀门，一个管道可以有多个阀门，而对于阀门来说有两种，一种阀门在处理完自己的事情以后，只需要将工作委托给下一个和自己在同一管道的阀门即可，第二种阀门是负责衔接各个管道的，它负责将请求传递给下个管道的第一个阀门处理，而这种阀门叫Basic阀门，它是每个管道中最后一个阀门，上面的Standard*Valve都属于第二种阀门。我们可以形象的通过下图来描述上面的过程:
<img class="center" src="/images/2013/11/08/tomcat-pipeline.png"></p>

<p>通过上图，我们可以很清楚的了解到Tomcat的请求处理流程。当用户请求服务器的时候，Connector会接受请求，从Socket连接中根据http协议解析出对应的数据，构造Request和Response对象，然后传递给后面的容器处理，顶层容器是StandardEngine，StandardEngine处理请求其实是通过容器的Pipeline进行的，而Pipeline其实最终是通过管道上的各个阀门进行的，当请求到达StandardEngineValve的时候，此阀门会将请求转发给对应StandardHost的Pipeline的第一个阀门处理，然后以此最终到达StandardHostValve阀门，它又会将请求转发给StandardContext的Pipeline的第一个阀门，这样以此类推，最后到达StandardWrapperValve，此阀门会根据Request来构建对应的Servelt，并将请求转发给对应的HttpServlet处理。从这里我们可以看出其实Tomcat核心处理流程就是通过责任链一步步的组装起来的。</p>

<h1>模板方法模式</h1>

<h2>定义</h2>

<p>模板方法模式抽象出某个业务操作公共的流程，将流程分为几个步骤，其中有一些步骤是固定不变的，有一些步骤是变化的，固定不变的步骤通过一个基类来实现，而变化的部分通过钩子方法让子类去实现，这样就实现了对系统中流程的统一化规范化管理。在日常生活中其实也有类似的例子，比如我们知道的连锁加盟店，他们都是有固定的加盟流程，只不过每一家店开的时候，店的选址，装修等不同的而已，但是总体的加盟流程已经是确定的。</p>

<h2>模板方法模式在Tomcat的应用</h2>

<p>Tomcat中关于生命周期管理的地方很好应用了模板方法模式，在一个组件的生命周期中都会涉及到init(初始化)，start（启动），stop(停止)，destory（销毁），而对于每一个生命周期阶段其实都有固定一些事情要做，比如判断前置状态，设置后置状态，以及通知状态变更事件的监听者等，而这些工作其实是可以固化的，所以Tomcat中就将每个生命周期阶段公共的部分固化，然后通过initInternal,startInternal,stopInternal,destoryInternal这几个钩子方法开放给子类去实现具体的逻辑。Tomcat中关于模板方法模式的实现如下图所示：
<img class="center" src="/images/2013/10/17/LifeCycleBase.png"></p>

<h1>命令模式</h1>

<h2>定义</h2>

<p>命令模式将请求封装为一个命令，将命令发送者和命令接受者解耦，并且所有命令对客户端来说都有统一的调用接口，使用命令模式还可以支持命令的撤销操作，在很多GUI程序中大量使用了此模式。<br/>
接下来我们来说一个场景大家感受下，我们有时候可能会遇到接口方法参数过多的问题，这样的接口不仅看起来丑陋而且不方便阅读，对客户端不友好。遇到这种情况我们可能选择将各种参数打包为一个参数对象，接口只需要一个参数对象即可，但是在具体的接口实现中，我们又要做条件判断根据参数值的不同做出不同的响应操作，这个时候其实就可以考虑将不同的逻辑实现和各种参数通过命令打包，然后提供一个命令工厂，客户端通过工厂生产出命令，然后直接调用即可。<br/>
其实在日常生活中，命令模式也很常见，比如公司老大给你分配了个任务，让你去做，他可能不关心你具体怎么做的，你做完了以后告诉他结果即可。</p>

<h2>命令模式在Tomcat的应用</h2>

<p>命令模式在Tomcat中主要是应用在对请求的处理过程中，Tomcat的实现中，根据它支持两种协议AJP和Http,而在具体的IO实现中，又分为Java同步阻赛IO,Java同步非祖塞IO，以及采用APR<a href="http://tomcat.apache.org/tomcat-7.0-doc/apr.html">Apache Portable Runtime </a>支持库,因此Tomcat统一了<code>org.apache.coyote.Processor</code>接口，根据协议和IO实现的不同通过不同的Process子类去实现，Connector作为客户端每次只需要根据具体的协议和IO实现创建对应的Process执行即可。下面我们来看一下命令模式在Tomcat中实现的相关类图:
<img class="center" src="/images/2013/11/08/tomcat-command-pattern.png"></p>

<p>通过上图我们可以清楚的看到，Tomcat首先根据协议的不同将Processor分为了Ajp和Http两组，然后又根据具体的IO实现方式的不同，将每一组都会实现同步祖塞IO,同步非祖塞IO，以及APR的Processor。
接下来我们再来看一个类图，我们就可以更加清楚的看到Tomcat中是如何利用命令模式来根据不同的协议以及IO实现方式来处理请求的。我们来看一下Tomcat中关于ProtocolHandler的类图。
<img class="center" src="/images/2013/11/08/tomcat-protocol.png"></p>

<p>通过上图我们可以看到针对每一种协议和IO实现方式的组合，都会有相应的协议处理类，而每个协议处理类都会有一个Handler，而每一个Handler在运行的时候就会创建出对应的Processor，比如AjpProtocol.AjpConnectionHandler创建AjpProcessor处理器，其它的类似。</p>

<p>通过上面的描述，我们可以看出Tomcat接受请求的处理流程如下：<br/>
Connector通过对应的Endpint监听Socket连接，当对应的端口有连接进来的时候，对应的Endpoint就会通过对应的Handler类处理，而Handler处理的时候，又会创建对应的Processor处理,而对应的Processor命令对象会解析Socket流的数据，然后生成Request和Response对象，最终通过上面说的责任链模式一步步的通过各个容器。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tomcat Session管理机制（Tomcat源代码阅读系列之七）]]></title>
    <link href="http://imtiger.github.io/blog/2013/11/05/tomcat-session-manage/"/>
    <updated>2013-11-05T15:39:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2013/11/05/tomcat-session-manage</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/10/14/apache_tomcat_bag.jpg">
本文是<a href="/blog/2013/10/08/tomcat-source-code-study/">Tomcat源代码阅读系列</a>的第七篇文章，本系列前六篇文章如下：  <br/>
<a href="/blog/2013/10/14/run-tomcat-in-idea-or-eclipse/">在IntelliJ IDEA 和 Eclipse运行tomcat 7源代码（Tomcat源代码阅读系列之一）</a>   <br/>
<a href="/blog/2013/10/16/tomcat-architecture/">Tomcat总体结构                             （Tomcat源代码阅读系列之二）</a>  <br/>
<a href="/blog/2013/10/17/tomcat-start-process/">Tomcat启动过程（Tomcat源代码阅读系列之三）</a> <br/>
<a href="/blog/2013/10/21/tomcat-shutdown/">Tomcat关闭过程（Tomcat源代码阅读系列之四）</a><br/>
<a href="/blog/2013/10/24/tomcat-request-process/">Tomcat请求处理流程（Tomcat源代码阅读系列之五）</a><br/>
<a href="/blog/2013/10/28/tomcat-class-loader/">Tomcat类加载器机制（Tomcat源代码阅读系列之六）</a></p>

<p>前面几篇我们分析了Tomcat的启动，关闭，请求处理的流程，tomcat的classloader机制，本篇将接着分析Tomcat的session管理方面的内容。</p>

<!-- more -->


<p>在开始之前，我们先来看一下总体上的结构，熟悉了总体结构以后，我们在一步步的去分析源代码。Tomcat session相光的类图如下：
<img class="center" src="/images/2013/11/06/tomcat-session.jpg">
通过上图，我们可以看出每一个StandardContext会关联一个Manager,默认情况下Manager的实现类是StandardManager，而StandardManager内部会聚合多个Session，其中StandardSession是Session的默认实现类，当我们调用Request.getSession的时候，Tomcat通过StandardSessionFacade这个外观类将StandardSession包装以后返回。</p>

<p>上面清楚了总体的结构以后，我们来进一步的通过源代码来分析一下。咋们首先从Request的getSession方法看起。
```java org.apache.catalina.connector.Request#getSession
public HttpSession getSession() {</p>

<pre><code>Session session = doGetSession(true);
if (session == null) {
    return null;
}

return session.getSession();
</code></pre>

<p>}
<code>
从上面的代码，我们可以看出首先首先调用doGetSession方法获取Session，然后再调用Session的getSession方法返回HttpSession，那接下来我们再来看看doGetSession方法：
</code>java org.apache.catalina.connector.Request#doGetSession
protected Session doGetSession(boolean create) {</p>

<pre><code>// There cannot be a session if no context has been assigned yet
if (context == null) {
    return (null);
}

// Return the current session if it exists and is valid
if ((session != null) &amp;&amp; !session.isValid()) {
    session = null;
}
if (session != null) {
    return (session);
}

// Return the requested session if it exists and is valid
// 1 
Manager manager = null;
if (context != null) {
    manager = context.getManager();
}
if (manager == null)
 {
    return (null);      // Sessions are not supported
}
// 2
if (requestedSessionId != null) {
    try {
        session = manager.findSession(requestedSessionId);
    } catch (IOException e) {
        session = null;
    }
    if ((session != null) &amp;&amp; !session.isValid()) {
        session = null;
    }
    if (session != null) {
        session.access();
        return (session);
    }
}

// Create a new session if requested and the response is not committed
// 3
if (!create) {
    return (null);
}
if ((context != null) &amp;&amp; (response != null) &amp;&amp;
    context.getServletContext().getEffectiveSessionTrackingModes().
            contains(SessionTrackingMode.COOKIE) &amp;&amp;
    response.getResponse().isCommitted()) {
    throw new IllegalStateException
      (sm.getString("coyoteRequest.sessionCreateCommitted"));
}

// Attempt to reuse session id if one was submitted in a cookie
// Do not reuse the session id if it is from a URL, to prevent possible
// phishing attacks
// Use the SSL session ID if one is present.
// 4
if (("/".equals(context.getSessionCookiePath())
        &amp;&amp; isRequestedSessionIdFromCookie()) || requestedSessionSSL ) {
    session = manager.createSession(getRequestedSessionId());
} else {
    session = manager.createSession(null);
}

// Creating a new session cookie based on that session
if ((session != null) &amp;&amp; (getContext() != null)
       &amp;&amp; getContext().getServletContext().
               getEffectiveSessionTrackingModes().contains(
                       SessionTrackingMode.COOKIE)) {
    // 5 
    Cookie cookie =
        ApplicationSessionCookieConfig.createSessionCookie(
                context, session.getIdInternal(), isSecure());

    response.addSessionCookieInternal(cookie);
}

if (session == null) {
    return null;
}

session.access();
return session;
</code></pre>

<p>}</p>

<p>```
下面我们就来重点分析一下，上面代码中标注了数字的地方：</p>

<ol>
<li>标注1（第17行）首先从StandardContext中获取对应的Manager对象，缺省情况下，这个地方获取的其实就是StandardManager的实例。</li>
<li>标注2（第26行）从Manager中根据requestedSessionId获取session，如果session已经失效了，则将session置为null以便下面创建新的session,如果session不为空则通过调用session的access方法标注session的访问时间，然后返回。</li>
<li>标注3（第43行）判断传递的参数，如果为false，则直接返回空，这其实就是对应的Request.getSession(true/false)的情况，当传递false的时候，如果不存在session，则直接返回空，不会新建。</li>
<li>标注4 （第59行）调用Manager来创建一个新的session，这里默认会调用到StandardManager的方法，而StandardManager继承了ManagerBase，那么默认其实是调用了了ManagerBase的方法。</li>
<li>标注5 (第72行)创建了一个Cookie，而Cookie的名称就是大家熟悉的JSESSIONID，另外JSESSIONID其实也是可以配置的，这个可以通过context节点的sessionCookieName来修改。比如<Context sessionCookieName="yoursessionId">&hellip;</Context>.</li>
</ol>


<p>通过doGetSession获取到Session了以后，我们发现调用了session.getSession方法，而Session的实现类是StandardSession，那么我们再来看下StandardSession的getSession方法。
```java org.apache.catalina.session.StandardSession#getSession
public HttpSession getSession() {</p>

<pre><code>if (facade == null){
    if (SecurityUtil.isPackageProtectionEnabled()){
        final StandardSession fsession = this;
        facade = AccessController.doPrivileged(
                new PrivilegedAction&lt;StandardSessionFacade&gt;(){
            @Override
            public StandardSessionFacade run(){
                return new StandardSessionFacade(fsession);
            }
        });
    } else {
        facade = new StandardSessionFacade(this);
    }
}
return (facade);
</code></pre>

<p>}</p>

<p>```
通过上面的代码，我们可以看到通过StandardSessionFacade的包装类将StandardSession包装以后返回。到这里我想大家应该熟悉了Session创建的整个流程。</p>

<p>接着我们再来看看，Sesssion是如何被销毁的。我们在<a href="/blog/2013/10/17/tomcat-start-process/">Tomcat启动过程（Tomcat源代码阅读系列之三）</a>中之处，在容器启动以后会启动一个ContainerBackgroundProcessor线程，这个线程是在Container启动的时候启动的，这条线程就通过后台周期性的调用org.apache.catalina.core.ContainerBase#backgroundProcess，而backgroundProcess方法最终又会调用org.apache.catalina.session.ManagerBase#backgroundProcess，接下来我们就来看看Manger的backgroundProcess方法。</p>

<p>```java org.apache.catalina.session.ManagerBase#backgroundProcess
public void backgroundProcess() {</p>

<pre><code>count = (count + 1) % processExpiresFrequency;
if (count == 0)
    processExpires();
</code></pre>

<p>}
<code>
上面的代码里，需要注意一下，默认情况下backgroundProcess是每10秒运行一次（StandardEngine构造的时候，将backgroundProcessorDelay设置为了10），而这里我们通过processExpiresFrequency来控制频率，例如processExpiresFrequency的值默认为6，那么相当于没一分钟运行一次processExpires方法。接下来我们再来看看processExpires。
</code>java org.apache.catalina.session.ManagerBase#processExpires
public void processExpires() {</p>

<pre><code>long timeNow = System.currentTimeMillis();
Session sessions[] = findSessions();
int expireHere = 0 ;

if(log.isDebugEnabled())
    log.debug("Start expire sessions " + getName() + " at " + timeNow + " sessioncount " + sessions.length);
for (int i = 0; i &lt; sessions.length; i++) {
    if (sessions[i]!=null &amp;&amp; !sessions[i].isValid()) {
        expireHere++;
    }
}
long timeEnd = System.currentTimeMillis();
if(log.isDebugEnabled())
     log.debug("End expire sessions " + getName() + " processingTime " + (timeEnd - timeNow) + " expired sessions: " + expireHere);
processingTime += ( timeEnd - timeNow );
</code></pre>

<p>}
<code>
上面的代码比较简单，首先查找出当前context的所有的session，然后调用session的isValid方法，接下来我们在看看Session的isValid方法。
</code>java org.apache.catalina.session.StandardSession#isValid
public boolean isValid() {</p>

<pre><code>if (this.expiring) {
    return true;
}

if (!this.isValid) {
    return false;
}

if (ACTIVITY_CHECK &amp;&amp; accessCount.get() &gt; 0) {
    return true;
}

if (maxInactiveInterval &gt; 0) {
    long timeNow = System.currentTimeMillis();
    int timeIdle;
    if (LAST_ACCESS_AT_START) {
        timeIdle = (int) ((timeNow - lastAccessedTime) / 1000L);
    } else {
        timeIdle = (int) ((timeNow - thisAccessedTime) / 1000L);
    }
    if (timeIdle &gt;= maxInactiveInterval) {
        expire(true);
    }
}

return (this.isValid);
</code></pre>

<p>}</p>

<p>```
查看上面的代码，主要就是通过对比当前时间和上次访问的时间差是否大于了最大的非活动时间间隔，如果大于就会调用expire(true)方法对session进行超期处理。这里需要注意一点，默认情况下LAST_ACCESS_AT_START为false，读者也可以通过设置系统属性的方式进行修改，而如果采用LAST_ACCESS_AT_START的时候，那么请求本身的处理时间将不算在内。比如一个请求处理开始的时候是10:00,请求处理花了1分钟，那么如果LAST_ACCESS_AT_START为true，则算是否超期的时候，是从10:00算起，而不是10:01。</p>

<p>接下来我们再来看看expire方法，代码如下：
```java org.apache.catalina.session.StandardSession#expire
public void expire(boolean notify) {</p>

<pre><code>// Check to see if expire is in progress or has previously been called
if (expiring || !isValid)
    return;

synchronized (this) {
    // Check again, now we are inside the sync so this code only runs once
    // Double check locking - expiring and isValid need to be volatile
    if (expiring || !isValid)
        return;

    if (manager == null)
        return;

    // Mark this session as "being expired"
    // 1         
    expiring = true;

    // Notify interested application event listeners
    // FIXME - Assumes we call listeners in reverse order
    Context context = (Context) manager.getContainer();

    // The call to expire() may not have been triggered by the webapp.
    // Make sure the webapp's class loader is set when calling the
    // listeners
    ClassLoader oldTccl = null;
    if (context.getLoader() != null &amp;&amp;
            context.getLoader().getClassLoader() != null) {
        oldTccl = Thread.currentThread().getContextClassLoader();
        if (Globals.IS_SECURITY_ENABLED) {
            PrivilegedAction&lt;Void&gt; pa = new PrivilegedSetTccl(
                    context.getLoader().getClassLoader());
            AccessController.doPrivileged(pa);
        } else {
            Thread.currentThread().setContextClassLoader(
                    context.getLoader().getClassLoader());
        }
    }
    try {
        // 2
        Object listeners[] = context.getApplicationLifecycleListeners();
        if (notify &amp;&amp; (listeners != null)) {
            HttpSessionEvent event =
                new HttpSessionEvent(getSession());
            for (int i = 0; i &lt; listeners.length; i++) {
                int j = (listeners.length - 1) - i;
                if (!(listeners[j] instanceof HttpSessionListener))
                    continue;
                HttpSessionListener listener =
                    (HttpSessionListener) listeners[j];
                try {
                    context.fireContainerEvent("beforeSessionDestroyed",
                            listener);
                    listener.sessionDestroyed(event);
                    context.fireContainerEvent("afterSessionDestroyed",
                            listener);
                } catch (Throwable t) {
                    ExceptionUtils.handleThrowable(t);
                    try {
                        context.fireContainerEvent(
                                "afterSessionDestroyed", listener);
                    } catch (Exception e) {
                        // Ignore
                    }
                    manager.getContainer().getLogger().error
                        (sm.getString("standardSession.sessionEvent"), t);
                }
            }
        }
    } finally {
        if (oldTccl != null) {
            if (Globals.IS_SECURITY_ENABLED) {
                PrivilegedAction&lt;Void&gt; pa =
                    new PrivilegedSetTccl(oldTccl);
                AccessController.doPrivileged(pa);
            } else {
                Thread.currentThread().setContextClassLoader(oldTccl);
            }
        }
    }

    if (ACTIVITY_CHECK) {
        accessCount.set(0);
    }
    setValid(false);

    // Remove this session from our manager's active sessions
    // 3 
    manager.remove(this, true);

    // Notify interested session event listeners
    if (notify) {
        fireSessionEvent(Session.SESSION_DESTROYED_EVENT, null);
    }

    // Call the logout method
    if (principal instanceof GenericPrincipal) {
        GenericPrincipal gp = (GenericPrincipal) principal;
        try {
            gp.logout();
        } catch (Exception e) {
            manager.getContainer().getLogger().error(
                    sm.getString("standardSession.logoutfail"),
                    e);
        }
    }

    // We have completed expire of this session
    expiring = false;

    // Unbind any objects associated with this session
    // 4
    String keys[] = keys();
    for (int i = 0; i &lt; keys.length; i++)
        removeAttributeInternal(keys[i], notify);

}
</code></pre>

<p>}</p>

<p>```
上面代码的主流程我已经标注了数字，我们来逐一分析一下：</p>

<ol>
<li>标注1（第18行）标记当前的session为超期</li>
<li>标注2（第41行）出发HttpSessionListener监听器的方法。</li>
<li>标注3（第89行）从Manager里面移除当前的session</li>
<li>标注4（第113行）将session中保存的属性移除。</li>
</ol>


<p>到这里我们已经清楚了Tomcat中对与StandardSession的创建以及销毁的过程，其实StandardSession仅仅是实现了内存中Session的存储，而Tomcat还支持将Session持久化，以及Session集群节点间的同步。这些内容我们以后再来分析。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tomcat类加载器机制（Tomcat源代码阅读系列之六）]]></title>
    <link href="http://imtiger.github.io/blog/2013/10/28/tomcat-class-loader/"/>
    <updated>2013-10-28T14:06:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2013/10/28/tomcat-class-loader</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/10/14/apache_tomcat_bag.jpg">
本文是<a href="/blog/2013/10/08/tomcat-source-code-study/">Tomcat源代码阅读系列</a>的第六篇文章，本系列前五篇文章如下：  <br/>
<a href="/blog/2013/10/14/run-tomcat-in-idea-or-eclipse/">在IntelliJ IDEA 和 Eclipse运行tomcat 7源代码（Tomcat源代码阅读系列之一）</a>   <br/>
<a href="/blog/2013/10/16/tomcat-architecture/">Tomcat总体结构                             （Tomcat源代码阅读系列之二）</a>  <br/>
<a href="/blog/2013/10/17/tomcat-start-process/">Tomcat启动过程（Tomcat源代码阅读系列之三）</a> <br/>
<a href="/blog/2013/10/21/tomcat-shutdown/">Tomcat关闭过程（Tomcat源代码阅读系列之四）</a><br/>
<a href="/blog/2013/10/24/tomcat-request-process/">Tomcat请求处理流程（Tomcat源代码阅读系列之五）</a></p>

<p>前面几篇我们分析了Tomcat的启动，关闭以及请求处理的流程，本篇将接着分析Tomcat的类加载器机制，如果大家对Java的类加载器机制不熟悉的话，建议首先熟悉一下Java的类加载器机制后再来查看本篇文章，对于Java的类加载器机制，大家可以参考自行Google或者参考笔者的另外一篇文章：<a href="/blog/2009/11/09/java-classloader/">Java Classloader机制解析</a>.</p>

<!-- more -->


<p>要说Tomcat的Classloader机制，我们还得从Bootstrap开始。在BootStrap初始化的时候，调用了<code>org.apache.catalina.startup.Bootstrap#initClassLoaders</code>方法，这个方法里面创建了3个ClassLoader,它们分别是commonLoader,catalinaLoader,sharedLoader，其中catalinaLoader,sharedLoader的父亲加载器是commonLoader，initClassLoaders执行的过程中会执行createClassLoader，而createClassLoader是根据conf/catalina.properties文件中common.loader，server.loader，shared.loader的值来初始化，它的代码如下：
```java org.apache.catalina.startup.Bootstrap#createClassLoader
private ClassLoader createClassLoader(String name, ClassLoader parent)</p>

<pre><code>throws Exception {

String value = CatalinaProperties.getProperty(name + ".loader");
// 1 
if ((value == null) || (value.equals("")))
    return parent;

// 2
value = replace(value);

List&lt;Repository&gt; repositories = new ArrayList&lt;Repository&gt;();

StringTokenizer tokenizer = new StringTokenizer(value, ",");
while (tokenizer.hasMoreElements()) {
    String repository = tokenizer.nextToken().trim();
    if (repository.length() == 0) {
        continue;
    }

    // Check for a JAR URL repository
    try {
        @SuppressWarnings("unused")
        URL url = new URL(repository);
        repositories.add(
                new Repository(repository, RepositoryType.URL));
        continue;
    } catch (MalformedURLException e) {
        // Ignore
    }

    // Local repository
    if (repository.endsWith("*.jar")) {
        repository = repository.substring
            (0, repository.length() - "*.jar".length());
        repositories.add(
                new Repository(repository, RepositoryType.GLOB));
    } else if (repository.endsWith(".jar")) {
        repositories.add(
                new Repository(repository, RepositoryType.JAR));
    } else {
        repositories.add(
                new Repository(repository, RepositoryType.DIR));
    }
}
// 3
ClassLoader classLoader = ClassLoaderFactory.createClassLoader
    (repositories, parent);


return classLoader;
</code></pre>

<p>}
```</p>

<p>以上代码删除了与本篇无关的代码，下面我们分别来分析一下标注的地方：</p>

<ol>
<li>标注1的代码（第5行）判断如果catalina.properties中没有配置对应的loader属性的话，直接返回父加载器，而默认情况下，server.loader,shared.loader为空，那么此时的catalinaLoader,sharedLoader其实是同一个ClassLoader.</li>
<li>标注2（第9行）的地方根据环境变量的配置替换字符串中的值.默认情况下，common.loader的值为common.loader=${catalina.base}/lib,${catalina.base}/lib/<em>.jar,${catalina.home}/lib,${catalina.home}/lib/</em>.jar,这里会将catalina.base和catalina.home用环境变量的值替换。</li>
<li>标注3（第46行）的代码最终调用<code>org.apache.catalina.startup.ClassLoaderFactory#createClassLoader</code>静态工厂方法创建了URLClassloader的实例，而具体的URL其实就是*.loader属性配置的内容，此外如果parent为null的话，则直接用系统类加载器。</li>
</ol>


<p>上面分析了Tomcat在启动的时候，初始化的几个ClassLoader，接下来我们再来继续看看，这些ClassLoader具体都用在什么地方。</p>

<p>我们接着来看org.apache.catalina.startup.Bootstrap#init方法，在初始化完3个classLoader以后，接下来首先通过catalinaLoader加载了<code>org.apache.catalina.startup.Catalina</code>l类，然后通过放射调用了org.apache.catalina.startup.Catalina#setParentClassLoader,具体代码片段如下：
```java org.apache.catalina.startup.Bootstrap#init
Class&lt;?> startupClass =</p>

<pre><code>catalinaLoader.loadClass
("org.apache.catalina.startup.Catalina");
</code></pre>

<p>Object startupInstance = startupClass.newInstance();</p>

<p>String methodName = &ldquo;setParentClassLoader&rdquo;;
Class&lt;?> paramTypes[] = new Class[1];
paramTypes[0] = Class.forName(&ldquo;java.lang.ClassLoader&rdquo;);
Object paramValues[] = new Object[1];
paramValues[0] = sharedLoader;
Method method =</p>

<pre><code>startupInstance.getClass().getMethod(methodName, paramTypes);
</code></pre>

<p>method.invoke(startupInstance, paramValues);
<code>
通过上面的代码，我们可以清楚的看到调用了Catalina的setParentClassLoader放，那么到这里我们可能又要想知道，设置了parentClassLoader以后，sharedLoader又是在哪里使用的呢？这就需要我们接着来分析容器启动的代码。我们通过查看`org.apache.catalina.startup.Catalina#getParentClassLoader`调用栈，我们看到在StandardContext的startInternal方法中调用了它，那么我们查看一下它的代码，包含了如下代码片段：
</code>java org.apache.catalina.core.StandardContext#startInternal
if (getLoader() == null) {</p>

<pre><code>        WebappLoader webappLoader = new WebappLoader(getParentClassLoader());
        webappLoader.setDelegate(getDelegate());
        setLoader(webappLoader);
</code></pre>

<p>}
try {</p>

<pre><code>if (ok) {

    // Start our subordinate components, if any
    if ((loader != null) &amp;&amp; (loader instanceof Lifecycle))
        ((Lifecycle) loader).start();
    //other code    
}
</code></pre>

<p>catch(Exception e){
}
```
通过查看上面的代码，我们看到在StandardContext启动的时候，会创建webapploader，创建webapploader的时候会将getParentClassLoader方法返回的结果（这里返回的其实就是sharedLoader）赋值给自己的parentClassLoader变量,接着又会调用到Webapploader的start方法，因为WebappLoader符合Tomcat组件生命周期管理的模板方法模式，因此会调用到它的startInternal方法。我们接下来就来看看WebappLoader的startInternal，我们摘取一部分与本篇相关的代码片段如下：</p>

<p>```java org.apache.catalina.loader.WebappLoader#startInternal
classLoader = createClassLoader();
classLoader.setResources(container.getResources());
classLoader.setDelegate(this.delegate);
classLoader.setSearchExternalFirst(searchExternalFirst);</p>

<p><code>
从上的代码可以看到调用了createClassLoader方法创建一个classLoader，那么我们再看来看看createClassLoader的代码：
</code>java org.apache.catalina.loader.WebappLoader#createClassLoader
private WebappClassLoader createClassLoader()</p>

<pre><code>throws Exception {

Class&lt;?&gt; clazz = Class.forName(loaderClass);
WebappClassLoader classLoader = null;

if (parentClassLoader == null) {
    parentClassLoader = container.getParentClassLoader();
}
Class&lt;?&gt;[] argTypes = { ClassLoader.class };
Object[] args = { parentClassLoader };
Constructor&lt;?&gt; constr = clazz.getConstructor(argTypes);
classLoader = (WebappClassLoader) constr.newInstance(args);

return classLoader;
</code></pre>

<p>}
<code>``
在上面的代码里面，loaderClass是WebappLoader的实例变量，其值为</code>org.apache.catalina.loader.WebappClassLoader`，那么上面的代码其实就是通过反射调用了WebappClassLoader的构造函数，然后传递了sharedLoader作为其父亲加载器。</p>

<p>代码阅读到这里，我们已经基本清楚了Tomcat中ClassLoader的总体结构，总结如下：
在Tomcat存在common,cataina,shared三个公共的classloader,默认情况下，这三个classloader其实是同一个，都是common classloader,而针对每个webapp，也就是context（对应代码中的StandardContext类），都有自己的WebappClassLoader来加载每个应用自己的类。上面的描述，我们可以通过下图形象化的描述：
<img class="center" src="/images/2013/10/30/tomcat-classloader.png"></p>

<p>清楚了Tomcat总体的ClassLoader结构以后，咋们就来进一步来分析一下WebAppClassLoader的代码，我们知道Java的ClassLoader机制有parent-first的机制，而这种机制是在loadClass方法保证的，一般情况下，我们只需要重写findClass方法就好了，而对于WebAppClassLoader，通过查看源代码，我们发现loadClass和findClass方法都进行了重写，那么我们首先就来看看它的loadClass方法,它的代码如下：
```java org.apache.catalina.loader.WebappClassLoader#loadClass
public synchronized Class&lt;?> loadClass(String name, boolean resolve)</p>

<pre><code>throws ClassNotFoundException {

if (log.isDebugEnabled())
    log.debug("loadClass(" + name + ", " + resolve + ")");
Class&lt;?&gt; clazz = null;

// Log access to stopped classloader
if (!started) {
    try {
        throw new IllegalStateException();
    } catch (IllegalStateException e) {
        log.info(sm.getString("webappClassLoader.stopped", name), e);
    }
}

// (0) Check our previously loaded local class cache
// 1 
clazz = findLoadedClass0(name);
if (clazz != null) {
    if (log.isDebugEnabled())
        log.debug("  Returning class from cache");
    if (resolve)
        resolveClass(clazz);
    return (clazz);
}

// (0.1) Check our previously loaded class cache
// 2
clazz = findLoadedClass(name);
if (clazz != null) {
    if (log.isDebugEnabled())
        log.debug("  Returning class from cache");
    if (resolve)
        resolveClass(clazz);
    return (clazz);
}

// (0.2) Try loading the class with the system class loader, to prevent
//       the webapp from overriding J2SE classes
// 3 
try {
    clazz = system.loadClass(name);
    if (clazz != null) {
        if (resolve)
            resolveClass(clazz);
        return (clazz);
    }
} catch (ClassNotFoundException e) {
    // Ignore
}

// (0.5) Permission to access this class when using a SecurityManager
if (securityManager != null) {
    int i = name.lastIndexOf('.');
    if (i &gt;= 0) {
        try {
            securityManager.checkPackageAccess(name.substring(0,i));
        } catch (SecurityException se) {
            String error = "Security Violation, attempt to use " +
                "Restricted Class: " + name;
            log.info(error, se);
            throw new ClassNotFoundException(error, se);
        }
    }
}

//4 
boolean delegateLoad = delegate || filter(name);

// (1) Delegate to our parent if requested
// 5 
if (delegateLoad) {
    if (log.isDebugEnabled())
        log.debug("  Delegating to parent classloader1 " + parent);
    ClassLoader loader = parent;
    if (loader == null)
        loader = system;
    try {
        clazz = Class.forName(name, false, loader);
        if (clazz != null) {
            if (log.isDebugEnabled())
                log.debug("  Loading class from parent");
            if (resolve)
                resolveClass(clazz);
            return (clazz);
        }
    } catch (ClassNotFoundException e) {
        // Ignore
    }
}

// (2) Search local repositories
if (log.isDebugEnabled())
    log.debug("  Searching local repositories");
// 6 
try {
    clazz = findClass(name);
    if (clazz != null) {
        if (log.isDebugEnabled())
            log.debug("  Loading class from local repository");
        if (resolve)
            resolveClass(clazz);
        return (clazz);
    }
} catch (ClassNotFoundException e) {
    // Ignore
}

// (3) Delegate to parent unconditionally
// 7
if (!delegateLoad) {
    if (log.isDebugEnabled())
        log.debug("  Delegating to parent classloader at end: " + parent);
    ClassLoader loader = parent;
    if (loader == null)
        loader = system;
    try {
        clazz = Class.forName(name, false, loader);
        if (clazz != null) {
            if (log.isDebugEnabled())
                log.debug("  Loading class from parent");
            if (resolve)
                resolveClass(clazz);
            return (clazz);
        }
    } catch (ClassNotFoundException e) {
        // Ignore
    }
}

throw new ClassNotFoundException(name);
</code></pre>

<p>}</p>

<p>```
我们一步步的来分析一下上面的代码做了什么事情。</p>

<ol>
<li>标注1(第18行)代码，首先从当前ClassLoader的本地缓存中加载类，如果找到则返回。</li>
<li>标注2(第29行)代码，在本地缓存没有的情况下，调用ClassLoader的findLoadedClass方法查看jvm是否已经加载过此类，如果已经加载则直接返回。</li>
<li>标注3(第41行)代码，通过系统的来加载器加载此类，这里防止应用写的类覆盖了J2SE的类,这句代码非常关键，如果不写的话，就会造成你自己写的类有可能会把J2SE的类给替换调，另外假如你写了一个javax.servlet.Servlet类，放在当前应用的WEB-INF/class中，如果没有此句代码的保证，那么你自己写的类就会替换到Tomcat容器Lib中包含的类。</li>
<li>标注4(第68行)代码，判断是否需要委托给父类加载器进行加载，delegate属性默认为false，那么delegatedLoad的值就取决于filter的返回值了，filter方法中根据包名来判断是否需要进行委托加载，默认情况下会返回false.因此delegatedLoad为false</li>
<li>标注5(第72行)代码，因为delegatedLoad为false,那么此时不会委托父加载器去加载，这里其实是没有遵循parent-first的加载机制。</li>
<li>标注6(第96行)调用findClass方法在webapp级别进行加载</li>
<li>标注7(第111行)如果还是没有加载到类，并且不采用委托机制的话，则通过父类加载器去加载。</li>
</ol>


<p>通过上面的描述，我们可以知道Tomcat在加载webapp级别的类的时候，默认是不遵守parent-first的，这样做的好处是更好的实现了应用的隔离，但是坏处就是加大了内存浪费，同样的类库要在不同的app中都要加载一份。</p>

<p>上面分析完了loadClass，我们接着在来分析一下findClass，通过分析findClass的代码，最终会调用<code>org.apache.catalina.loader.WebappClassLoader#findClassInternal</code>方法，那我们就来分析一下它的代码：
```java org.apache.catalina.loader.WebappClassLoader#findClassInternal
protected Class&lt;?> findClassInternal(String name)</p>

<pre><code>throws ClassNotFoundException {

//
if (!validate(name))
    throw new ClassNotFoundException(name);

String tempPath = name.replace('.', '/');
String classPath = tempPath + ".class";

ResourceEntry entry = null;

if (securityManager != null) {
    PrivilegedAction&lt;ResourceEntry&gt; dp =
        new PrivilegedFindResourceByName(name, classPath);
    entry = AccessController.doPrivileged(dp);
} else {
    // 1 
    entry = findResourceInternal(name, classPath);
}

if (entry == null)
    throw new ClassNotFoundException(name);

Class&lt;?&gt; clazz = entry.loadedClass;
if (clazz != null)
    return clazz;

synchronized (this) {
    clazz = entry.loadedClass;
    if (clazz != null)
        return clazz;

    if (entry.binaryContent == null)
        throw new ClassNotFoundException(name);

    try {
        // 2
        clazz = defineClass(name, entry.binaryContent, 0,
                entry.binaryContent.length,
                new CodeSource(entry.codeBase, entry.certificates));
    } catch (UnsupportedClassVersionError ucve) {
        throw new UnsupportedClassVersionError(
                ucve.getLocalizedMessage() + " " +
                sm.getString("webappClassLoader.wrongVersion",
                        name));
    }
    entry.loadedClass = clazz;
    entry.binaryContent = null;
    entry.source = null;
    entry.codeBase = null;
    entry.manifest = null;
    entry.certificates = null;
}

return clazz;
</code></pre>

<p>}
```
上面的代码标注1（第19行）的地方通过名称去当前webappClassLoader的仓库中查找对应的类文件，标注2(第38行)的代码，将找到的类文件通过defineClass转变为Jvm可以识别的Class对象返回。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tomcat请求处理流程（Tomcat源代码阅读系列之五）]]></title>
    <link href="http://imtiger.github.io/blog/2013/10/24/tomcat-request-process/"/>
    <updated>2013-10-24T09:54:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2013/10/24/tomcat-request-process</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/10/14/apache_tomcat_bag.jpg">
本文是<a href="/blog/2013/10/08/tomcat-source-code-study/">Tomcat源代码阅读系列</a>的第五篇文章，本系列前四篇文章如下：<br/>
<a href="/blog/2013/10/14/run-tomcat-in-idea-or-eclipse/">在IntelliJ IDEA 和 Eclipse运行tomcat 7源代码（Tomcat源代码阅读系列之一）</a> <br/>
<a href="/blog/2013/10/16/tomcat-architecture/">Tomcat总体结构                             （Tomcat源代码阅读系列之二）</a><br/>
<a href="/blog/2013/10/17/tomcat-start-process/">Tomcat启动过程（Tomcat源代码阅读系列之三）</a>
<a href="/blog/2013/10/21/tomcat-shutdown/">Tomcat关闭过程（Tomcat源代码阅读系列之四）</a></p>

<p>前面已经分析完了Tomcat的启动和关闭过程，本篇就来接着分析一下Tomcat中请求的处理过程。</p>

<!-- more -->


<p>在开始本文之前，咋们首先来看看一个Http请求处理的过程，一般情况下是<code>浏览器发送http请求-&gt;建立Socket连接-&gt;通过Socket读取数据-&gt;根据http协议解析数据-&gt;调用后台服务完成响应</code>,而Tomcat既是一个HttpServer也是一个Servlet 容器，那么这里必然也涉及到如上过程，首先根据HTTP协议规范解析请求数据，然后将请求转发给Servlet进行处理，因此顺应这样的思路，本文也将从<strong>Http协议请求解析</strong>，<strong>请求如何转发给Servlet</strong>两个方面来进行分析。首先来看Http协议请求解析。</p>

<h1>Http协议请求解析</h1>

<p>在<a href="/blog/2013/10/17/tomcat-start-process/">Tomcat启动过程（Tomcat源代码阅读系列之三）</a>一文中，我们已经知道Tomcat启动以后，默认情况下会通过<code>org.apache.tomcat.util.net.JIoEndpoint.Acceptor</code>监听Socket连接，当监听到有Socket连接的时候，就会调用<code>org.apache.tomcat.util.net.JIoEndpoint#processSocket</code>方法进行处理，下面我们就来看看此方法的代码，为了节省版面，只保留与本文相关的代码。
```java org.apache.tomcat.util.net.JIoEndpoint#processSocket
protected boolean processSocket(Socket socket) {</p>

<pre><code>    // Process the request from this socket
    try {
        SocketWrapper&lt;Socket&gt; wrapper = new SocketWrapper&lt;Socket&gt;(socket);
        wrapper.setKeepAliveLeft(getMaxKeepAliveRequests());
        // During shutdown, executor may be null - avoid NPE
        if (!running) {
            return false;
        }
        getExecutor().execute(new SocketProcessor(wrapper));
    } catch (RejectedExecutionException x) {
       //exception handler ...
       return false;
    }
    return true;
</code></pre>

<p>}
<code>
通过上面的代码，我们可以看出首先将Socket封装为SocketWrapper，然后通过SocketProcessor来进行处理，因为Tomcat必然面对用户并发请求，因此这里Socket的处理通过新的线程池来处理。接下来我们再来看看SocketProcess的代码，同样省略了一些非核心的代码，代码如下：
</code>java org.apache.tomcat.util.net.JIoEndpoint.SocketProcessor#run
public void run() {</p>

<pre><code>    boolean launch = false;
    synchronized (socket) {
        try {
            SocketState state = SocketState.OPEN;

            try {
                // SSL handshake
                serverSocketFactory.handshake(socket.getSocket());
            } catch (Throwable t) {
                ExceptionUtils.handleThrowable(t);
                if (log.isDebugEnabled()) {
                    log.debug(sm.getString("endpoint.err.handshake"), t);
                }
                // Tell to close the socket
                state = SocketState.CLOSED;
            }

            if ((state != SocketState.CLOSED)) {
                if (status == null) {
                    // 1 
                    state = handler.process(socket, SocketStatus.OPEN);
                } else {
                    state = handler.process(socket,status);
                }
            }
            if (state == SocketState.CLOSED) {
                // Close socket
                if (log.isTraceEnabled()) {
                    log.trace("Closing socket:"+socket);
                }
                countDownConnection();
                try {
                    socket.getSocket().close();
                } catch (IOException e) {
                    // Ignore
                }
            } else if (state == SocketState.OPEN ||
                    state == SocketState.UPGRADING  ||
                    state == SocketState.UPGRADED){
                socket.setKeptAlive(true);
                socket.access();
                launch = true;
            } else if (state == SocketState.LONG) {
                socket.access();
                waitingRequests.add(socket);
            }
        } finally {
           //other code
        }
    }
    socket = null;
    // Finish up this request
}
</code></pre>

<p>}
<code>
默认情况下，代码会运行到标注1的地方，标注1的地方又通过`org.apache.tomcat.util.net.JIoEndpoint.Handler#process`的方法进行处理，而通过前面Tomcat启动的文章，我们已经知道handler属性是在`org.apache.coyote.http11.Http11Protocol`的构造方法中初始化的，构造方法如下：
</code>java org.apache.coyote.http11.Http11Protocol#Http11Protocol
public Http11Protocol() {</p>

<pre><code>endpoint = new JIoEndpoint();
cHandler = new Http11ConnectionHandler(this);
((JIoEndpoint) endpoint).setHandler(cHandler);
setSoLinger(Constants.DEFAULT_CONNECTION_LINGER);
setSoTimeout(Constants.DEFAULT_CONNECTION_TIMEOUT);
setTcpNoDelay(Constants.DEFAULT_TCP_NO_DELAY);
</code></pre>

<p>}
<code>``
从构造方法中，我们可以清楚的看到，其实初始化了</code>org.apache.coyote.http11.Http11Protocol.Http11ConnectionHandler<code>的实例，那么接下来我们就来看看它的process方法，因为Http11ConnectionHandler继承了</code>org.apache.coyote.AbstractProtocol.AbstractConnectionHandler`，而自己没有实现process方法，因此会调用到父类的process方法，那么接下来我们就来看看AbstractConnectionHandler的process方法，代码如下：</p>

<p>```java org.apache.coyote.AbstractProtocol.AbstractConnectionHandler#process
public SocketState process(SocketWrapper<S> socket,</p>

<pre><code>    SocketStatus status) {
Processor&lt;S&gt; processor = connections.remove(socket.getSocket());

if (status == SocketStatus.DISCONNECT &amp;&amp; processor == null) {
    //nothing more to be done endpoint requested a close
    //and there are no object associated with this connection
    return SocketState.CLOSED;
}

socket.setAsync(false);

try {
    if (processor == null) {
        processor = recycledProcessors.poll();
    }
    if (processor == null) {
        processor = createProcessor();
    }

    initSsl(socket, processor);

    SocketState state = SocketState.CLOSED;
    do {
        if (status == SocketStatus.DISCONNECT &amp;&amp;
                !processor.isComet()) {
            // Do nothing here, just wait for it to get recycled
            // Don't do this for Comet we need to generate an end
            // event (see BZ 54022)
        } else if (processor.isAsync() ||
                state == SocketState.ASYNC_END) {
            state = processor.asyncDispatch(status);
        } else if (processor.isComet()) {
            state = processor.event(status);
        } else if (processor.isUpgrade()) {
            state = processor.upgradeDispatch();
        } else {
            state = processor.process(socket);
        }

        if (state != SocketState.CLOSED &amp;&amp; processor.isAsync()) {
            state = processor.asyncPostProcess();
        }

        if (state == SocketState.UPGRADING) {
            // Get the UpgradeInbound handler
            UpgradeInbound inbound = processor.getUpgradeInbound();
            // Release the Http11 processor to be re-used
            release(socket, processor, false, false);
            // Create the light-weight upgrade processor
            processor = createUpgradeProcessor(socket, inbound);
            inbound.onUpgradeComplete();
        }
    } while (state == SocketState.ASYNC_END ||
            state == SocketState.UPGRADING);

    return state;
} catch(java.net.SocketException e) {
            // exception handler   
}

return SocketState.CLOSED;
</code></pre>

<p>}
```</p>

<p>通过查看上面的代码，默认一个新连接的情况下，会调用<code>org.apache.coyote.Processor#process</code>方法,而Processor的实例实在<code>org.apache.coyote.AbstractProtocol.AbstractConnectionHandler#createProcessor</code>中创建的，通过查看createProcessor代码，我们发现是创建了一个org.apache.coyote.http11.Http11Processor的实例，那么接下来，我们就来看看它的process方法，因为Http11Processor继承了AbstractHttp11Processor，最终其实调用的是AbstractHttp11Processor的process方法，代码如下：</p>

<p>```java org.apache.coyote.http11.AbstractHttp11Processor#process
public SocketState process(SocketWrapper<S> socketWrapper)</p>

<pre><code>throws IOException {
RequestInfo rp = request.getRequestProcessor();
rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);

// Setting up the I/O
// 1 
setSocketWrapper(socketWrapper);
getInputBuffer().init(socketWrapper, endpoint);
getOutputBuffer().init(socketWrapper, endpoint);

// Flags
error = false;
keepAlive = true;
comet = false;
openSocket = false;
sendfileInProgress = false;
readComplete = true;
if (endpoint.getUsePolling()) {
    keptAlive = false;
} else {
    keptAlive = socketWrapper.isKeptAlive();
}

if (disableKeepAlive()) {
    socketWrapper.setKeepAliveLeft(0);
}

while (!error &amp;&amp; keepAlive &amp;&amp; !comet &amp;&amp; !isAsync() &amp;&amp;
        upgradeInbound == null &amp;&amp; !endpoint.isPaused()) {

    // Parsing the request header
    try {
        setRequestLineReadTimeout();
        //2 
        if (!getInputBuffer().parseRequestLine(keptAlive)) {
            if (handleIncompleteRequestLineRead()) {
                break;
            }
        }

        if (endpoint.isPaused()) {
            // 503 - Service unavailable
            response.setStatus(503);
            error = true;
        } else {
            // Make sure that connectors that are non-blocking during
            // header processing (NIO) only set the start time the first
            // time a request is processed.
            if (request.getStartTime() &lt; 0) {
                request.setStartTime(System.currentTimeMillis());
            }
            keptAlive = true;
            // Set this every time in case limit has been changed via JMX
            request.getMimeHeaders().setLimit(endpoint.getMaxHeaderCount());
            // Currently only NIO will ever return false here
            // 3
            if (!getInputBuffer().parseHeaders()) {
                // We've read part of the request, don't recycle it
                // instead associate it with the socket
                openSocket = true;
                readComplete = false;
                break;
            }
            if (!disableUploadTimeout) {
                setSocketTimeout(connectionUploadTimeout);
            }
        }
    } catch (IOException e) {
        if (getLog().isDebugEnabled()) {
            getLog().debug(
                    sm.getString("http11processor.header.parse"), e);
        }
        error = true;
        break;
    } catch (Throwable t) {
        ExceptionUtils.handleThrowable(t);
        UserDataHelper.Mode logMode = userDataHelper.getNextMode();
        if (logMode != null) {
            String message = sm.getString(
                    "http11processor.header.parse");
            switch (logMode) {
                case INFO_THEN_DEBUG:
                    message += sm.getString(
                            "http11processor.fallToDebug");
                    //$FALL-THROUGH$
                case INFO:
                    getLog().info(message);
                    break;
                case DEBUG:
                    getLog().debug(message);
            }
        }
        // 400 - Bad Request
        response.setStatus(400);
        adapter.log(request, response, 0);
        error = true;
    }

    if (!error) {
        // Setting up filters, and parse some request headers
        rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);
        try {
            prepareRequest();
        } catch (Throwable t) {
            ExceptionUtils.handleThrowable(t);
            if (getLog().isDebugEnabled()) {
                getLog().debug(sm.getString(
                        "http11processor.request.prepare"), t);
            }
            // 400 - Internal Server Error
            response.setStatus(400);
            adapter.log(request, response, 0);
            error = true;
        }
    }

    if (maxKeepAliveRequests == 1) {
        keepAlive = false;
    } else if (maxKeepAliveRequests &gt; 0 &amp;&amp;
            socketWrapper.decrementKeepAlive() &lt;= 0) {
        keepAlive = false;
    }

    // Process the request in the adapter
    if (!error) {
        try {
            // 4
            rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);
            adapter.service(request, response);
            // Handle when the response was committed before a serious
            // error occurred.  Throwing a ServletException should both
            // set the status to 500 and set the errorException.
            // If we fail here, then the response is likely already
            // committed, so we can't try and set headers.
            if(keepAlive &amp;&amp; !error) { // Avoid checking twice.
                error = response.getErrorException() != null ||
                        (!isAsync() &amp;&amp;
                        statusDropsConnection(response.getStatus()));
            }
            setCometTimeouts(socketWrapper);
        } catch (InterruptedIOException e) {
            error = true;
        } catch (HeadersTooLargeException e) {
            error = true;
            // The response should not have been committed but check it
            // anyway to be safe
            if (!response.isCommitted()) {
                response.reset();
                response.setStatus(500);
                response.setHeader("Connection", "close");
            }
        } catch (Throwable t) {
            ExceptionUtils.handleThrowable(t);
            getLog().error(sm.getString(
                    "http11processor.request.process"), t);
            // 500 - Internal Server Error
            response.setStatus(500);
            adapter.log(request, response, 0);
            error = true;
        }
    }

    // Finish the handling of the request
    rp.setStage(org.apache.coyote.Constants.STAGE_ENDINPUT);

    if (!isAsync() &amp;&amp; !comet) {
        if (error) {
            // If we know we are closing the connection, don't drain
            // input. This way uploading a 100GB file doesn't tie up the
            // thread if the servlet has rejected it.
            getInputBuffer().setSwallowInput(false);
        }
        endRequest();
    }

    rp.setStage(org.apache.coyote.Constants.STAGE_ENDOUTPUT);

    // If there was an error, make sure the request is counted as
    // and error, and update the statistics counter
    if (error) {
        response.setStatus(500);
    }
    request.updateCounters();

    if (!isAsync() &amp;&amp; !comet || error) {
        getInputBuffer().nextRequest();
        getOutputBuffer().nextRequest();
    }

    if (!disableUploadTimeout) {
        if(endpoint.getSoTimeout() &gt; 0) {
            setSocketTimeout(endpoint.getSoTimeout());
        } else {
            setSocketTimeout(0);
        }
    }

    rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);

    if (breakKeepAliveLoop(socketWrapper)) {
        break;
    }
}

rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);

if (error || endpoint.isPaused()) {
    return SocketState.CLOSED;
} else if (isAsync() || comet) {
    return SocketState.LONG;
} else if (isUpgrade()) {
    return SocketState.UPGRADING;
} else {
    if (sendfileInProgress) {
        return SocketState.SENDFILE;
    } else {
        if (openSocket) {
            if (readComplete) {
                return SocketState.OPEN;
            } else {
                return SocketState.LONG;
            }
        } else {
            return SocketState.CLOSED;
        }
    }
}
</code></pre>

<p>}</p>

<p>```
上面的代码有点长，但是经过分析，我们还是可以看清楚主干，我已经在代码中将主流程通过数字标注了，我们就来一一看看标注了数字的地方：</p>

<ol>
<li>标注1的地方（第7行）将Socket的输入流和输出流通过InternalInputBuffer进行了包装，InternalInputBuffer是在Http11Processor的构造函数中初始化的。</li>
<li>标注2的地方（第35行）调用了InternalInputBuffer的parseRequesLine方法解析http请求的请求行。(关于http请求行和请求头请看下文解释)</li>
<li>标注3的地方（第57行）调用了InternalInputBuffer的prarseHeaders方法解析http请求的请求头。解析完了以后，会将http header保存在<code>org.apache.tomcat.util.http.MimeHeaders</code></li>
<li>标注4的地方（第128行）调用了org.apache.coyote.Adapter#service方法，次方法就会最终调用到具体的Servlet.</li>
</ol>


<p>对于Http请求行和请求头，大家可以看下面的例子：
```js Http get request
GET /contextpath/querystring HTTP/1.1</p>

<p>Host: 127.0.0.1:8080</p>

<p>User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:23.0) Gecko/20100101 Firefox/23.0</p>

<p>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8</p>

<p>Accept-Language: en-US,en;q=0.5</p>

<p>Accept-Encoding: gzip, deflate</p>

<p>Cookie: JSESSIONID=9F5897FEF3CDBCB234C050C132DCAE52; <strong>atuvc=384%7C39; </strong>utma=96992031.358732763.1380383869.1381468490.1381554710.38; __utmz=96992031.1380383869.1.1.utmcsr=(direct)|utmccn=(direct)|utmcmd=(none); Hm_lvt_21e144d0df165d6556d664e2836dadfe=1381330561,1381368826,1381395666,1381554711</p>

<p>Connection: keep-alive</p>

<p>Cache-Control: max-age=0
<code>``
在上面的Http协议get请求中，其中请求行就是第一行，</code>GET /contextpath/querystring HTTP/1.1`,余下的都是请求头。这里面需要注意根据Http协议的要求，请求行末尾必须是CRLF，而请求行与请求头，以及请求头之间必须用空行隔开，而空行也必须只包含CRLF。对于Http协议请求头的规范可以参考<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html">这里</a>。</p>

<p>通过上面的描述，我们可以整理出如下的一个请求解析流程：
<code>java Request http header parse
org.apache.tomcat.util.net.JIoEndpoint.Acceptor#run
-&gt;org.apache.tomcat.util.net.JIoEndpoint.SocketProcessor#run(请求处理线程池中运行)
--&gt;org.apache.coyote.AbstractProtocol.AbstractConnectionHandler#process
---&gt;org.apache.coyote.http11.AbstractHttp11Processor#process
----&gt;org.apache.coyote.http11.InternalInputBuffer#parseRequestLine
----&gt;org.apache.coyote.http11.InternalInputBuffer#parseHeaders
----&gt;org.apache.catalina.connector.CoyoteAdapter#service
</code></p>

<h1>如何转发到Servlet</h1>

<p>上面我们说了一个请求过来是如何根据http协议解析Socket的数据，最终将生成<code>org.apache.coyote.Request</code>和<code>org.apache.coyote.Response</code>，接下来我们就来看看request,reponse是如何一步步的进入最终的Servlet进行处理的。这一步的入口就是CoyoteAdapter的service方法。
接下来我们就来看看它的代码：
```java org.apache.catalina.connector.CoyoteAdapter#service
public void service(org.apache.coyote.Request req,</p>

<pre><code>                org.apache.coyote.Response res)
throws Exception {


Request request = (Request) req.getNote(ADAPTER_NOTES);
Response response = (Response) res.getNote(ADAPTER_NOTES);

//1 
if (request == null) {

    // Create objects
    request = connector.createRequest();
    request.setCoyoteRequest(req);
    response = connector.createResponse();
    response.setCoyoteResponse(res);

    // Link objects
    request.setResponse(response);
    response.setRequest(request);

    // Set as notes
    req.setNote(ADAPTER_NOTES, request);
    res.setNote(ADAPTER_NOTES, response);

    // Set query string encoding
    req.getParameters().setQueryStringEncoding
        (connector.getURIEncoding());

}

if (connector.getXpoweredBy()) {
    response.addHeader("X-Powered-By", POWERED_BY);
}

boolean comet = false;
boolean async = false;

try {

    // Parse and set Catalina and configuration specific
    // request parameters
    req.getRequestProcessor().setWorkerThreadName(Thread.currentThread().getName());
    //2
    boolean postParseSuccess = postParseRequest(req, request, res, response);
    if (postParseSuccess) {
        //check valves if we support async
        request.setAsyncSupported(connector.getService().getContainer().getPipeline().isAsyncSupported());
        // Calling the container
        //3
        connector.getService().getContainer().getPipeline().getFirst().invoke(request, response);

        // other code

    }
    // other code

} catch (IOException e) {
    // Ignore
} finally {
    req.getRequestProcessor().setWorkerThreadName(null);
    // Recycle the wrapper request and response
    if (!comet &amp;&amp; !async) {
        request.recycle();
        response.recycle();
    } else {
        // Clear converters so that the minimum amount of memory
        // is used by this processor
        request.clearEncoders();
        response.clearEncoders();
    }
}
</code></pre>

<p>}
```
为了可以清楚的看到主流程，上面删除了一部分非主流程的代码，接下来我们逐一分析一下标注了数字的地方：</p>

<ol>
<li>标注1的代码(第9行)将<code>org.apache.coyote.Request</code>和<code>org.apache.coyote.Response</code>对象转变为<code>org.apache.catalina.connector.Request</code>,<code>org.apache.catalina.connector.Response</code>类型的对象。其中coyote包中的Request仅仅只是包含了解析出来的http协议的数据，而connector包中的Request才是真正Servlet容器中的HttpServletRequest，它里面包含了完成请求需要的host,context和wrapper信息,在这里每一个wrapper其实都对应web.xml配置的一个Servlet。</li>
<li>标注2（第44行）的代码调用了postParseRequest方法，这个方法里面做的事情非常多，但是最终都是为了根据Request对象找到对应的Host,Conext和Wrapper对象，也就是说最终要清楚这个请求应该由哪个Servlet来处理。</li>
<li>标注3（第50）的代码将已经设置好了Host,Context,Wrapper对象的Request通过Pipeline机制链式传递给最终的Servlet。</li>
</ol>


<p>上面只是从整体上告诉了读者<code>org.apache.catalina.connector.CoyoteAdapter#service</code>方法做的事情，接下来我们进一步分解每一个步骤都具体做了哪些工作。第一步比较简单，大家可以自己阅读，我们关键来看2，3步。首先我们来看看postParseRequest方法。
通过分析org.apache.catalina.connector.CoyoteAdapter#postParseRequest的代码，我们会发现它最终是通过<code>org.apache.tomcat.util.http.mapper.Mapper#map</code>方法来达到匹配请求到对应的Context和Wrapper(Servlet包装类)目的。具体代码如下：
```java org.apache.catalina.connector.CoyoteAdapter#postParseRequest
connector.getMapper().map(serverName, decodedURI, version,</p>

<pre><code>                                  request.getMappingData());
        request.setContext((Context) request.getMappingData().context);
        request.setWrapper((Wrapper) request.getMappingData().wrapper);
</code></pre>

<p><code>``
那我们再来看看此方法。通过分析它的代码，我们发现最终其实是调用了几个</code>internalMap**`方法将找到的Context,Wrapper设置到org.apache.catalina.connector.Request对象的org.apache.tomcat.util.http.mapper.MappingData类型的属性中,map方法执行完以后，然后接下来就从MappingData中获取已经找到的Context和Wrapper，再设置到Request的context和wrapper中。</p>

<p>接下来我们再来分析第3步，第3步通过pipeline链式调用机制最终调用了Servlet对象，而对于pipeline其实是运用了责任链模式，它将各个阀门链接起来，然后一步步的调用，而至于有多少个阀门（Valve）对象，主要来源于两个地方，一个是conf/server.xml中配置的valve，我们知道所有的容器都是支持pipeline机制的，另外一个就是每一个容器的构造其中自己初始化的阀门对象。接下来一一看一下。对于StandardEngine来说有一个与之对应的StandardEngineValve，对于StandardHost有一个StandardHostValve与之对应，StandardContext有一个StandardContextValve与之对应，StandardWrapper与StandardWrapperValve对应,通过分析代码，我们可以得到如下的一个调用链。
<code>java
-&gt;org.apache.catalina.core.StandardEngineValve#invoke
--&gt;org.apache.catalina.valves.AccessLogValve#invoke
---&gt;org.apache.catalina.valves.ErrorReportValve#invoke
----&gt;org.apache.catalina.core.StandardHostValve#invoke
-----&gt;org.apache.catalina.authenticator.AuthenticatorBase#invoke
------&gt;org.apache.catalina.core.StandardContextValve#invoke
-------&gt;org.apache.catalina.core.StandardWrapperValve#invoke
</code>
上述的调用栈中，最后会调用到StandardWrapperValve，它其实也是最终调用Servlet的地方，接下来我们就来看看它的代码：
```java
public final void invoke(Request request, Response response)</p>

<pre><code>throws IOException, ServletException {

// Initialize local variables we may need
boolean unavailable = false;
Throwable throwable = null;
// This should be a Request attribute...
long t1=System.currentTimeMillis();
requestCount++;
StandardWrapper wrapper = (StandardWrapper) getContainer();
Servlet servlet = null;
Context context = (Context) wrapper.getParent();


// Allocate a servlet instance to process this request
try {
    //1
    if (!unavailable) {
        servlet = wrapper.allocate();
    }
} catch (UnavailableException e) {
    container.getLogger().error(
            sm.getString("standardWrapper.allocateException",
                    wrapper.getName()), e);
    long available = wrapper.getAvailable();
    if ((available &gt; 0L) &amp;&amp; (available &lt; Long.MAX_VALUE)) {
        response.setDateHeader("Retry-After", available);
        response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,
                   sm.getString("standardWrapper.isUnavailable",
                                wrapper.getName()));
    } else if (available == Long.MAX_VALUE) {
        response.sendError(HttpServletResponse.SC_NOT_FOUND,
                   sm.getString("standardWrapper.notFound",
                                wrapper.getName()));
    }
} // other code

MessageBytes requestPathMB = request.getRequestPathMB();
DispatcherType dispatcherType = DispatcherType.REQUEST;
if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC; 
request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);
request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,
        requestPathMB);
// Create the filter chain for this request
ApplicationFilterFactory factory =
    ApplicationFilterFactory.getInstance();
ApplicationFilterChain filterChain =
    factory.createFilterChain(request, wrapper, servlet);

// Reset comet flag value after creating the filter chain
request.setComet(false);

// Call the filter chain for this request
// NOTE: This also calls the servlet's service() method
// 2 
try {
    if ((servlet != null) &amp;&amp; (filterChain != null)) {
        // Swallow output if needed
        if (context.getSwallowOutput()) {
            try {
                SystemLogHandler.startCapture();
                if (request.isAsyncDispatching()) {
                    //TODO SERVLET3 - async
                    ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch(); 
                } else if (comet) {
                    filterChain.doFilterEvent(request.getEvent());
                    request.setComet(true);
                } else {
                    filterChain.doFilter(request.getRequest(), 
                            response.getResponse());
                }
            } finally {
                String log = SystemLogHandler.stopCapture();
                if (log != null &amp;&amp; log.length() &gt; 0) {
                    context.getLogger().info(log);
                }
            }
        } else {
            if (request.isAsyncDispatching()) {
                //TODO SERVLET3 - async
                ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();
            } else if (comet) {
                request.setComet(true);
                filterChain.doFilterEvent(request.getEvent());
            } else {
                filterChain.doFilter
                    (request.getRequest(), response.getResponse());
            }
        }

    }
} catch(Exception e){
// other code
}
</code></pre>

<p>}
```
为了节省版面，上面的代码已经删除非主流程的代码。接下来我们逐一分析一下标注了数字的地方：</p>

<ol>
<li>标注1（第17行）的代码实例化了Servlet对象，在实例化的过程中使用了Java双检查锁的机制来实例化Servlet，有兴趣的童鞋可以去看看org.apache.catalina.core.StandardWrapper#allocate的代码。这里需要注意的是在Servlet2.4规范之前，有一个singleThreadMode模型，这个机制类似与之前EJB的无状态会话Bean机制，每个线程过来会通过实例池中取出一个实例来完成响应。在Servlet规范2.4之后，单线程模型已经被废除了。具体细节可以参考<a href="http://docs.oracle.com/javaee/5/api/javax/servlet/SingleThreadModel.html">这里</a> .</li>
<li>标注2（第55行）的代码其实调用了大家熟悉的Servlet的过滤器链，过滤器链最终就会调用到Servlet.</li>
</ol>


<p>最后，咋们再来看看过滤器滤链的处理，来看看<code>org.apache.catalina.core.ApplicationFilterChain#doFilter</code>，doFilter方法中会根据filterConfig中取的web.xml配置的过滤器，然后一个个调用，等每个过滤器执行完了以后，最终就会调用到Servlet的Service方法。</p>

<p>通过上面的分析，其实我们已经清楚了一个请求过来以后，Tomcat是如何一步步处理的。我们再来做一个总体的总结：</p>

<ol>
<li>用户浏览器发送请求，请求会发送到对应的Connector监听的Socket端口。</li>
<li>Connector从Socket流中获取数据，然后根据Http协议将其解析为Request和Reponse对象</li>
<li>找到Request对象对应的Host,Context,Wrapper</li>
<li>调用最终的Servelt的service进行处理。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tomcat关闭过程（Tomcat源代码阅读系列之四）]]></title>
    <link href="http://imtiger.github.io/blog/2013/10/21/tomcat-shutdown/"/>
    <updated>2013-10-21T14:45:00+08:00</updated>
    <id>http://imtiger.github.io/blog/2013/10/21/tomcat-shutdown</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/10/14/apache_tomcat_bag.jpg">
本文是<a href="/blog/2013/10/08/tomcat-source-code-study/">Tomcat源代码阅读系列</a>的第四篇文章，在阅读此文之前，建议先读前三篇：<br/>
<a href="/blog/2013/10/14/run-tomcat-in-idea-or-eclipse/">在IntelliJ IDEA 和 Eclipse运行tomcat 7源代码（Tomcat源代码阅读系列之一）</a> <br/>
<a href="/blog/2013/10/16/tomcat-architecture/">Tomcat总体结构                             （Tomcat源代码阅读系列之二）</a><br/>
<a href="/blog/2013/10/17/tomcat-start-process/">Tomcat启动过程（Tomcat源代码阅读系列之三）</a></p>

<p>我们在<a href="/blog/2013/10/17/tomcat-start-process/">Tomcat启动过程（Tomcat源代码阅读系列之三）</a>一文中已经知道Tomcat启动以后，会启动6条线程，他们分别如下：</p>

<!-- more -->


<p>```java Tomcat threads
&ldquo;ajp-bio-8009-AsyncTimeout&rdquo; daemon prio=5 tid=7f8738afe000 nid=0x115ad6000 waiting on condition [115ad5000]</p>

<p>&ldquo;ajp-bio-8009-Acceptor-0&rdquo; daemon prio=5 tid=7f8738b05800 nid=0x1159d3000 runnable [1159d2000]</p>

<p>&ldquo;http-bio-8080-AsyncTimeout&rdquo; daemon prio=5 tid=7f8735acb800 nid=0x1158d0000 waiting on condition [1158cf000]</p>

<p>&ldquo;http-bio-8080-Acceptor-0&rdquo; daemon prio=5 tid=7f8735acd000 nid=0x1157cd000 runnable [1157cc000]</p>

<p>&ldquo;ContainerBackgroundProcessor[StandardEngine[Catalina]]&rdquo; daemon prio=5 tid=7f8732850800 nid=0x111203000 waiting on condition [111202000]</p>

<p>&ldquo;main&rdquo; prio=5 tid=7f8735000800 nid=0x10843e000 runnable [10843c000]
```</p>

<p>其中5条是Dameon线程，而对于Java程序来说，当所有非Dameon程序都终止的时候，Jvm就会退出，因此要想终止Tomcat就只需要将main这一条非Dameon线程终止了即可。</p>

<blockquote><p>Dameon线程又叫后台或者守护线程，它负责在程序运行期提供一种通用服务的线程，比如垃圾收集线程，非Dameon线程和Dameon线程的区别就在于当程序中所有的非Daemon线程都终止的时候，Jvm会杀死余下的Dameon线程，然后退出。</p></blockquote>

<p>接下来，我们就来一步步的分析如何来让main线程终止，要想终止它，我们还是得从Tomcat的启动中来寻找答案，我们在分析Tomcat容器启动的时候，在Catalina#start中有一段代码，我们没有关注，接下来就来看看这段代码：
```java org.apache.catalina.startup.Catalina#start
public void start() {</p>

<pre><code>// ignore other code 

// Register shutdown hook
// 1 
if (useShutdownHook) {
    if (shutdownHook == null) {
        shutdownHook = new CatalinaShutdownHook();
    }
    Runtime.getRuntime().addShutdownHook(shutdownHook);

    // If JULI is being used, disable JULI's shutdown hook since
    // shutdown hooks run in parallel and log messages may be lost
    // if JULI's hook completes before the CatalinaShutdownHook()
    LogManager logManager = LogManager.getLogManager();
    if (logManager instanceof ClassLoaderLogManager) {
        ((ClassLoaderLogManager) logManager).setUseShutdownHook(
                false);
    }
}

// 2
if (await) {
    await();
    stop();
}
</code></pre>

<p>}</p>

<p>```</p>

<p>这里就是Tomcat关闭流程的入口代码了。我在代码中标注了两处，我们首先来看标注1的地方。标注1的代码，我们用到了Jvm的shutdownHook机制。对于shutdownHook大家可以参考<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Runtime.html#addShutdownHook%28java.lang.Thread%29">这个连接</a>,我这里做一个简单的介绍，shutdown hook是一个已经初始化但是还没有启动的线程，当Jvm关闭的时候，它会启动并并发的运行所有已经注册过的shutdown hooks，知道了这点，我们就来看看<code>CatalinaShutdownHook</code>线程做了什么事情？它的代码如下：
```java org.apache.catalina.startup.Catalina.CatalinaShutdownHook#run</p>

<p>public void run() {</p>

<pre><code>try {
    if (getServer() != null) {
        Catalina.this.stop();
    }
} catch (Throwable ex) {
    ExceptionUtils.handleThrowable(ex);
    log.error(sm.getString("catalina.shutdownHookFail"), ex);
} finally {
    // If JULI is used, shut JULI down *after* the server shuts down
    // so log messages aren't lost
    LogManager logManager = LogManager.getLogManager();
    if (logManager instanceof ClassLoaderLogManager) {
        ((ClassLoaderLogManager) logManager).shutdown();
    }
}
</code></pre>

<p>}
```
通过上面的代码，我们可以清楚的看到调用了Catalina的stop方法。而Catalina#stop方法最终又是调用了StandardServer#stop方法和destroy方法。通过这里，我们知道Tomcat利用了shutdown hook机制来在Jvm关闭的时候关闭各个组件。但是Jvm又是何时退出的呢？这就要来看标注为2的代码了。</p>

<p>接下来我们再来看看标注2的地方：在标注为2的代码中，首先判断了await属性是否为true,如果为true就调用await()，调用完以后，再调用stop方法，接下来我们就来看await()方法,而catalina的awit方法又调用了StandardServer#awit方法，它的代码如下：
```java org.apache.catalina.core.StandardServer#await
public void await() {</p>

<pre><code>// Set up a server socket to wait on
try {
    awaitSocket = new ServerSocket(port, 1,
            InetAddress.getByName(address));
} catch (IOException e) {
    log.error("StandardServer.await: create[" + address
                       + ":" + port
                       + "]: ", e);
    return;
}

try {
    awaitThread = Thread.currentThread();

    // Loop waiting for a connection and a valid command
    while (!stopAwait) {
        ServerSocket serverSocket = awaitSocket;
        if (serverSocket == null) {
            break;
        }

        // Wait for the next connection
        Socket socket = null;
        StringBuilder command = new StringBuilder();
        try {
            InputStream stream;
            try {
                socket = serverSocket.accept();
                socket.setSoTimeout(10 * 1000);  // Ten seconds
                stream = socket.getInputStream();
            } catch (AccessControlException ace) {
                log.warn("StandardServer.accept security exception: "
                        + ace.getMessage(), ace);
                continue;
            } catch (IOException e) {
                if (stopAwait) {
                    // Wait was aborted with socket.close()
                    break;
                }
                log.error("StandardServer.await: accept: ", e);
                break;
            }

            // Read a set of characters from the socket
            int expected = 1024; // Cut off to avoid DoS attack
            while (expected &lt; shutdown.length()) {
                if (random == null)
                    random = new Random();
                expected += (random.nextInt() % 1024);
            }
            while (expected &gt; 0) {
                int ch = -1;
                try {
                    ch = stream.read();
                } catch (IOException e) {
                    log.warn("StandardServer.await: read: ", e);
                    ch = -1;
                }
                if (ch &lt; 32)  // Control character or EOF terminates loop
                    break;
                command.append((char) ch);
                expected--;
            }
        } finally {
            // Close the socket now that we are done with it
            try {
                if (socket != null) {
                    socket.close();
                }
            } catch (IOException e) {
                // Ignore
            }
        }

        // Match against our command string
        boolean match = command.toString().equals(shutdown);
        if (match) {
            log.info(sm.getString("standardServer.shutdownViaPort"));
            break;
        } else
            log.warn("StandardServer.await: Invalid command '"
                    + command.toString() + "' received");
    }
} finally {
    ServerSocket serverSocket = awaitSocket;
    awaitThread = null;
    awaitSocket = null;

    // Close the server socket and return
    if (serverSocket != null) {
        try {
            serverSocket.close();
        } catch (IOException e) {
            // Ignore
        }
    }
}
</code></pre>

<p>}
```</p>

<p>通过上面的代码，我们可以看出在配置的端口上通过ServerSocket来监听一个请求的到来，如果请求的字符串和配置的字符串相同的话即跳出循环，这样的话就会运行stop方法，运行完了以后，main线程就退出了。</p>

<blockquote><p>这里ServerSocket监听的端口，以及对比的字符串都是在conf/server.xml中配置的，缺省情况下，配置如下：<Server port="8005" shutdown="SHUTDOWN"></Server>,从这里可以看出监听端口为8005,关闭请求发送的字符串为SHUTDOWN.</p></blockquote>

<p>看到这里，我们基本上已经清楚了Tomcat的关闭就是通过在8005端口，发送一个SHUTDOWN字符串。那么我们就来实验一下。首先启动Tomcat，然后在终端运行如下指令：
<code>bash telnet
telnet 127.0.0.1 8005
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
SHUTDOWN
Connection closed by foreign host.
</code>
运行telnet命令，并发送SHUTDOWN字符串以后，我们发现Tomcat就会退出await方法，然后执行stop方法最终停止。</p>

<p>但是一般情况下，我们停止tomcat都不会像上面那种方式来关闭，我们一般有两种方式来关闭：</p>

<ol>
<li>ps aux | grep java ,kill -9 <pid><br/>
对于这种方式，比较简单粗暴会直接干掉进程，不过这种简单粗暴的方式我也经常用。</li>
<li>运行shutdown.sh<br/>
这种方式其实最终也是向server发送了一个SHUTDOWN字符串，我们接下来分析下第二种情况。<br/>
查看shutdown.sh最终是调用了 catalina.sh，并传递了stop参数。查看catalina.sh脚本，最终其实是调用了 <code>org.apache.catalina.startup.Bootstrap#main</code>,并传递参数stop.我们查看Bootstrap#main方法，发现会调用<code>org.apache.catalina.startup.Bootstrap#stopServer</code>,而Bootstrap#stopServer通过反射调用了<code>org.apache.catalina.startup.Catalina#stopServer</code>,我们来看看Catalina#stopServer方法，代码如下：
```java org.apache.catalina.startup.Catalina#stopServer</li>
</ol>


<p>public void stopServer(String[] arguments) {</p>

<pre><code>if (arguments != null) {
    arguments(arguments);
}

Server s = getServer();
// 1 
if( s == null ) {
    // Create and execute our Digester
    Digester digester = createStopDigester();
    digester.setClassLoader(Thread.currentThread().getContextClassLoader());
    File file = configFile();
    FileInputStream fis = null;
    try {
        InputSource is =
            new InputSource(file.toURI().toURL().toString());
        fis = new FileInputStream(file);
        is.setByteStream(fis);
        digester.push(this);
        digester.parse(is);
    } catch (Exception e) {
        log.error("Catalina.stop: ", e);
        System.exit(1);
    } finally {
        if (fis != null) {
            try {
                fis.close();
            } catch (IOException e) {
                // Ignore
            }
        }
    }
} else {
    // Server object already present. Must be running as a service
    try {
        s.stop();
    } catch (LifecycleException e) {
        log.error("Catalina.stop: ", e);
    }
    return;
}

// Stop the existing server
s = getServer();
// 2
if (s.getPort()&gt;0) {
    Socket socket = null;
    OutputStream stream = null;
    try {
        socket = new Socket(s.getAddress(), s.getPort());
        stream = socket.getOutputStream();
        String shutdown = s.getShutdown();
        for (int i = 0; i &lt; shutdown.length(); i++) {
            stream.write(shutdown.charAt(i));
        }
        stream.flush();
    } catch (ConnectException ce) {
        log.error(sm.getString("catalina.stopServer.connectException",
                               s.getAddress(),
                               String.valueOf(s.getPort())));
        log.error("Catalina.stop: ", ce);
        System.exit(1);
    } catch (IOException e) {
        log.error("Catalina.stop: ", e);
        System.exit(1);
    } finally {
        if (stream != null) {
            try {
                stream.close();
            } catch (IOException e) {
                // Ignore
            }
        }
        if (socket != null) {
            try {
                socket.close();
            } catch (IOException e) {
                // Ignore
            }
        }
    }
} else {
    log.error(sm.getString("catalina.stopServer"));
    System.exit(1);
}
</code></pre>

<p>}
```
我们来分析一下标注的地方：</p>

<ol>
<li>标注1的代码，此时因为是新开了一个进程,并且conf/server.xml还没有解析，因此s是NULL，通过Digester解析conf/server.xml，最终生成了未初始化的StandardServer对象。</li>
<li>标注2的代码，向standardServer.getPort返回的端口（其实这里面返回即是conf/server.xml中Server根节点配置的port和shutdown属性）发送了standardServer.getShutdown()返回的字符串，而默认情况下这个字符串就是SHUTDOWN.</li>
</ol>


<p>分析到这里，我想大家已经清楚了Tomcat的关闭流程，我们再来总结一下：
Tomcat启动的时候的主线程会在8005端口（默认配置，可以更改）上建立socket监听，当关闭的时候，最终其实就是新起了一个进程然后向Tomcat主线程监听的8005端口发送了一个SHUTDOWN字符串，这样主线程就会结束了，主线程结束了以后，因为其它的线程都是dameon线程，这样依赖Jvm就会退出了。</p>
]]></content>
  </entry>
  
</feed>
